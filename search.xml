<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>podman容器</title>
      <link href="/2025/05/28/rong-qi-ji-zhu/podman-rong-qi/"/>
      <url>/2025/05/28/rong-qi-ji-zhu/podman-rong-qi/</url>
      
        <content type="html"><![CDATA[<h1 id="1-容器的概念"><a href="#1-容器的概念" class="headerlink" title="1 容器的概念"></a>1 容器的概念</h1><h2 id="1-1-容器技术介绍"><a href="#1-1-容器技术介绍" class="headerlink" title="1.1 容器技术介绍"></a>1.1 容器技术介绍</h2><p>  软件应用通常依赖于运行时环境(runtimeenvironment)提供的系统库、配置文件或服务</p><p>  传统软件应用的运行时环境安装在物理主机或虚拟机上运行的操作系统中。然后，管理员在操作系统上安装应用依赖项</p><p>  在红帽企业Linux中，诸如RPM等打包系统可协助管理员管理应用依赖项。安装httpd软件包时，RPM系统会确保同时安装该软件包的正确库和其他依赖项</p><p>  传统方式部署软件应用的主要弊端是这些依赖项会受到运行时环境的束缚，应用需要的支持软件的版本可能比操作系统提供的软件更旧或更新，同一系统上的两个应用可能需要同一软件互不兼容的不同版本，解决这些冲突的方式之一是将应用打包并作为容器进行部署</p><p>  容器是由一个或多个与系统其余部分隔离的进程组成的集合，软件容器是打包应用以简化其部署和管理的一种方式</p><p>  以实体集装箱为例。集装箱是打包和装运货物的标准方式。作为一个箱子进行标记、装载、卸载，以及从一个位置运输到另一个位置。集装箱中的内容与其他集装箱的内容隔离，因此互不影响。这些基本原则也适用于软件容器</p><h2 id="1-2-容器技术的核心"><a href="#1-2-容器技术的核心" class="headerlink" title="1.2 容器技术的核心"></a>1.2 容器技术的核心</h2><p>  红帽企业Linux通过运用以下核心技术来支持容器:</p><p>   1.用于资源管理的控制组(cgroups)</p><p>   2.用于进程隔离的命名空间</p><p>   3.加强安全边界的SELinux和Seccomp安全计算模式</p><h2 id="1-3-容器和虚拟机的差异"><a href="#1-3-容器和虚拟机的差异" class="headerlink" title="1.3 容器和虚拟机的差异"></a><strong>1.3 容器和虚拟机的差异</strong></h2><p>  1.容器提供许多与虚拟机相同的益处，如安全、存储和网络隔离等</p><p>  2.这两种技术都将其应用库和运行时资源与主机操作系统或虚拟机监控程序隔离开</p><p>  3.容器和虚拟机以不同的方式与硬件和底层操作系统交互</p><p>  4.虚拟机具有以下特征:</p><p>   4.1 使多个操作系统能够同时在一个硬件平台上运行</p><p>   4.2 使用虚拟机监控程序将硬件分为多个虚拟硬件系统</p><p>   4.3 需要一个完整的操作系统环境来支持该应用</p><p>  5.容器具有以下特征:</p><p>   5.1 直接在操作系统上运行，从而跨系统上的所有容器共享资源</p><p>   5.2 共享主机的内核，但它将应用进程与系统其余部分隔离开来</p><p>   5.3 与虚拟机相比，它需要的硬件资源要少得多，因此容器的启动速度也更快</p><p>   5.4 包括所有依赖项，如系统和编程依赖项，以及配置设置</p><h2 id="1-4-Rootless和Rootful容器"><a href="#1-4-Rootless和Rootful容器" class="headerlink" title="1.4 Rootless和Rootful容器"></a><strong>1.4 Rootless和Rootful容器</strong></h2><p>  在容器主机上，特权用户运行的容器称为Rootful容器、非特权用户运行的容器称为Rootless容器</p><p>  Rootless容器不允许使用通常为特权用户保留的系统资源，例如访问受限目录、在受限端口(1024以下的端口)上发布网络服务，此功能可防止潜在攻击者获取容器主机上的root特权</p><p>  可使用root用户身份直接运行容器，但如果有漏洞允许攻击者破坏容器，这样做会削弱系统的安全性</p><h2 id="1-5-设计基于容器的架构"><a href="#1-5-设计基于容器的架构" class="headerlink" title="1.5 设计基于容器的架构"></a><strong>1.5 设计基于容器的架构</strong></h2><p>  容器是重复利用托管应用并使其可以移植的有效方式</p><p>  容器可以轻松地从一个环境迁移到另一个环境，如从开发环境迁移到生产环境</p><p>  可以保存一个容器的多个版本，并根据需要快速访问每个版本</p><p>  容器通常是临时的，可将运行中容器所生成的数据永久保存到持久存储中，但容器本身通常会在需要时运行，然后停止并被删除，下次需要该特定容器时，将启动新的容器进程</p><p>  可以在单个容器中安装含有多个服务的复杂软件应用。例如，Web服务器可能需要使用数据库和消息传递系统。不过，将一个容器用于多个服务会难以管理</p><p>  更好的设计是在单独的容器中运行每个组件、Web服务器、数据库和消息传递系统。这样，更新和维护单个应用组件不会影响其他组件或应用堆栈</p><h1 id="2-容器镜像和注册表"><a href="#2-容器镜像和注册表" class="headerlink" title="2 容器镜像和注册表"></a>2 容器镜像和注册表</h1><p>  运行容器必须使用容器镜像：</p><p>  1.容器镜像是包含编码步骤的静态文件，充当创建容器的蓝图</p><p>  2.容器镜像打包应用及其所有依赖项，如系统库、编程语言运行时和库以及其他配置设置</p><p>  3.容器镜像根据规范构建，如开放容器项目(OCI)镜像格式规范。这些规范定义容器镜像的格式，以及镜像支持的容器主机操作系统和硬件架构的元数据</p><p>  4.容器注册表是用于存储和检索容器镜像的存储库。开发人员将容器镜像推送或上传到容器注册表中，可以从注册表中将这些容器镜像拉取或下载到本地系统，以用于运行容器。可使用包含第三方镜像的公共注册表，也可使用贵组织控制的私有注册表</p><p>  5.容器镜像来源很重要。和任何其他软件包一样，必须知道是否可以信任容器镜像中的代码。对于是否及如何提供、评估和测试提交给它们的容器镜像，不同的注册表具有不同的策略</p><p>  红帽通过两个主容器注册表分发认证容器镜像，可以使用红帽登录凭据来访问这两个注册表:</p><p>  1.utility.redhat.io: 适用于基于官方红帽产品的容器</p><p>  2.utilityconnect.redhat,com:适用于基于第三方产品的容器</p><p>  3.红帽容器目录(<a href="https://access.redhat.com/containers)%E6%8F%90%E4%BE%9B%E4%BA%86%E4%B8%80%E4%B8%AA%E5%9F%BA%E4%BA%8EWeb%E7%9A%84%E7%95%8C%E9%9D%A2%EF%BC%8C%E9%80%9A%E8%BF%87%E5%AE%83%E5%8F%AF%E4%BB%A5%E6%90%9C%E7%B4%A2%E8%BF%99%E4%BA%9B%E6%B3%A8%E5%86%8C%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%AE%A4%E8%AF%81%E5%86%85%E5%AE%B9">https://access.redhat.com/containers)提供了一个基于Web的界面，通过它可以搜索这些注册表中的认证内容</a></p><h2 id="2-1-安装容器"><a href="#2-1-安装容器" class="headerlink" title="2.1 安装容器"></a>2.1 安装容器</h2><p>  使用的镜像仓库浏览器访问为: <a href="https://utility/">https://utility</a> 账号&amp;密码是:admin/redhat321</p><p>  镜像对应的地址为:utility.lab.example.com</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[kiosk@foundation0 ~]$ cat /etc/hosts127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4::1         localhost localhost.localdomain localhost6 localhost6.localdomain6### rht-vm-hosts file listing the entries to be appended to /etc/hosts172.25.250.254 bastion.lab.example.com bastion172.25.250.10  servera.lab.example.com servera172.25.250.11  serverb.lab.example.com serverb172.25.250.220 utility.lab.example.com utility172.25.250.9   workstation.lab.example.com workstation# 登录servera请使用ssh方式，不要使用su切换。[root@foundation0 ~]# ssh root@servera[root@servera ~]# ssh student@localhost[student@servera ~]$ sudo dnf -y install container-tools    # 安装podman容器 [student@servera ~]$ podman --version<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-2-登录容器"><a href="#2-2-登录容器" class="headerlink" title="2.2 登录容器"></a>2.2 登录容器</h2><p>  需要红帽开发人员账户才能从红帽注册表下载镜像。可以使用podman login命令对注册表进行身份验证。如果不向podman login命令提供注册表URL，它会向默认配置的注册表进行身份验证</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ podman login --help# 登录方法一(交互)：$ podman login utility.lab.example.com Username: adminPassword: redhat321Login Succeeded!# 登录方法二(非交互)： #$ podman login utility.lab.example.com -u admin -p redhat321  # 生产环境中是有https验证的Login Succeeded![student@servera ~]$ podman login -u admin -p redhat321 utility.lab.example.comError: authenticating creds for "utility.lab.example.com": pinging container registry utility.lab.example.com: Get "https://utility.lab.example.com/v2/": tls: failed to verify certificate: x509: certificate is not valid for any names, but wanted to match utility.lab.example.com# 如果出现以上报错，是要求https验证，需要通过选项--tls-verify进行手动关闭$ podman login utility.lab.example.com -u admin -p redhat321 --tls-verify=false[student@servera ~]$ podman login --help[student@servera ~]$ podman login -u admin -p redhat321 utility.lab.example.com --tls-verify=falseLogin Succeeded!# 登录方法三(非交互):# 使用podman login命令的--username和--password-sdtin选项，指定用于登录注册表的用户和密码# --password-stdin选项从stdin读取密码# 红帽建议不要使用--password选项直接提供密码，因为此选项会将密码存储在日志文件中$ echo redhat321 | podman login -u admin --password-stdin utility.lab.example.com  Login Succeeded!<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-3-验证容器的登录"><a href="#2-3-验证容器的登录" class="headerlink" title="2.3 验证容器的登录"></a>2.3 验证容器的登录</h2><p>  要验证是否已登录到某一注册表，请使用 podman login命令的–get-login选项</p><p>  退出登录：podman logout</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ podman login --get-login   # 查看登录的用户admin[student@servera ~]$ podman login utility.lab.example.com --get-login    # 指定仓库地址，查看登录用户admin[student@servera ~]$ podman logout utility.lab.example.com  # 登出Removed login credentials for utility.lab.example.com<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-4-配置容器注册表"><a href="#2-4-配置容器注册表" class="headerlink" title="2.4 配置容器注册表"></a><strong>2.4 配置容器注册表</strong></h2><p>  容器注册表的默认配置文件是： /etc/containers/registries.conf</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[student@servera ~]$ sudo vim /etc/containers/registries.conf[sudo] password for student: student#第22行 指定可搜索的镜像仓库地址，如果使用完全合格域名，此处可以留空unqualified-search-registries = ["utility.lab.example.com","registry.access.redhat.com","registry.redhat.io","docker.io"][[utility]]   #第24行 解除注释开启以下功能insecure = true    #false/true 开启https安全验证/关闭安全验证blocked = false    #第40行 需要过滤掉的镜像仓库地址location = "utility.lab.example.com" #第56行 指定容器注册表位置# $注意 ~/.config/containers/registries.conf目录设置会覆盖/etc/containers/registries.conf# 推荐：【student】$ mkdir -p ~/.config/containers$ cp /etc/containers/registries.conf ~/.config/containers/registries.conf$ vim ~/.config/containers/registries.confunqualified-search-registries = ["utility.lab.example.com"] [[utility]]   insecure = true blocked = false    location = "utility.lab.example.com" # 登录容器注册表[student@servera ~]$ podman login -u admin -p redhat321 utility.lab.example.comLogin Succeeded!# 根据仓库地址搜索镜像[student@servera ~]$ podman search utility.lab.example.com/# 如果只访问本地仓库，unqualified-search-registries = ["utility.lab.example.com"]默认即可，但要需要访问外网，需要用root用户修改vim /etc/resolv.conf文件内容添加nameserver 8.8.8.8 优先解析。# 阿里容器 i2kldsde.mirror.aliyuncs.com<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-5-容器文件构建容器镜像"><a href="#2-5-容器文件构建容器镜像" class="headerlink" title="2.5 容器文件构建容器镜像"></a>2.5 容器文件构建容器镜像</h2><p>  容器文件是一种文本文件，内含用于构建容器镜像的指令</p><p>  容器文件通常具有定义其文件和目录所在路径或URL的上下文。生成的容器镜像由只读层组成，每一层代表容器文件中的一条指令</p><p>  以下是一个容器文件示例，它使用utility.access.redhat.com注册表中的UBI镜像,安装python3 软件包，并将hello字符串打印到控制台</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ cat ContainerfileFROM utility.access.redhat.com/ubi8/ubi:latestRUN dnf install -y python3CMD["/bin/bash"，"-c"，"echo hello"]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-6-规模化容器管理"><a href="#2-6-规模化容器管理" class="headerlink" title="2.6 规模化容器管理"></a>2.6 规模化容器管理</h2><p>  新应用越来越多地使用容器来实施功能组件，这些容器提供应用的其他部分使用的服务</p><p>  组织管理越来越多的容器，可能很快就会不堪重负</p><p>  在生产中大规模部署容器需要一个能够应对以下挑战的环境：</p><p>   1.平台必须确保提供必要服务的容器的可用性</p><p>   2.环境必须通过增加或减少运行中的容器实例，并对流量进行负载平衡，从而应对应用的使用高峰</p><p>   3.平台必须检测容器或主机的故障，并相应地作出反应</p><p>   4.开发人员可能需要自动工作流，以便透明、安全地向客户交付新的应用版本</p><p>  Kubernetes是一项编排服务，可以使在容器主机集群中部署、管理和扩展基于容器的应用变得更加轻而易举</p><p>  Kubernetes通过负载平衡器将流量重定向到容器，以便可以扩展提供服务的容器数量</p><p>  Kubernetes支持用户定义的健康检查，以便监控您的容器，并在容器出现故障时将其重新启动</p><p>  红帽提供了一个名为红帽OpenShift 的kubernetes发行版。OpenShift是基于Kubernetes基础架构构建的一组模块化组件和服务，为开发人员提供的额外功能包括基于Web的远程管理、多租户、监控与审计、高级安全功能、应用生命周期管理和自助服务实例等</p><h1 id="3-部署容器"><a href="#3-部署容器" class="headerlink" title="3 部署容器"></a><strong>3 部署容器</strong></h1><h2 id="3-1-Podman实用程序"><a href="#3-1-Podman实用程序" class="headerlink" title="3.1 Podman实用程序"></a>3.1 Podman实用程序</h2><p>  Podman是来自container-tools元数据包的全功能容器引警，用于管理开放容器计划(OCI)容器和镜像</p><p>  podman实用程序的运作不使用守护进程，因此开发人员无需系统上的特权用户帐户来启动或停止容器</p><p>  Podman提供多个子命令来与容器和镜像交互</p><p>  Podman的命令如下表：</p><table><thead><tr><th align="left">命令</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">podman build</td><td align="left">使用容器文件构建容器镜像</td></tr><tr><td align="left">podman run</td><td align="left">在新容器中运行命令</td></tr><tr><td align="left">podman images</td><td align="left">列出本地存储中的镜像</td></tr><tr><td align="left">podman ps</td><td align="left">打印有关容器的信息</td></tr><tr><td align="left">podman inspect</td><td align="left">显示容器、镜像、卷、网络或容器集的配置</td></tr><tr><td align="left">podman pull</td><td align="left">从注册表下载镜像</td></tr><tr><td align="left">podman cp</td><td align="left">在容器和本地文件系统之间复制文件或目录</td></tr><tr><td align="left">podman exec</td><td align="left">在运行中的容器内执行命令</td></tr><tr><td align="left">podman rm</td><td align="left">删除一个或多个容器</td></tr><tr><td align="left">podman rmi</td><td align="left">删除一个或多个本地存储的镜像</td></tr><tr><td align="left">podman search</td><td align="left">在注册表中搜索镜像</td></tr></tbody></table><p>  有关各个子命令使用帮助手册的更多信息，将子命令附加到podman命令，并用连字符将两者分隔。例如，podman-build帮助手册介绍了podman build子命令的用法</p><h2 id="3-2-安装容器实用工具"><a href="#3-2-安装容器实用工具" class="headerlink" title="3.2 安装容器实用工具"></a>3.2 安装容器实用工具</h2><p>  container-tools软件包包含与容器和容器镜像交互所需的实用程序</p><p>  若要在系统上下载、运行和比较容器，使用dnf install命令来安装container-tools元软件包</p><p>  使用dnf info命令查看container-tools软件包的版本和内容</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[student@servera ~]$ sudo dnf -y install container-tools    # 安装podman容器 [student@servera ~]$ podman --version[student@servera ~]$ dnf info container-tools<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>  container-tools元数据包提供所需的podman和skope实用程序，用于完成分配的任务</p><h2 id="3-3-从注册表下载容器镜像文件"><a href="#3-3-从注册表下载容器镜像文件" class="headerlink" title="3.3 从注册表下载容器镜像文件"></a>3.3 从注册表下载容器镜像文件</h2><p>  1.确保podman实用程序已配置为从utility.lab.example.com注册表搜索和下载容器</p><p>  2.podman info命令显示podman实用程序的配置信息，包括其配置的注册表</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[student@servera ~]$ podman info<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>  podman search命令使用registries.conf文件中指定的注册表列表搜索匹配的名称镜像。默认情况下，Podman在所有非限定搜索注册表中执行搜索</p><p>  使用podman search命令，显示包含python-38软件包的已配置注册表的镜像列表</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 在注册表中搜索镜像[student@servera ~]$ podman search utility.lab.example.com/# 从注册表中下载镜像[student@servera ~]$ podman pull utility.lab.example.com/ubi7/ubi# 列出本地存储中的镜像[student@servera ~]$ podman imagesREPOSITORY                                 TAG         IMAGE ID      CREATED      SIZEutility.lab.example.com/ubi7/ubi           latest      87dd8ec61bbc  4 years ago  215 MB# 镜像信息注解:1.REPOSITORY    仓库地址2.TAG           标记，latest最近版本3.IMAGE ID      镜像ID，ID号唯一，保证镜像唯一性4.CREATED       创建时间；5.SIZE          镜像大小<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-4-从容器文件创建容器镜像"><a href="#3-4-从容器文件创建容器镜像" class="headerlink" title="3.4 从容器文件创建容器镜像"></a>3.4 从容器文件创建容器镜像</h2><p>  您获得了以下容器文件，用于在 python36-app目录中创建容器镜像</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ cat Containerfile FROM utility.access.redhat.com/ubi8/ubi:latestRUN dnf install -y python36CMD["/bin/bash"，"-c"，"sleep infinity"]# 此容器文件是教材中例子默认报错，可以使用下面的容器文件[student@servera ~]$ vim ContainerfileFROM utility.lab.example.com/ubi9/ubi:latestRUN echo -e '[rhel-9.3-for-x86_64-baseos-rpms]\nbaseurl = http://content.example.com/rhel9.3/x86_64/dvd/BaseOS\nenabled = true\ngpgcheck = false\nname = Red Hat Enterprise Linux 9.3 BaseOS (dvd)\n[rhel-9.3-for-x86_64-appstream-rpms]\nbaseurl = http://content.example.com/rhel9.3/x86_64/dvd/AppStream\nenabled = true\ngpgcheck = false\nname = Red Hat Enterprise Linux 9.3 Appstream (dvd)'&gt;/etc/yum.repos.d/rhel_dvd.repoRUN yum install --disablerepo=* --enablerepo=rhel-9.3-for-x86_64-baseos-rpms --enablerepo=rhel-9.3-for-x86_64-appstream-rpms -y python3CMD ["/bin/bash", "-c", "sleep infinity"]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  以上容器文件使用utility.lab.example.com/ubi9/ubi:latest镜像作为基础镜像。容器文件而后将安装python36软件包，并运行sleep infinity bash命令来防止容器退出</p><p>  通常，容器运行一个进程，然后在该进程完成后退出。sleep infinity命令可防止容器退出因为该进程永远不会完成，然后可以在容器内进行测试、开发和调试</p><p>  在检查容器文件后，可以使用podman build命令来构建镜像。podman build命令的语法如下所示：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ podman build -t NAME:TAG  DIR[student@servera ~]$ podman build -t rhel7:2.0 .[student@servera ~]$ podman imagesREPOSITORY                                 TAG         IMAGE ID      CREATED         SIZElocalhost/rhel7                            2.0         98d0b6385a00  40 seconds ago  238 MButility.lab.example.com/ubi9/ubi           latest      8d2a8803cfca  12 months ago   219 MButility.lab.example.com/ubi7/ubi           latest      87dd8ec61bbc  4 years ago     215 MButility.lab.example.com/rhel8/mariadb-103  latest      11a47e0fbed0  4 years ago     572 MB# 以上输出的最后一行显示了容器镜像ID。大多数Podman命令使用容器镜像ID的前12个字符来指代容器镜像，可以将此短ID或者容器或容器镜像的名称，作为大多数Podman命令的参数# 注解:-t,--tag name 生成镜像的名称NAME:新镜像的名称标签:新镜像的标签。如果未指定标签，则镜像自动标记为latestDIR:工作目录路径。容器文件必须位于工作目录中。如果工作目录是当前目录，则可以用点(.)来指定它。使用-f标志指定与当前目录不同的目录<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  使用podman inspect命令来查看容器镜像的低级别信息，并验证其内容是否符合容器要求:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[student@servera ~]$ podman inspect localhost/rhel7:2.0<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>  podman inspect命令的输出显示reqistry.access.redhat.com/ubi8/ubi:latest基础镜像、用于安装python36 软件包的dnf命令，以及在运行时执行以防止容器退出的sleep infinity bash命令</p><h1 id="4-运行容器"><a href="#4-运行容器" class="headerlink" title="4 运行容器"></a>4 运行容器</h1><p>  现在已拥有所需的容器镜像，可以使用它们来运行容器。容器可以处于以下状态之一!</p><p>   1.Created：已创建好但尚未启动的容器</p><p>   2.运行中：与其进程一起运行的容器</p><p>   3.已停止：其进程已停止的容器</p><p>   4.Paused：其进程已暂停的容器，不支持 Rootless容器</p><p>   5.Deleted：其进程处于已死状态的容器</p><p>  podman ps命令列出系统上正在运行的容器</p><p>  使用podman ps -a来命令查看计算机中的所有容器 (已创建、已停止、已暂停或正在运行)</p><p>  可使用podman create命令来创建容器，以便稍后运行。若要创建容器，请使用容器localhost/rhel7:2.0镜像的ID。也可以使用–name<br>选项设置名称来标识容器。此命令的输出是容器的长ID，如果不指定–name选项，会自动生成一个容器名称</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ podman create --name python36 dd6ca291f097# 使用podman ps和podman ps -a命令来验证容器是否已创建但尚未启动$ podman ps -a$ podman ps # 运行podman start命令。可以使用名称或容器ID来启动容器。此命令的输出是容器的名称$ podman start python36$ podman ps<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-1-从远程存储库运行容器"><a href="#4-1-从远程存储库运行容器" class="headerlink" title="4.1 从远程存储库运行容器"></a>4.1 从远程存储库运行容器</h2><p>  可使用podman run命令，在一个步骤中创建并运行容器。podman run命令在容器内运行进程，此进程将启动新容器</p><p>  可使用podman run命令的-d选项以分离模式运行容器，这将在后台运行容器，而不是在会话的前台运行</p><p>  在python36容器的示例中，您不需要提供容器运行所提的命令，原因是为该容器创建镜像的容器文件中已提供了sleep infinity 命令</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># podman run -t：终端     -i：交互    -d：放在后台    --name：指定容器的名称，如果不指定，会自动产生名称[student@servera ~]$ podman run -it utility.lab.example.com/ubi7/ubi[student@servera ~]$ podman psCONTAINER ID  IMAGE                                    COMMAND     CREATED             STATUS             PORTS       NAMES537b1f1fbb6d  utility.lab.example.com/ubi7/ubi:latest  /bin/bash   About a minute ago  Up About a minute              objective_antonelli#实验前可以提前下载镜像至本地 #podman search utility.lab.example.com/#podman pull utility.lab.example.com/ubi8/ubi#podman images[student@servera ~]$ podman run -it --name rhel9 utility.lab.example.com/ubi9/ubi[student@servera ~]$ podman run -di --name rhel9-1 utility.lab.example.com/ubi9/ubi[student@servera ~]$ podman psCONTAINER ID  IMAGE                                    COMMAND     CREATED         STATUS         PORTS       NAMES537b1f1fbb6d  utility.lab.example.com/ubi7/ubi:latest  /bin/bash   5 minutes ago   Up 5 minutes               objective_antonellifb45a06e2271  utility.lab.example.com/ubi9/ubi:latest  /bin/bash   56 seconds ago  Up 57 seconds              rhel9-1# ctrl+d退出后再查看容器的状态[student@servera ~]$ podman exec -ti rhel9-1 /bin/bash[student@servera ~]$ podman run -d --name rhel9-2 utility.lab.example.com/ubi9/ubi sleep infinity[student@servera ~]$ podman psCONTAINER ID  IMAGE                                    COMMAND         CREATED         STATUS         PORTS       NAMESfb45a06e2271  utility.lab.example.com/ubi9/ubi:latest  /bin/bash       5 minutes ago   Up 5 minutes               rhel9-1c4f7f4d72747  utility.lab.example.com/ubi9/ubi:latest  sleep infinity  34 seconds ago  Up 34 seconds              rhel9-2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-2-容器中的环境隔离"><a href="#4-2-容器中的环境隔离" class="headerlink" title="4.2 容器中的环境隔离"></a>4.2 容器中的环境隔离</h2><p>  每个容器都有自己的文件系统、网络和进程。查看ps命令的输出，并在主机和运行中容器之间进行比较，就会注意到隔离功能</p><p>  在本地计算机上运行ps -ax命令，该命令将返回具有许多进程的预期结果</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[student@servera ~]$ ps -ax[student@servera ~]$ podman run -di --name python36-db utility.lab.example.com/rhel8/mariadb-103f4c3d26df7bd3614e6b4954ae6ed485046128afc89a95cba20c834b2ba0327ff[student@servera ~]$ podman ps -aCONTAINER ID  IMAGE                                             COMMAND         CREATED         STATUS                     PORTS       NAMES850618efbece  utility.lab.example.com/ubi9/ubi:latest           /bin/bash       9 hours ago     Exited (0) 9 hours ago                 rhel9fb45a06e2271  utility.lab.example.com/ubi9/ubi:latest           /bin/bash       9 hours ago     Up 9 hours                             rhel9-1c4f7f4d72747  utility.lab.example.com/ubi9/ubi:latest           sleep infinity  9 hours ago     Up 9 hours                             rhel9-2f4c3d26df7bd  utility.lab.example.com/rhel8/mariadb-103:latest  run-mysqld      22 minutes ago  Exited (1) 22 minutes ago              python36-db<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-3-容器内执行命令"><a href="#4-3-容器内执行命令" class="headerlink" title="4.3 容器内执行命令"></a>4.3 容器内执行命令</h2><p>  podman exec命令可在运行中的容器内执行命令，该命令取容器的名称或ID作为第一个参数，并将下列参数作为要在容器内运行的命令</p><p>  使用podman exec命令查看rhel7容器中正在运行的进程</p><p>  ps aux命令的输出看起来有所不同，因为它运行与本地计算机不同的进程</p><p>  使用sh -c命令来封装要在容器中执行的命令</p><p>  ps ax &gt; /tmp/process-data.log命令被解释为要在容器中执行的命令。如果不封装命令，则Podman可能会将大于号字符(&gt;)解释为podman命令的一部分，而不是podman exec选项的参数</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[student@servera ~]$ podman exec rhel7 ps -ax    PID TTY      STAT   TIME COMMAND      1 ?        Ss     0:00 /bin/bash      2 ?        R      0:00 ps -ax[student@servera ~]$ podman exec rhel7 sh -c 'ps -a &gt; /tmp/process_data.log'[student@servera ~]$ podman exec rhel7 sh -c 'echo China &gt; /test.txt'[student@servera ~]$ podman exec -ti rhel7 /bin/bash[root@2d4b030f4141 /]# ls /bin  boot  dev  etc  home  lib  lib64  media  mnt  opt  proc  root  run  sbin  srv  sys  test.txt  tmp  usr  var[root@2d4b030f4141 /]# cat test.txtChina[root@2d4b030f4141 /]# cat /tmp/process_data.log    PID TTY          TIME CMD[root@2d4b030f4141 /]# exitexit[student@servera ~]$ # 将主机系统上安装的python版本与容器上安装的python版本进行比较[student@servera ~]$ podman exec rhel9-1 python3 --versionPython 3.9.18[student@servera ~]$ python3 --versionPython 3.9.18[student@servera ~]$ podman exec python38  python3 --versionPython 3.9.18<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-4-容器中的文件系统隔离"><a href="#4-4-容器中的文件系统隔离" class="headerlink" title="4.4 容器中的文件系统隔离"></a>4.4 容器中的文件系统隔离</h2><p>  开发人员可以使用文件系统隔离功能，为不同版本的编程语言编写和测试应用，无需使用多个物理机或虚拟机</p><p>  在终端上的/tmp目录中创建一个显示hello world的简单bash脚本</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[student@servera ~]$ echo "echo Hello China!" &gt; /tmp/hello.sh[student@servera tmp]$ cd /tmp;lltotal 8-rw-r--r--. 1 student student 18 Mar  3 21:24 hello.sh-rw-r--r--. 1 student student 30 Mar  3 21:01 process_data.logdrwx------. 3 root    root    17 Mar  3 08:28 systemd-private-3f251aad6ce74edb86dddf89d56e8aed-chronyd.service-c0Zzhidrwx------. 3 root    root    17 Mar  3 08:28 systemd-private-3f251aad6ce74edb86dddf89d56e8aed-dbus-broker.service-QaiP7Ndrwx------. 3 root    root    17 Mar  3 08:28 systemd-private-3f251aad6ce74edb86dddf89d56e8aed-systemd-logind.service-iM6Zeq<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  /tmp/hello.sh文件位于主机计算机上，而不存在于容器内的文件系统上。如果尝试使用podmanexec来执行脚本，则会出现错误，因为容器中不存在/tmp/hello.sh脚本</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[student@servera tmp]$ stat /tmp/hello.sh  File: /tmp/hello.sh  Size: 18          Blocks: 8          IO Block: 4096   regular fileDevice: fc04h/64516d    Inode: 18159864    Links: 1Access: (0644/-rw-r--r--)  Uid: ( 1000/ student)   Gid: ( 1000/ student)Context: unconfined_u:object_r:user_tmp_t:s0Access: 2025-03-03 21:24:33.865950531 -0500Modify: 2025-03-03 21:24:33.865950531 -0500Change: 2025-03-03 21:24:33.865950531 -0500 Birth: 2025-03-03 21:24:33.865950531 -0500[student@servera tmp]$ podman exec rhel7 stat /tmp/hello.shstat: cannot stat '/tmp/hello.sh': No such file or directory<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  podman cp命令在主机和容器文件系统之间复制文件和文件夹。可以使用podman cp 命令将/tmp/hello.sh文件复制到python38容器:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[student@servera ~]$ podman cp /tmp/hello.sh rhel7:/tmp/hello.sh[student@servera ~]$ podman exec rhel7 stat /tmp/hello.sh  File: '/tmp/hello.sh'  Size: 18          Blocks: 8          IO Block: 4096   regular fileDevice: 58h/88d Inode: 10261231    Links: 1Access: (0644/-rw-r--r--)  Uid: (    0/    root)   Gid: (    0/    root)Access: 2025-03-04 02:24:34.000000000 +0000Modify: 2025-03-04 02:24:34.000000000 +0000Change: 2025-03-04 02:28:24.720471184 +0000 Birth: -<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  脚本复制到容器文件系统后，即可从容器内执行:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[student@servera ~]$ podman exec rhel7 bash /tmp/hello.shHello China!<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="4-5-删除容器和镜像"><a href="#4-5-删除容器和镜像" class="headerlink" title="4.5 删除容器和镜像"></a>4.5 删除容器和镜像</h2><p>  使用podman rm和podman rmi命令删除容器和镜像</p><p>  删除容器镜像之前，必须先从该镜像移除任何现有的运行中容器</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[student@servera ~]$ podman ps -aCONTAINER ID  IMAGE                                             COMMAND         CREATED            STATUS                        PORTS       NAMES850618efbece  utility.lab.example.com/ubi9/ubi:latest           /bin/bash       10 hours ago       Exited (0) 10 hours ago                   rhel9student@servera ~]$ podman rmi utility.lab.example.com/ubi9/ubi:latestError: image used by 8e7870d50daa32c768c4301911364285a659a5383b4cdadc96b8d3b7ff411c2d: image is in use by a container: consider listing external containers and force-removing image<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  必须先停止容器，然后才能删除它。若要停止容器，请使用podman stop命令</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[student@servera ~]$ podman stop python38python38<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>  停止容器后，使用podman rm命令来删除容器</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[student@servera ~]$ podman rm --help[student@servera ~]$ podman rm python38python38<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>  当容器不再存在时，可使用podman rmi命令删除对应的镜像:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[student@servera ~]$ podman imagesREPOSITORY                                 TAG         IMAGE ID      CREATED        SIZElocalhost/rhel7                            2.0         98d0b6385a00  11 hours ago   238 MButility.lab.example.com/ubi9/ubi           latest      8d2a8803cfca  12 months ago  219 MButility.lab.example.com/ubi7/ubi           latest      87dd8ec61bbc  4 years ago    215 MButility.lab.example.com/rhel8/mariadb-103  latest      11a47e0fbed0  4 years ago    572 MB[student@servera ~]$ podman rmi 8d2a8803cfcaError: image used by c4f7f4d727471d590f6241cccf0be0b1ef2256cc43a710594642611fe6d0be47: image is in use by a container: consider listing external containers and force-removing image[student@servera ~]$ podman rmi 98d0b6385a00Untagged: localhost/rhel7:2.0Deleted: 98d0b6385a005e09cfcee59a393cfce2fc46b56f09af6c4f87bd874f00966ed2Deleted: 53c739e51f226903b6568038c9cf563de2007f756e0a0e86e5c00604cf474f3dDeleted: 92b83aa1157f23b209f53480c6bbdf780c39490b37337bc4f4fcb1061b7c978<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="5-容器存储和网络资源"><a href="#5-容器存储和网络资源" class="headerlink" title="5 容器存储和网络资源"></a>5 容器存储和网络资源</h1><h2 id="5-1-管理容器资源"><a href="#5-1-管理容器资源" class="headerlink" title="5.1 管理容器资源"></a>5.1 管理容器资源</h2><p>  可以使用容器来运行简单的进程，然后退出。还可以配置容器以连续运行某一服务，如数据库服务器。如果持续运行服务，最终可能需要向容器添加更多资源，如持久存储或对其他网络的访问权限</p><p>  可以使用不同的策略为容器配置持久存储:</p><p>   1.对于红帽OpenShift等企业容器平台上的大型部署，可以使用复杂的存储解决方案为容器提供存储，而无需了解底层基础架构</p><p>   2.对于单个容器主机上且无需扩展的小型部署，可以通过在运行中的容器上创建要挂载的目录，从容器主机创建持久存储</p><p>  当Web服务器或数据库服务器等容器为容器主机外部的客户端提供内容时，必须为这些客户端设置通信通道，以访问容器的内容</p><p>  可以配置端口映射，以启用与容器的通信。通过端口映射，目的地为容器主机上端口的请求将被转发到容器内的端口</p><h2 id="5-2-容器的环境变量"><a href="#5-2-容器的环境变量" class="headerlink" title="5.2 容器的环境变量"></a>5.2 容器的环境变量</h2><p>  容器镜像允许在创建时传递环境变量以自定义容器</p><p>  可以使用环境变量为容器设置参数，以根据您的环境进行定制，无需创建自己的自定义镜像。通常不会修改容器镜像，因为这会向镜像添加层，或许更加难以维护</p><p>  使用podman run -d –name db01 utility.lab.example.com/rhel8/mariadb-103命令运行容器化数据库，但发现容器无法启动</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[student@servera ~]$ podman search utility.lab.example.com/     [student@servera ~]$ podman pull utility.lab.example.com/rhel8/mariadb-103[student@servera ~]$ podman imagesREPOSITORY                                 TAG         IMAGE ID      CREATED        SIZEutility.lab.example.com/rhel8/mariadb-103  latest      11a47e0fbed0  4 years ago    572 MB[student@servera ~]$ podman run -d --name db01 utility.lab.example.com/rhel8/mariadb-10329decc6e48d62506e62e503a383943709138a8f789a32dd27d2fa1761bf3ea9f# 发现容器无法启动[student@servera ~]$ podman ps -aCONTAINER ID  IMAGE           COMMAND     CREATED        STATUS                    PORTS       NAMES29decc6e48d6  utility.lab.example.com/rhel8/mariadb-103:latest  run-mysqld  2 minutes ago  Exited (1) 2 minutes ago              db01<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  使用podman container logs命令调查容器状态的原因</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[student@servera ~]$ podman container logs db01Warning: Can't detect memory limit from cgroupsWarning: Can't detect number of CPU cores from cgroupsWarning: Can't detect memory limit from cgroupsWarning: Can't detect number of CPU cores from cgroups=&gt; sourcing 20-validate-variables.sh ...You must either specify the following environment variables:  MYSQL_USER (regex: '^[a-zA-Z0-9_]+$')  MYSQL_PASSWORD (regex: '^[a-zA-Z0-9_~!@#$%^&amp;*()-=&lt;&gt;,.?;:|]+$')  MYSQL_DATABASE (regex: '^[a-zA-Z0-9_]+$')Or the following environment variable:  MYSQL_ROOT_PASSWORD (regex: '^[a-zA-Z0-9_~!@#$%^&amp;*()-=&lt;&gt;,.?;:|]+$')Or both.Optional Settings:......<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  容器信息展示</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 输出中的usage 标签提供了如何运行镜像的示例。url标签指向红帽容器目录中的一个Web页面，其中记录了环境变量以及有关如何使用容器镜像的其他信息。# 此镜像的文档显示容器将3306端口用于数据库服务。文档中还显示了以下环境变量可用于配置数据库服务:[student@servera ~]$ podman imagesREPOSITORY                                 TAG         IMAGE ID      CREATED        SIZEutility.lab.example.com/ubi9/ubi           latest      8d2a8803cfca  12 months ago  219 MButility.lab.example.com/ubi7/ubi           latest      87dd8ec61bbc  4 years ago    215 MButility.lab.example.com/rhel8/mariadb-103  latest      11a47e0fbed0  4 years ago    572 MB[student@servera ~]$ podman inspect utility.lab.example.com/rhel8/mariadb-103 | grep usage                    "usage": "podman run -d -e MYSQL_USER=user -e MYSQL_PASSWORD=pass -e MYSQL_DATABASE=db -p 3306:3306 rhel8/mariadb-103",               "usage": "podman run -d -e MYSQL_USER=user -e MYSQL_PASSWORD=pass -e MYSQL_DATABASE=db -p 3306:3306 rhel8/mariadb-103",$ skopeo inspect docker://utility.lab.example.com/rhel8/mariadb-105 | grep -B 1 Usage<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  mariadb镜像的环境变量</p><table><thead><tr><th align="left">变量</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">MYSQL_USER</td><td align="left">要创建的MySQL帐户的用户名</td></tr><tr><td align="left">MYSQL_PASSWORD</td><td align="left">用户帐户的密码</td></tr><tr><td align="left">MYSQL_DATABASE</td><td align="left">数据库名称</td></tr><tr><td align="left">MYSQL_ROOT_PASSWORD</td><td align="left">root用户的密码 (可选)</td></tr></tbody></table><p>  在检查了镜像的可用环境变量后，使用podman run命令-e选项将环境变量传递给容器，并使用podman ps命令来验证它是否正在运行</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[student@servera ~]$ podman rm -af29decc6e48d62506e62e503a383943709138a8f789a32dd27d2fa1761bf3ea9f[student@servera ~]$ podman ps -aCONTAINER ID  IMAGE       COMMAND     CREATED     STATUS      PORTS       NAMES[student@servera ~]$ podman run -d --name db01 -e MYSQL_USER=user -e MYSQL_PASSWORD=pass -e MYSQL_DATABASE=db utility.lab.example.com/rhel8/mariadb-10341a62ff2efd7f268e52d6f6a0a9b503411824c5f4391b86dae5d3f01376cb896# 容器启动成功[student@servera ~]$ podman ps  -aCONTAINER ID  IMAGE                                             COMMAND     CREATED        STATUS        PORTS       NAMES41a62ff2efd7  utility.lab.example.com/rhel8/mariadb-103:latest  run-mysqld  8 seconds ago  Up 8 seconds              db01<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5-3-容器持久存储"><a href="#5-3-容器持久存储" class="headerlink" title="5.3 容器持久存储"></a>5.3 容器持久存储</h2><p>  默认情况下运行容器时，所有内容都使用基于容器的镜像</p><p>  鉴于容器镜像的寿命短，用户或应用写入的所有新数据在移除容器后都会丢失</p><p>  若要持久保留数据，可以将容器中的主机文件系统内容与–volume(-v)选项搭配使用。在容器中使用此卷类型时，必须考虑文件系统级别的权限<br>  MariaDB容器镜像中，mysql用户必须拥有/var/lib/mysql目录，就如同MariaDB在主机上运行时一样</p><p>  打算挂载到容器中的目录必须具有mysql作为用户和组所有者(或mysql用户的UID/GID，如果主机上没有安装MariaDB)</p><p>  如果以root用户身份运行容器，则主机上的UID和GID与容器内的UID和GID匹配</p><p>  可使用podman unshare命令在用户命名空间内运行命令。要获取用户命名空间的UID映射，请使用podman unshare cat命令</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[student@servera ~]$ podman unshare cat /proc/self/uid_map         0       1000          1         1     100000      65536[student@servera ~]$ podman unshare cat /proc/self/gid_map         0       1000          1         1     100000      65536<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  以上输出显示：</p><p>   1.容器中的root用户 (UID和GID为0)映射到主机计算机上的用户(UID和GID为1000)</p><p>   2.容器中的UID和GID1映射到主机计算机上的UID和GID 100000</p><p>   3.1后的每个UID和GID以1增量递增。例如，容器内的UID和GID30映射到主机计算机上的UID和GID100029</p><p>   4.可使用podman exec命令查看使用临时存储运行的容器内的mysql用户UID和GID:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[student@servera ~]$ podman exec -it db01 grep mysql /etc/passwdmysql:x:27:27:MySQL Server:/var/lib/mysql:/sbin/nologin<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>  将/home/user/db_data目录挂载到db01容器中，以在容器的/var/lib/mysql目录中提供持久存储</p><p>  创建/home/user/db_data目录，并使用podmanunshare命令将27的用户命名空间UID和GID设置为该目录的所有者</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[student@servera ~]$ mkdir /home/student/db_data[student@servera ~]$ ll -d /home/student/db_datadrwxr-xr-x. 2 student student 6 Mar  4 00:43 /home/student/db_data[student@servera ~]$ ll -d -n /home/student/db_datadrwxr-xr-x. 2 1000 1000 6 Mar  4 00:43 /home/student/db_data[student@servera ~]$ podman unshare chown 27:27 /home/student/db_data/[student@servera ~]$ ll -d /home/student/db_datadrwxr-xr-x. 2 100026 100026 6 Mar  4 00:43 /home/student/db_data<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  容器中的UID和GID 27映射到主机计算机上的UID和GID100026</p><p>  可使用ll -d命令查看/home/student/db_data目录的所有权来验证映射</p><p>  现在已设置了正确的文件系统级权限，可使用podman run 命令-v选项来挂载目录:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[student@servera ~]$ podman rm -af41a62ff2efd7f268e52d6f6a0a9b503411824c5f4391b86dae5d3f01376cb896[student@servera ~]$ podman run -d --name db01 -e MYSQL_USER=user -e MYSQL_PASSWORD=pass -e MYSQL_DATABASE=db -v /home/student/db_data/:/var/lib/mysql  utility.lab.example.com/rhel8/mariadb-10354279d1fff7f3b679dd9d4efb7bfa28a626f41f7d07bea50a445ec2392c8cb02# db01容器未在运行[student@servera ~]$ podman ps -aCONTAINER ID  IMAGE                                             COMMAND     CREATED        STATUS                    PORTS       NAMES54279d1fff7f  utility.lab.example.com/rhel8/mariadb-103:latest  run-mysqld  6 minutes ago  Exited (1) 6 minutes ago              db01$ podman run -d --name db01 \-e MYSQL_USER=user \-e MYSQL_PASSWORD=pass \-e MYSQL_DATABASE=db \-e MYSQL_ROOT_PASSWORD=redhat \-v /home/student/db_data/:/var/lib/mysql \utility.lab.example.com/rhel8/mariadb-103<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  podman container logs命令显示/var/lib/mysql/data目录的权限错误：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[student@servera ~]$ podman container logs db01Warning: Can't detect memory limit from cgroupsWarning: Can't detect number of CPU cores from cgroupsWarning: Can't detect memory limit from cgroupsWarning: Can't detect number of CPU cores from cgroups=&gt; sourcing 20-validate-variables.sh ...=&gt; sourcing 25-validate-replication-variables.sh ...=&gt; sourcing 30-base-config.sh ...---&gt; 05:58:29     Processing basic MySQL configuration files ...=&gt; sourcing 60-replication-config.sh ...=&gt; sourcing 70-s2i-config.sh ...---&gt; 05:58:29     Processing additional arbitrary  MySQL configuration provided by s2i ...=&gt; sourcing 40-paas.cnf ...=&gt; sourcing 50-my-tuning.cnf ...---&gt; 05:58:29     Initializing database ...---&gt; 05:58:29     Running mysql_install_db ...mkdir: cannot create directory '/var/lib/mysql/data': Permission deniedFatal error Can't create database directory '/var/lib/mysql/data'# 发生此错误的原因是，主机上/home/user/db\_data目录中设置的SELinux上下文不正确<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5-4-容器存储的SELinux上下文"><a href="#5-4-容器存储的SELinux上下文" class="headerlink" title="5.4 容器存储的SELinux上下文"></a>5.4 容器存储的SELinux上下文</h2><p>  必须先设置container_file_t SELinux上下文类型，然后才能将该目录作为持久存储挂载到容器。如果目录没有container_file_t SELinux 上下文，则容器无法访问该目录</p><p>  可以将Z选项附加到podman run命令-v选项的参数，以自动设置目录的SELinux上下文</p><p>  /home/student/db_data挂载为/var/lib/mysql目录的持久存储时，可使用podman run -v /home/student/db_data:/var/lib/mysql:Z命令设置该目录的SELinux上下文</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[student@servera ~]$ podman run -d --name db01 -e MYSQL_USER=user -e MYSQL_PASSWORD=pass -e MYSQL_DATABASE=db -v /home/student/db_data/:/var/lib/mysql:Z utility.lab.example.com/rhel8/mariadb-1036195fc399b1f6ae8f5b9d3f436c02bb5d6b093b597949dc968b2a64f6e7d023c[student@servera ~]$ ll -dZ /home/student/db_data/drwxr-xr-x. 3 100026 100026 system_u:object_r:container_file_t:s0:c428,c988 36 Mar  4 01:26 /home/student/db_data/$ podman run -d --name db01 \-e MYSQL_USER=user \-e MYSQL_PASSWORD=pass \-e MYSQL_DATABASE=db \-e MYSQL_ROOT_PASSWORD=redhat \-v /home/student/db_data:/var/lib/mysql:Z utility.lab.example.com/rhel8/mariadb-103<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5-5-分配端口映射到容器"><a href="#5-5-分配端口映射到容器" class="headerlink" title="5.5 分配端口映射到容器"></a>5.5 分配端口映射到容器</h2><p>  要提供对容器的网络访问权限，客户端必须连接到容器主机上的端口，这些端口将网络流量传递到容器中的端口</p><p>  将容器主机上的网络端口映射到容器中的端口时，容器将接收发送到主机网络端口的网络流量</p><p>  例如，可以将容器主机上的13306端口映射到容器上的3306端口，以便与MariaDB容器通信。因此，发送到容器主机端口13306的流量将由容器中运行的MariaDB接收</p><p>  可以使用 podman run命令的-p选项设置从容器主机上13306端口到db01容器上3306端口的端口映射</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[student@servera ~]$ podman run -d --name db01 -e MYSQL_USER=user -e MYSQL_PASSWORD=pass -e MYSQL_DATABASE=db -v /home/student/db_data/:/var/lib/mysql:Z -p 13306:3306 utility.lab.example.com/rhel8/mariadb-10328202973f22d60ea4ccd096b8a321b30c7d57156a2c41d2502c1a0456c794ced[student@servera ~]$ podman ps -aCONTAINER ID  IMAGE                                             COMMAND     CREATED         STATUS         PORTS                    NAMES28202973f22d  utility.lab.example.com/rhel8/mariadb-103:latest  run-mysqld  20 seconds ago  Up 20 seconds  0.0.0.0:13306-&gt;3306/tcp  db01$ podman run -d --name db01 \-e MYSQL_USER=user \-e MYSQL_PASSWORD=pass \-e MYSQL_DATABASE=db \-e MYSQL_ROOT_PASSWORD=redhat \-p 13306:3306 \-v /home/student/db_data:/var/lib/mysql:Z \utility.lab.example.com/rhel8/mariadb-103<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  使用podman port命令的-a选项可显示正在使用的所有容器端口映射。还可以使用podman port db01命令显示 db01容器的映射端口</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[student@servera ~]$ podman port -a28202973f22d    3306/tcp -&gt; 0.0.0.0:13306[student@servera ~]$ podman port db013306/tcp -&gt; 0.0.0.0:13306<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>  可使用firewall-cmd命令允许端口13306流量传入容器主机，以便它可以重定向到容器:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># Rootless(特权)容器无法打开主机上特权端口1024有 以下的端口。比如-p 80:8000 ，比必须使用root才可以对其进行调整[student@servera ~]$ sudo firewall-cmd --permanent --add-port=13306/tcp[sudo] password for student: success[student@servera ~]$ sudo firewall-cmd --reloadsuccess[student@servera ~]$ sudo firewall-cmd --list-allpublic (active)  target: default  icmp-block-inversion: no  interfaces: eth0  sources:   services: cockpit dhcpv6-client ssh  ports: 13306/tcp  protocols:   forward: yes  masquerade: no  forward-ports:   source-ports:   icmp-blocks:   rich rules: # firewall-cmd --add-port=13306/tcp --permanent# firewall-cmd --reload<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5-6-容器的网络后端"><a href="#5-6-容器的网络后端" class="headerlink" title="5.6 容器的网络后端"></a>5.6 容器的网络后端</h2><p>  Podmanv4.0支持两种容器网络后端，即Netavark和CNI</p><p>  自RHEL9起，系统默认使用Netavark。若要验证所用的网络后端，请运行以下podman info命令</p><p>  <a href="https://docs.redhat.com/zh_hans/documentation/red_hat_enterprise_linux/9/html/building_running_and_managing_containers/proc_switching-the-network-stack-from-cni-to-netavark_assembly_setting-container-network-modes">将网络堆栈从 CNI 切换到 Netavark | Red Hat Product Documentation</a></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ podman info --format {{.Host.NetworkBackend}}netavark<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>  主机上使用默认Podman网络的现有容器无法解析彼此的主机名，因为默认网络上未启用DNS</p><p>  使用podman network create命令创建一个支持DNS的网络：</p><p>   使用podman network create命令创建名为db_net的网络，并将子网指定为10.87.0.0/16，网关指定为10.87.0.1</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ podman network create --gateway 10.87.0.1 --subnet 10.87.0.0/16 db_net$ podman network ls # 列出容器网络<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>  如果不指定–gateway 或–subnet 选项，则会使用默认值创建它们</p><p>  podman network inspect 命令显示关于特定网络的信息：</p><p>   可使用podman network inspect 命令验证网关和子网的设置是否正确，以及新的dbnet网络是否启用了DNS</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ podman network inspect db_net<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>  podman run命令–network选项将启用DNS的db_net网络添加到新容器：</p><p>   可使用podman run命令–network选项创建连接到db_net网络的db01和client01容器</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ podman run -d --name db01 \--network db_net \-e MYSQL_USER=user \-e MYSQL_PASSWORD=pass \-e MYSQL_DATABASE=db \-e MYSQL_ROOT_PASSWORD=redhat \-v /home/student/db_data:/var/lib/mysql:Z \-p 13306:3306 \utility.lab.example.com/rhel8/mariadb-105$ podman run -d --name client01 \--network db_net \-v /etc/yum.repos.d:/etc/yum.repos.d/ \utility.lab.example.com/ubi9-beta/ubi \sleep infinity$ podman ps -a<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  由于容器设计为仅具有所需的最少软件包，因此容器可能不具有测试通信所需的实用程序，如ping和ip命令。可以使用podman exec 命令在容器中安装这些实用程序</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ podman exec client01 dnf install -y iputils iproute..output omitted..<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>  容器现在可以通过容器名称互相ping</p><p>  可以使用podman exec命令来测试DNS解析，名称解析到为db_net网络手动设置的子网内的IP</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ podman exec client01 ping -c4 db01PING db01.dns.podman (10.87.0.2) 56(84) bytes of data.64 bytes from 10.87.0.2 (10.87.0.2): icmp_seq=1 ttl=64 time=1.08 ms64 bytes from 10.87.0.2 (10.87.0.2): icmp_seq=2 ttl=64 time=0.082 ms64 bytes from 10.87.0.2 (10.87.0.2): icmp_seq=3 ttl=64 time=0.063 ms64 bytes from 10.87.0.2 (10.87.0.2): icmp_seq=4 ttl=64 time=0.070 ms<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  可以使用 podman exec命令验证每个容器中的IP地址是否与DNS解析匹配</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ podman exec client01 ip a | grep 10.8    inet 10.87.0.3/16 brd 10.87.255.255 scope global eth0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="5-7-多个网络连接到单个容器"><a href="#5-7-多个网络连接到单个容器" class="headerlink" title="5.7 多个网络连接到单个容器"></a>5.7 多个网络连接到单个容器</h2><p>  多个网络可以同时连接到一个容器，以帮助分隔不同类型的流量</p><p>  可以使用podman network create命令创建backend网络</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ podman network create backend<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>  使用podman network ls 命令查看所有Podman网络</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ podman network lsNETWORK ID    NAME    DRIVER  a7fea510a6d1  backend bridgefe680efc5276  db01    bridge2f259bab93aa  podman  bridge<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  没有通过podman network create命令的–gateway和–subnet选项指定子网和网关，使用podman network inspect命令获取backend<br>网络的IP信息</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ podman network inspect backend<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>  在容器运行时，可以使用podman network connect命令将其他网络连接到容器</p><p>  可以使用podman network connect命令，将backend网络连接到db01和client01容器</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ podman network connect backend db01$ podman network connect backend client01<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>  可以使用podman inspect命令验证两个网络是否都已连接到各个容器并显示IP信息</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ podman inspect db01$ podman inspect db01 | grep -A 34 Networks &gt; db01$ cat db01  #查看db01的两个网络IP为10.89.0.2 ， 10.87.0.2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>  client01容器现在可以与两个网络上的db01容器通信，可以使用podman exec命令从cliento1容器pingdb01容器上的两个网络</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ podman exec -ti client01 ping -c4 10.89.0.2PING 10.89.0.2 (10.89.0.2) 56(84) bytes of data.64 bytes from 10.89.0.2: icmp_seq=1 ttl=64 time=0.352 ms$ podman exec -ti client01 ping -c4 10.87.0.2PING 10.87.0.2 (10.87.0.2) 56(84) bytes of data.64 bytes from 10.87.0.2: icmp_seq=1 ttl=64 time=0.594 ms<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  容器内安装mariadb客户端访问容器数据库</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ podman exec client01 dnf -y install mariadbpodman$ podman exec -ti client01 mysql -u user -ppass -h db01<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h1 id="6-系统服务管理容器"><a href="#6-系统服务管理容器" class="headerlink" title="6 系统服务管理容器"></a>6 系统服务管理容器</h1><h2 id="6-1-systemd管理小型容器"><a href="#6-1-systemd管理小型容器" class="headerlink" title="6.1 systemd管理小型容器"></a>6.1 systemd管理小型容器</h2><p>  可以运行容器来完成系统任务、获取一系列命令的输出，可能还希望运行无限期运行服务的容器，如Web服务器或数据库</p><p>  在传统环境中，特权用户通常将这些服务配置为在系统启动时运行，并使用systemctl命令进行管理</p><p>  普通用户可以创建systemd单元来配置您的Rootless容器。利用此配置，可以通过systemctl命令将容器作为常规系统服务进行管理</p><p>  基于systemd单元管理容器主要用于不需要扩展的基本和小型部署</p><p>  对于许多基于容器的应用和服务的更复杂扩展和编排，可以使用基于Kubernetes的企业编排平台，如红帽OpenShift容器平台</p><h2 id="6-2-systemd用户服务要求"><a href="#6-2-systemd用户服务要求" class="headerlink" title="6.2 systemd用户服务要求"></a>6.2 systemd用户服务要求</h2><p>  普通用户可以使用systemctl命令来启用服务，该服务在打开会话(图形界面、文本控制台或SSH)时启动，并在关闭最后一个会话时停止。</p><p>此行为与系统服务有所不同，系统服务是在系统启动时启动并在系统关机时停止</p><p>  默认情况下，当使用useradd命令创建用户帐户时，系统将使用普通用户ID范围中的下一个可用ID</p><p>  系统在/etc/subuid文件中为用户的容器保留一系列ID</p><p>  如果使用useradd命令–system选项创建用户帐户，系统不会为用户容器保留范围。因此，无法使用系统帐户启动Rootless容器</p><p>  创建一个专门的用户帐户来管理容器，使用useradd命令创建appdev-adm用户，并将redhat用作密码</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[student@servera ~]$ sudo useradd appdev-adm[sudo] password for student:student[student@servera ~]$ sudo passwd appdev-admChanging password for user appdev-adm.New password:BAD PASSWORD: The password is shorter than 8 charactersRetype new password:passwd: all authentication tokens updated successfully.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  使用su命令切换到appdev-adm用户，并使用podman命令来启动</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[student@servera ~]$ su appdev-admPassword:redhat[appdev-adm@servera student]$ podman infoERRO[0000] XDG_RUNTIME_DIR directory "/run/user/1000" is not owned by the current user[root@servera ~]# su appdev-adm[appdev-adm@servera root]$ podman infoERRO[0000] XDG_RUNTIME_DIR directory "/run/user/0" is not owned by the current user<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  Podman是一款无状态实用程序，需要完整的登录会话</p><p>  Podman必须在SSH会话中使用，不能在sudo或su shell中使用。因此，将退出su shell，并通过SSH登录计算机</p><p>  无状态应用：</p><p>   Stateless Application指不会在会话中保存下次会话中去要的客户端数据，每个会话都像首次执行一样,不会依赖之前的数据进行响应</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[appdev-adm@servera root]$ exitexit[root@servera ~]# ssh appdev-adm@localhostappdev-adm@localhost's password:Register this system with Red Hat Insights: insights-client --registerCreate an account or view all your systems at https://red.ht/insights-dashboardLast login: Tue Mar  4 09:06:27 2025[appdev-adm@servera ~]$ podman info[appdev-adm@servera ~]$ podman login -u admin -p redhat321 utility.lab.example.comLogin Succeeded![appdev-adm@servera ~]$ podman search utility.lab.example.com/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  配置容器注册表并使用您的凭据进行身份验证，可以使用以下命令运行http容器</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[appdev-adm@servera ~]$ mkdir /home/appdev-adm/nginx_web/[appdev-adm@servera ~]$ echo nginx_web_page &gt; /home/appdev-adm/nginx_web/index.html[appdev-adm@servera ~]$ cat /home/appdev-adm/nginx_web/index.htmlnginx_web_page[appdev-adm@servera ~]$ podman run -d --name nginx -v /home/appdev-adm/nginx_web/:/usr/share/nginx/html/:Z -p 8080:80 utility.lab.example.com/library/nginx[appdev-adm@servera ~]$ podman ps -aCONTAINER ID  IMAGE                                         COMMAND               CREATED        STATUS        PORTS                 NAMES6f72fe3fc6d7  utility.lab.example.com/library/nginx:latest  nginx -g daemon o...  2 minutes ago  Up 2 minutes  0.0.0.0:8080-&gt;80/tcp  nginx[appdev-adm@servera ~]$ curl localhost:8080nginx_web_page<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="6-2-1-创建systemd用户文件"><a href="#6-2-1-创建systemd用户文件" class="headerlink" title="6.2.1 创建systemd用户文件"></a>6.2.1 创建systemd用户文件</h3><p>  在~/.confiq/svstemd/user/目录中手动定义systemd服务</p><p>  用户服务的文件语法与系统服务文件的相同，详细信息可查看systemd.unit(5)和systemd.service(5)man手册</p><p>  podman generate systemd命令为现有容器生成systemd服务文件，podman generate systemd命令使用容器作为模型创建配置文件</p><p>  podman generate systemd命令的–new选项指示podman实用程序对systemd服务进行配置，以便在该服务启动时创建容器并在该服务停止时删除容器</p><p>  使用podman generate systemd命令和–name选项来显示为nginx容器建模的systemd服务文件</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[appdev-adm@servera ~]$ man systemd.unit | grep config.*user       ~/.config/systemd/user.control/*       ~/.config/systemd/user/*       │~/.config/systemd/user.control                    │ using the dbus API ($XDG_CONFIG_HOME is used if   │       │$HOME/.config/systemd/user                        │ set, ~/.config otherwise)                         │[appdev-adm@servera ~]$ man systemd.unit[appdev-adm@servera ~]$ mkdir -p ~/.config/systemd/user/[appdev-adm@servera ~]$ cd ~/.config/systemd/user/[appdev-adm@servera ~]$ podman stop nginx        # 生成单元文件之前先停止容器nginx[appdev-adm@servera user]$ podman generate systemd -n nginx -f/home/appdev-adm/.config/systemd/user/container-nginx.service[appdev-adm@servera user]$ lscontainer-nginx.service[appdev-adm@servera user]$ systemctl --user enable --now container-nginx.serviceCreated symlink /home/appdev-adm/.config/systemd/user/default.target.wants/container-nginx.service → /home/appdev-adm/.config/systemd/user/container-nginx.service.[appdev-adm@servera ~]$ podman ps -aCONTAINER ID  IMAGE                                         COMMAND               CREATED         STATUS             PORTS                 NAMES6f72fe3fc6d7  utility.lab.example.com/library/nginx:latest  nginx -g daemon o...  26 minutes ago  Up About a minute  0.0.0.0:8080-&gt;80/tcp  nginx[appdev-adm@servera user]$ systemctl --user stop container-nginx.service[appdev-adm@servera ~]$ podman ps -aCONTAINER ID  IMAGE                                         COMMAND               CREATED         STATUS                     PORTS                 NAMES6f72fe3fc6d7  utility.lab.example.com/library/nginx:latest  nginx -g daemon o...  27 minutes ago  Exited (0) 16 seconds ago  0.0.0.0:8080-&gt;80/tcp  nginx[appdev-adm@servera user]$ systemctl --user restart container-nginx.service$ podman generate systemd -n nginxExecStart=/usr/bin/podman start nginxExecStop=/usr/bin/podman stop -t 10 nginx*$ podman generate systemd -n nginx -f$ lscontainer-nginx.service<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  启动时，systemd守护进程执行podman start命令来启动现有容器</p><p>  停止时，systemd守护进程执行podman stop命令来停止容器，systemd守护进程不会删除该容器</p><p>  使用上一命令并加上–new选项来比较systemd配置</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ podman generate systemd -n nginx --newExecStartPre=/bin/rm -f %t/%n.ctr-idExecStart=/usr/bin/podman run --cidfile=%t/%n.ctr-id --cgroups=no-conmon --rm --sdnotify=conmon --replace -d --name nginx -p 8080:80 -v /home/appdev-adm/nginx_web/:/usr/share/nginx/html/:Z utility.lab.example.com/library/nginxExecStop=/usr/bin/podman stop --ignore --cidfile=%t/%n.ctr-idExecStopPost=/usr/bin/podman rm -f --ignore --cidfile=%t/%n.ctr-id#通过--new选项创建用户单元文件的方法，仅供参考$ cd ~/.config/systemd/user/$ podman generate systemd -n nginx --new -f/home/appdev-adm/.config/systemd/user/container-nginx.service<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  启动时，systemd守护进程执行podman run命令创建并启动新容器。此操作使用podman run命令的–rm选项，将在停止时删除容器</p><p>  停止时，systemd 执行podman stop命令以停止容器</p><p>  在systemd停止容器后，systemd将使用podman rm -f命令将其移除</p><p>  验证podman generate systemd命令的输出，并使用–files选项运行上一命令，以在当前目录中创建systemd用户文件。由于nginx容器使用持久存储，因此选择使用带有–new选项的podman generate systemd命令。然后创建~/config/systemd/user/目录并将文件移到此位置上</p><h3 id="6-2-2-管理systemd用户文件"><a href="#6-2-2-管理systemd用户文件" class="headerlink" title="6.2.2 管理systemd用户文件"></a>6.2.2 管理systemd用户文件</h3><p>  现在已创建了systemd用户文件，可以使用systemctl命令的–user选项来管理nginx容器</p><p>  首先，重新加载systemd守护进程，使systemctl命令知道新的用户文件：</p><p>   使用systemctl–user start命令启动nginx容器</p><p>   使用为容器生成的systemd用户文件的名称</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ systemctl --user enable --now container-nginx.service#其他的管理方法，仅供参考$ systemctl --user status container-nginx.service$ systemctl --user stop container-nginx.service#建议重启验证容器是否可以 开机自启动<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  systemd 系统和用户服务之间使用的不同目录和命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">1.存储自定义单元文件     系统服务   /etc/systemd/system/unit.service                       用户服务   \~/.config/systemd/user/unit.service                         2.重新加载单元文件       系统服务   \# systemctl daemon-reload                       用户服务   \$ systemctl --user daemon-reload                       3.启动和停止服务         系统服务   \# systemctl start UNIT                                     \# systemctl stop UNIT                       用户服务   \$ systemctl --user start UNIT                                    \$ systemctl --user stop UNIT                     4.在计算机启动时启动服务  系统服务   \# systemctl enable UNIT                       用户服务   \$ loginctl enable-linger                                   \$ systemctl --user enable UNIT                    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="6-2-3-配置为系统引导时启动"><a href="#6-2-3-配置为系统引导时启动" class="headerlink" title="6.2.3 配置为系统引导时启动"></a>6.2.3 配置为系统引导时启动</h3><p>  此时systemd服务配置已就绪，可以为给定的用户运行容器。但是，如果用户从系统注销，systemd服务会在特定时间后停止容器。出现此行为的原因是，systemd服务单元是使用.user选项创建的，它在用户登录时启动服务，并在用户注销时停止服务</p><p>  可以通过运行loginctl enable-linger命令来更改此默认行为，并强制已启用的服务在服务器启动时启动，并在服务器关闭期间停止。使用loginctl命令将systemd用户服务配置为在所配置服务的最后一个用户会话关闭后保留</p><p>  使用 loginctl show-user 命令验证配置是否成功。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[appdev-adm@servera ~]$ loginctl show-user appdev-admLinger=no[appdev-adm@servera ~]$ loginctl enable-linger[appdev-adm@servera ~]$ loginctl show-user appdev-admLinger=yes# 重启后进行测试[kiosk@foundation0 ~]$ ssh root@servera[root@servera ~]# ssh appdev-adm@localhost[appdev-adm@servera ~]$ podman ps -aCONTAINER ID  IMAGE                                         COMMAND               CREATED         STATUS             PORTS                 NAMES6f72fe3fc6d7  utility.lab.example.com/library/nginx:latest  nginx -g daemon o...  40 minutes ago  Up About a minute  0.0.0.0:8080-&gt;80/tcp  nginx<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="6-2-4-Root使用Systemd管理容器"><a href="#6-2-4-Root使用Systemd管理容器" class="headerlink" title="6.2.4 Root使用Systemd管理容器"></a>6.2.4 Root使用Systemd管理容器</h3><p>  将容器配置为以root身份运行，并使用systemd服务文件进行管理的优势是可以将这些服务文件配置为像常见systemd单元文件那样工作，而不是以特定用户身份来运行</p><p>  将服务文件设置为root的过程与前面概述的Rootless容器过程类似，但以下例外:</p><p>   1.不要创建专门的用户来管理容器</p><p>   2.服务文件必须在/etc/systemd/system目录中，而不是在~/config/systemd/user目录中</p><p>   3.使用systemctl命令管理容器，但不使用–user选项，不要以root用户身份运行loginctl enable-linger命令</p>]]></content>
      
      
      <categories>
          
          <category> 容器技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> podman容器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>容器&amp;K8S</title>
      <link href="/2025/05/28/kubernetes/rong-qi-k8s/"/>
      <url>/2025/05/28/kubernetes/rong-qi-k8s/</url>
      
        <content type="html"><![CDATA[<h1 id="1-微服务"><a href="#1-微服务" class="headerlink" title="1 微服务"></a>1 微服务</h1><p>  把一个庞大的应用拆成几个小的独立的服务，再把独立的服务串起来的一种架构设计:内聚更强，更加敏捷</p><p><img src="/images/%E5%BE%AE%E6%9C%8D%E5%8A%A1.png"></p><h2 id="1-1-应用架构的发展"><a href="#1-1-应用架构的发展" class="headerlink" title="1.1 应用架构的发展"></a>1.1 应用架构的发展</h2><p><img src="/images/%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%84%E7%9A%84%E5%8F%91%E5%B1%95.png"></p><h2 id="1-2-传统单体架构vs微服务软件架构"><a href="#1-2-传统单体架构vs微服务软件架构" class="headerlink" title="1.2 传统单体架构vs微服务软件架构"></a>1.2 传统单体架构vs微服务软件架构</h2><p>  不同于微服务，传统的项目会包含很多功能，是一个大而全的“超级”工程</p><p>  例如：以普通架构方式实现的电商平台包含：登录、权限、会员、商品库存、订单、收藏、关注、购物车等功能的多个单一项目。随着项目业务越来越复杂、开发人员越来越多，相应开发、编译、部署、技术扩展、水平扩展都会受到限制</p><p><img src="/images/%E4%BC%A0%E7%BB%9F%E5%8D%95%E4%BD%93%E6%9E%B6%E6%9E%84vs%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84.png"></p><h2 id="1-3-基于微服务的系统架构"><a href="#1-3-基于微服务的系统架构" class="headerlink" title="1.3 基于微服务的系统架构"></a>1.3 基于微服务的系统架构</h2><p><img src="/images/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84.png"></p><p>  核心思路是拆分</p><p>  单体项目的问题，通过把项目拆分成一个个小项目就可以解决</p><h2 id="1-4-微服务的特征"><a href="#1-4-微服务的特征" class="headerlink" title="1.4 微服务的特征"></a>1.4 微服务的特征</h2><p><img src="/images/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9A%84%E7%89%B9%E5%BE%81.png"></p><h2 id="1-5-单体架构"><a href="#1-5-单体架构" class="headerlink" title="1.5 单体架构"></a>1.5 单体架构</h2><p>  紧耦合面临的问题：故障影响范围大、变更成本高、无法支持大规模计算</p><p><img src="/images/%E5%8D%95%E4%BD%93%E6%9E%B6%E6%9E%84.png"></p><p>  如果需要加入模块C，需要更改模块A、B的代码，需要各个系统人员协调处理</p><h2 id="1-6-解耦架构"><a href="#1-6-解耦架构" class="headerlink" title="1.6 解耦架构"></a>1.6 解耦架构</h2><p><img src="/images/%E8%A7%A3%E8%80%A6%E6%9E%B6%E6%9E%84.png"></p><p>  解耦架构的优势：</p><p>  1.模块化，缩小故障范围</p><p>  2.降低变更成本，插入新模块不影响其他模块</p><p>  3.开发人员协作更简单</p><p>  4.易于扩展</p><h2 id="1-7-消息队列"><a href="#1-7-消息队列" class="headerlink" title="1.7 消息队列"></a>1.7 消息队列</h2><h3 id="1-7-1-传统架构"><a href="#1-7-1-传统架构" class="headerlink" title="1.7.1 传统架构"></a>1.7.1 传统架构</h3><p><img src="/images/%E4%BC%A0%E7%BB%9F%E6%9E%B6%E6%9E%84.png"></p><h3 id="1-7-2-消息队列架构"><a href="#1-7-2-消息队列架构" class="headerlink" title="1.7.2 消息队列架构"></a>1.7.2 消息队列架构</h3><p><img src="/images/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E6%9E%B6%E6%9E%84.png"></p><h2 id="1-8-微服务面临的挑战"><a href="#1-8-微服务面临的挑战" class="headerlink" title="1.8 微服务面临的挑战"></a>1.8 微服务面临的挑战</h2><table><thead><tr><th></th><th>单体架构</th><th>微服务架构</th></tr></thead><tbody><tr><td>迭代速度</td><td>较慢</td><td>快</td></tr><tr><td>部署频率</td><td>不经常部署</td><td>经常发布</td></tr><tr><td>系统性能</td><td>吞吐量小</td><td>吞吐量大</td></tr><tr><td>系统扩展性</td><td>扩展性差</td><td>扩展性好</td></tr><tr><td>技术栈多样性</td><td>单一、封闭</td><td>多样、开放</td></tr><tr><td>运维</td><td>简单</td><td>运维复杂</td></tr><tr><td>部署难度</td><td>容易部署</td><td>较难部署</td></tr><tr><td>架构复杂度</td><td>较小</td><td>复杂度高</td></tr><tr><td>查错</td><td>简单</td><td>定位问题较难</td></tr><tr><td>管理成本</td><td>主要在于开发成本</td><td>服务治理、运维</td></tr></tbody></table><h2 id="1-9-虚拟机与容器的比较"><a href="#1-9-虚拟机与容器的比较" class="headerlink" title="1.9 虚拟机与容器的比较"></a>1.9 虚拟机与容器的比较</h2><p><img src="/images/%E8%99%9A%E6%8B%9F%E6%9C%BAvs%E5%AE%B9%E5%99%A8.png"></p><table><thead><tr><th>对比模块</th><th>虚拟机</th><th>容器</th></tr></thead><tbody><tr><td>占用空间</td><td>非常大，GB级别</td><td>小，MB/KB级别</td></tr><tr><td>启用速度</td><td>慢，分钟级</td><td>快，秒级</td></tr><tr><td>运行形态</td><td>运行于Hypervisor</td><td>直接运行在宿主机内核上</td></tr><tr><td>并发性</td><td>一台宿主机上十几个，最多几 十个</td><td>上百个，甚至数百个</td></tr><tr><td>性能</td><td>低于宿主机</td><td>接近于宿主机本地进程</td></tr><tr><td>资源利用率</td><td>低</td><td>高</td></tr></tbody></table><h1 id="2-容器的基本使用"><a href="#2-容器的基本使用" class="headerlink" title="2 容器的基本使用"></a>2 容器的基本使用</h1><h2 id="2-1-容器介绍"><a href="#2-1-容器介绍" class="headerlink" title="2.1 容器介绍"></a>2.1 容器介绍</h2><p>  容器是一个可以在共享的操作系统上将应用程序以指定格式打包并运行在一个与操作系统相关联的环境中的方法</p><p>  和虚拟机相比，容器并不会打包整个操作系统，而只是打包应用程序所必须的库和设置，这将使得容器具备高效率、轻量化、系统隔离性，以上特性将会确保无论在何处部署，容器每次运行都会完全一致</p><p>  容器工具：Rkt、Containerd、Docker、Podman</p><h2 id="2-2-部署Docker"><a href="#2-2-部署Docker" class="headerlink" title="2.2 部署Docker"></a>2.2 部署Docker</h2><p>  从南京大学开源镜像站在Ubuntu上安装docker</p><p><img src="/images/docker%E5%AE%89%E8%A3%85.png"></p><h3 id="2-2-1-安装依赖"><a href="#2-2-1-安装依赖" class="headerlink" title="2.2.1 安装依赖"></a>2.2.1 安装依赖</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 检测系统是否安装了dockerroot@k8s-master:~# for pkg in docker.io docker-doc docker-compose podman-docker containerd runc; do sudo apt-get remove $pkg; done# 安装依赖root@k8s-master:~# sudo apt-get updateroot@k8s-master:~# sudo apt-get install ca-certificates curl gnupg<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-2-2-安装GPG公钥"><a href="#2-2-2-安装GPG公钥" class="headerlink" title="2.2.2 安装GPG公钥"></a>2.2.2 安装GPG公钥</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@k8s-master:~# sudo install -m 0755 -d /etc/apt/keyringsroot@k8s-master:~# curl -fsSL https://mirror.nju.edu.cn/docker-ce/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpgroot@k8s-master:~# sudo chmod a+r /etc/apt/keyrings/docker.gpg<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-2-3-添加Docker仓库"><a href="#2-2-3-添加Docker仓库" class="headerlink" title="2.2.3 添加Docker仓库"></a>2.2.3 添加Docker仓库</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@k8s-master:~# echo \  "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://mirror.nju.edu.cn/docker-ce/linux/ubuntu \  "$(. /etc/os-release &amp;&amp; echo "$VERSION_CODENAME")" stable" | \  sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-2-4-安装Docker"><a href="#2-2-4-安装Docker" class="headerlink" title="2.2.4 安装Docker"></a>2.2.4 安装Docker</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@k8s-master:~# sudo apt-get updateroot@k8s-master:~# sudo apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin# 拉取失败，因此在中国需要加速器root@k8s-master:~# sudo docker run hello-worldUnable to find image 'hello-world:latest' locallydocker: Error response from daemon: Get "https://registry-1.docker.io/v2/": context deadline exceeded (Client.Timeout exceeded while awaiting headers)Run 'docker run --help' for more information<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-2-5-Docker镜像加速器"><a href="#2-2-5-Docker镜像加速器" class="headerlink" title="2.2.5 Docker镜像加速器"></a>2.2.5 Docker镜像加速器</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@k8s-master:~# mkdir -p /etc/dockerroot@k8s-master:~# cd /etc/dockerroot@k8s-master:/etc/docker# vim daemon.json{  "registry-mirrors": [        "https://docker.mirrors.ustc.edu.cn",        "https://mirror.baidubce.com",        "https://docker.m.daocloud.io",        "https://mirror.ccs.tencentyun.com",        "https://docker.nju.edu.cn",        "https://docker.mirrors.sjtug.sjtu.edu.cn",        "https://mirror.gcr.io",        "https://docker.registry.cyou",        "https://docker-cf.registry.cyou",        "https://dockercf.jsdelivr.fyi",        "https://docker.jsdelivr.fyi",        "https://dockertest.jsdelivr.fyi",        "https://mirror.aliyuncs.com",        "https://dockerproxy.com"  ],  "exec-opts": ["native.cgroupdriver=systemd"]}root@k8s-master:~# systemctl daemon-reloadroot@k8s-master:~# systemctl restart dockerroot@k8s-master:~# sudo docker pull hello-worldUsing default tag: latestlatest: Pulling from library/hello-worldDigest: sha256:c41088499908a59aae84b0a49c70e86f4731e588a737f1637e73c8c09d995654Status: Image is up to date for hello-world:latestdocker.io/library/hello-world:latestroot@k8s-master:~# docker imagesREPOSITORY    TAG       IMAGE ID       CREATED        SIZEhello-world   latest    74cc54e27dc4   3 months ago   10.1kB<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-2-6-重启Docker服务"><a href="#2-2-6-重启Docker服务" class="headerlink" title="2.2.6 重启Docker服务"></a>2.2.6 重启Docker服务</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@k8s-master:~# systemctl restart dockerroot@k8s-master:~# docker infoClient: Docker Engine - Community Version:    28.1.1 Context:    default Debug Mode: false Plugins:  buildx: Docker Buildx (Docker Inc.)    Version:  v0.23.0    Path:     /usr/libexec/docker/cli-plugins/docker-buildx  compose: Docker Compose (Docker Inc.)    Version:  v2.35.1    Path:     /usr/libexec/docker/cli-plugins/docker-composeServer: Containers: 2  Running: 1  Paused: 0  Stopped: 1 Images: 2 Server Version: 28.1.1 Storage Driver: overlay2  Backing Filesystem: extfs  Supports d_type: true  Using metacopy: false  Native Overlay Diff: true  userxattr: false Logging Driver: json-file Cgroup Driver: systemd Cgroup Version: 2 Plugins:  Volume: local  Network: bridge host ipvlan macvlan null overlay  Log: awslogs fluentd gcplogs gelf journald json-file local splunk syslog Swarm: inactive Runtimes: io.containerd.runc.v2 runc Default Runtime: runc Init Binary: docker-init containerd version: 05044ec0a9a75232cad458027ca83437aae3f4da runc version: v1.2.5-0-g59923ef init version: de40ad0 Security Options:  apparmor  seccomp   Profile: builtin  cgroupns Kernel Version: 6.8.0-53-generic Operating System: Ubuntu 24.04.2 LTS OSType: linux Architecture: x86_64 CPUs: 2 Total Memory: 3.777GiB Name: k8s-master ID: 6c5b4dc6-423d-47e6-a687-e75062cf4fd9 Docker Root Dir: /var/lib/docker Debug Mode: false Experimental: false Insecure Registries:  ::1/128  127.0.0.0/8 Registry Mirrors:  https://docker.mirrors.ustc.edu.cn/  https://mirror.baidubce.com/  https://docker.m.daocloud.io/  https://mirror.ccs.tencentyun.com/  https://docker.nju.edu.cn/  https://docker.mirrors.sjtug.sjtu.edu.cn/  https://mirror.gcr.io/  https://docker.registry.cyou/  https://docker-cf.registry.cyou/  https://dockercf.jsdelivr.fyi/  https://docker.jsdelivr.fyi/  https://dockertest.jsdelivr.fyi/  https://mirror.aliyuncs.com/  https://dockerproxy.com/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-3-操作容器"><a href="#2-3-操作容器" class="headerlink" title="2.3 操作容器"></a>2.3 操作容器</h2><h3 id="2-3-1-创建持续运行的容器"><a href="#2-3-1-创建持续运行的容器" class="headerlink" title="2.3.1 创建持续运行的容器"></a>2.3.1 创建持续运行的容器</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@k8s-master:~# docker run -d --name nginxtest nginxroot@k8s-master:~# docker psCONTAINER ID   IMAGE     COMMAND                  CREATED              STATUS              PORTS     NAMESb68184fd3b9b   nginx     "/docker-entrypoint.…"   About a minute ago   Up About a minute   80/tcp  nginxtestroot@k8s-master:~# docker ps -aCONTAINER ID   IMAGE    COMMAND                  CREATED              STATUS               PORTS     NAMESb68184fd3b9b   nginx    "/docker-entrypoint.…"   About a minute ago   Up About a minute     80/tcp  nginxtest8ea8394296ac   hello-world   "/hello"            22 minutes ago    Exited (0) 22 minutes ago   goofy_brattain<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-3-2-进入容器"><a href="#2-3-2-进入容器" class="headerlink" title="2.3.2 进入容器"></a>2.3.2 进入容器</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@k8s-master:~# docker exec -it nginxtest /bin/bashroot@b68184fd3b9b:/# cat /etc/nginx/nginx.confroot@b68184fd3b9b:/# exitexitroot@k8s-master:~## @后的主机名在exec后发生了变化，这就是进入容器内的标志<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-3-3-删除容器"><a href="#2-3-3-删除容器" class="headerlink" title="2.3.3 删除容器"></a>2.3.3 删除容器</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@k8s-master:~# docker psCONTAINER ID   IMAGE      COMMAND                  CREATED         STATUS        PORTS       NAMES260028d6b4a2   httpd:v1   "httpd-foreground"       5 seconds ago   Up 4 seconds   0.0.0.0:4000-&gt;80/tcp, [::]:4000-&gt;80/tcp   luoyudockerfileb68184fd3b9b   nginx      "/docker-entrypoint.…"   12 hours ago    Up 12 hours    80/tcp    nginxtestroot@k8s-master:~# docker rm -f nginxtest luoyudockerfilenginxtestluoyudockerfileroot@k8s-master:~# docker psCONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-4-构建-使用镜像"><a href="#2-4-构建-使用镜像" class="headerlink" title="2.4 构建&amp;使用镜像"></a>2.4 构建&amp;使用镜像</h2><h3 id="2-4-1-镜像概述"><a href="#2-4-1-镜像概述" class="headerlink" title="2.4.1 镜像概述"></a>2.4.1 镜像概述</h3><p>  镜像是一个用于创建容器的只读模板，通常来讲，包含一些额外的自定义，比如说，可以构建一个基于centos的镜像，在镜像构建时，直接包含一些应用程序，比如Apache或者其他程序，构建完成后，可以直接基于这个镜像启动容器，快速获得期望的业务</p><p>  镜像可以来自公共的仓库，也可通过Dockerfile等定义文件来构建，并且把自己的镜像推送到仓库中，以备在任何地方任何时间下载使用</p><h3 id="2-4-2-公共镜像仓库"><a href="#2-4-2-公共镜像仓库" class="headerlink" title="2.4.2 公共镜像仓库"></a>2.4.2 公共镜像仓库</h3><p>  Docker公共镜像仓库：<a href="https://hub.docker.com/">https://hub.docker.com</a></p><p>  Docker Hub是一个基于云端的registry服务，这个服务允许我们连接仓库代码、建立镜像、 推送镜像等功能，提供了一个集中式的容器资源管理平台，包含了各式各样的官方镜像，例如Apache、Centos以及各种企业级应用镜像，还以星级和评分来确保镜像的可靠性和适用性</p><p><img src="/images/%E5%85%AC%E5%85%B1%E9%95%9C%E5%83%8F%E5%BA%93.png"></p><p>  打开<a href="https://hub.docker.com,注册一个docker/">https://hub.docker.com，注册一个Docker</a> ID，登陆后浏览各项功能</p><h3 id="2-4-3-镜像分层技术"><a href="#2-4-3-镜像分层技术" class="headerlink" title="2.4.3 镜像分层技术"></a>2.4.3 镜像分层技术</h3><p><img src="/images/%E9%95%9C%E5%83%8F%E5%88%86%E5%B1%82.png"></p><h3 id="2-4-4-构建镜像的方法"><a href="#2-4-4-构建镜像的方法" class="headerlink" title="2.4.4 构建镜像的方法"></a>2.4.4 构建镜像的方法</h3><p>  1.docker commit</p><p>  使用容器中发生更改的部分生成一个新的镜像，通常的使用场景为，基于普通镜像启动了容器，在容器内部署了所需的业务后，把当前的状态重新生成镜像，以便以当前状态快速部署业务所用</p><p>  2.Dockerfile 创建镜像</p><p>  从零开始构建自己所需的镜像，在创建镜像之初把所需的各种设置和所需要的各种应用程序包含进去，生成的镜像可直接用于业务部署</p><p>  3.Dockerfile高频指令集</p><p><img src="/images/dockerfile%E6%8C%87%E4%BB%A4.png"></p><h3 id="2-4-5-Dockerfile-image"><a href="#2-4-5-Dockerfile-image" class="headerlink" title="2.4.5 Dockerfile image"></a>2.4.5 Dockerfile image</h3><p>  在设计Dockerfile时应考虑以下事项：</p><p>  1.容器应该是暂时的</p><p>  2.避免安装不必要的软件包</p><p>  3.每个容器只应该有一个用途</p><p>  4.避免容器有过多的层</p><p>  5.多行排序</p><p>  6.建立缓存</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 创建dockerfile文件root@k8s-master:~# cat &gt; dockerfile &lt;&lt;EOFFROM httpdMAINTAINER luovipyu@163.comRUN echo hello luoyu dockerfile container &gt; /usr/local/apache2/htdocs/index.htmlEXPOSE 80WORKDIR /usr/local/apache2/htdocs/EOF# 开始构建镜像root@k8s-master:~# docker build -t httpd:v1 -f dockerfile .# 查看docker镜像root@k8s-master:~# docker imagesREPOSITORY    TAG       IMAGE ID       CREATED          SIZEhttpd         v1        d6d24a446dd4   25 seconds ago   148MBnginx         latest    a830707172e8   3 weeks ago      192MBhello-world   latest    74cc54e27dc4   3 months ago     10.1kB注明：如果文件名是Dockerfile时可不指定docker build -t web:v1 .# 如果用的是containerd，dockerfile方式构建容器镜像的命令就是下面这样的nerdctl build  -t httpd:v1 -f dockerfile .nerdctl images<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-4-6-使用Dockerfile镜像"><a href="#2-4-6-使用Dockerfile镜像" class="headerlink" title="2.4.6 使用Dockerfile镜像"></a>2.4.6 使用Dockerfile镜像</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 用httpd:v1的镜像在本机4000端口上提供一个名为luoyudockerfile的容器root@k8s-master:~# docker run -d -p 4000:80 --name luoyudockerfile httpd:v1260028d6b4a2b11cd2cfca9ab6ae9d406cc8fa9afd33131db03c880cc235e68froot@k8s-master:~# docker psCONTAINER ID   IMAGE      COMMAND                  CREATED         STATUS        PORTS       NAMES260028d6b4a2   httpd:v1   "httpd-foreground"       5 seconds ago   Up 4 seconds   0.0.0.0:4000-&gt;80/tcp, [::]:4000-&gt;80/tcp   luoyudockerfileb68184fd3b9b   nginx      "/docker-entrypoint.…"   12 hours ago    Up 12 hours    80/tcp    nginxtestroot@k8s-master:~# curl http://127.0.0.1:4000hello luoyu dockerfile container# 如果用的是containerd，dockerfile方式构建容器镜像的使用命令就是下面这样的nerdctl run -d -p 4000:80 --name luoyudockerfile httpd:v1nerdctl ps<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-4-7-关于镜像命名"><a href="#2-4-7-关于镜像命名" class="headerlink" title="2.4.7 关于镜像命名"></a>2.4.7 关于镜像命名</h3><p>  1.镜像命名格式：REPOSITORY+TAG，使用版本号作为命名</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@k8s-master:~# docker imagesREPOSITORY    TAG       IMAGE ID       CREATED        SIZEhttpd         v1        d6d24a446dd4   11 hours ago   148MBnginx         latest    a830707172e8   3 weeks ago    192MBhello-world   latest    74cc54e27dc4   3 months ago   10.1kB<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  2.关于latest tag的说明</p><p>  如果在建立镜像时没有指定Tag，会使用默认值latest，所以，当看到一个镜像的Tag处显示latest的时候，并不一定意味着此版本是最新版，而只意味着在建立镜像的时候，没有指定Tag</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@k8s-master:~# docker build -t web .root@k8s-master:~# docker imagesREPOSITORY    TAG       IMAGE ID       CREATED        SIZEhttpd         v1        d6d24a446dd4   11 hours ago   148MBweb           latest    d6d24a446dd4   11 hours ago   148MBnginx         latest    a830707172e8   3 weeks ago    192MBhello-world   latest    74cc54e27dc4   3 months ago   10.1kB<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-4-8-删除镜像"><a href="#2-4-8-删除镜像" class="headerlink" title="2.4.8 删除镜像"></a>2.4.8 删除镜像</h3><p>  删除一个特定的镜像，需要知道该镜像的ID或者标签(repository:tag)。或者，如果只记得镜像的部分ID，可以使用这个ID来删除镜像</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@k8s-master:~# docker imagesREPOSITORY    TAG       IMAGE ID       CREATED        SIZEhttpd         v1        d6d24a446dd4   11 hours ago   148MBweb           latest    d6d24a446dd4   11 hours ago   148MBnginx         latest    a830707172e8   3 weeks ago    192MBhello-world   latest    74cc54e27dc4   3 months ago   10.1kBroot@k8s-master:~# docker rmi web:latestUntagged: web:latestroot@k8s-master:~# docker rmi 74cc54e27dc4Error response from daemon: conflict: unable to delete 74cc54e27dc4 (must be forced) - image is being used by stopped container 8ea8394296acroot@k8s-master:~# docker ps -aCONTAINER ID   IMAGE         COMMAND    CREATED        STATUS                    PORTS     NAMES8ea8394296ac   hello-world   "/hello"   13 hours ago   Exited (0) 13 hours ago             goofy_brattainroot@k8s-master:~# docker rm 8ea8394296acroot@k8s-master:~# docker rmi 74cc54e27dc4root@k8s-master:~# docker images\REPOSITORY   TAG       IMAGE ID       CREATED        SIZEhttpd        v1        d6d24a446dd4   11 hours ago   148MBnginx        latest    a830707172e8   3 weeks ago    192MB<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-4-9-私有镜像仓库"><a href="#2-4-9-私有镜像仓库" class="headerlink" title="2.4.9 私有镜像仓库"></a>2.4.9 私有镜像仓库</h3><p>  构建私有镜像存储考虑：</p><p>  1.交付时效，例如，下载并运行镜像，需要消耗带宽和时间</p><p>  2.机房是否允许接入外网</p><p>  3.镜像私密，不允许将数据放到外网</p><p>  4.内网速率更高</p><p>  什么是Registry？</p><p>  1.Registry是一个无状态、高度可扩展的服务，可以存储和分发镜像</p><p>  2.Registry是一个基于Apache License许可的开源服务</p><p>  为什么使用Registry？</p><p>  1.严格控制映像存储位置</p><p>  2.拥有完全属于自己的镜像分发渠道</p><p>  3.将镜像存储和分布紧密集成到内部开发工作流程中</p><p>  部署Registry步骤如下：如果选用Harbor，请参考Gitee文档</p><p>  1.下载Docker官方最新版的Registry镜像</p><p>  2.启动Registry容器</p><p>  3.下载测试镜像</p><p>  4.将测试镜像上传至自己的私有仓库</p><p>  5.验证从自有仓库下载并启动容器</p><h1 id="3-部署Harbor私有仓库"><a href="#3-部署Harbor私有仓库" class="headerlink" title="3 部署Harbor私有仓库"></a>3 部署Harbor私有仓库</h1><p>  在现代软件开发中，容器化应用已经成为主流，而容器镜像仓库则是确保容器镜像安全、管理和分发的重要工具。Harbor作为一款开源的企业级容器镜像仓库管理工具，不仅支持多种认证方式，还提供镜像复制、漏洞扫描和用户访问控制等功能，为企业提供了一个安全、高效的镜像管理方案</p><table><thead><tr><th>主机名</th><th>角色</th><th>IP</th><th>VMware网络类型</th><th>用户名</th><th>密码</th><th>系统</th></tr></thead><tbody><tr><td>harbor</td><td>Harbor主机</td><td>192.168.8.52</td><td>NAT</td><td>root</td><td>harbor</td><td>RHEL-9.5</td></tr></tbody></table><h2 id="3-1-RedHat9镜像源配置"><a href="#3-1-RedHat9镜像源配置" class="headerlink" title="3.1 RedHat9镜像源配置"></a>3.1 RedHat9镜像源配置</h2><h3 id="3-1-1-国内镜像源"><a href="#3-1-1-国内镜像源" class="headerlink" title="3.1.1 国内镜像源"></a>3.1.1 国内镜像源</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@harbor ~]# cd /etc/yum.repos.d[root@harbor yum.repos.d]# ll-rw-r--r--. 1 root root 358 May 14 11:25 redhat.repo[root@harbor yum.repos.d]# vim aliyun_yum.repo[ali_baseos]name=ali_baseosbaseurl=https://mirrors.aliyun.com/centos-stream/9-stream/BaseOS/x86_64/os/gpgcheck=0[ali_appstream]name=ali_appstreambaseurl=https://mirrors.aliyun.com/centos-stream/9-stream/AppStream/x86_64/os/gpgcheck=0[root@harbor yum.repos.d]# yum makecache# 根据需要选择是否更新yum源[root@harbor yum.repos.d]# yum -y update<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-1-2-本地yum源配置"><a href="#3-1-2-本地yum源配置" class="headerlink" title="3.1.2 本地yum源配置"></a>3.1.2 本地yum源配置</h3><p>  配置本地yum源可以创建一个本地的软件包存储库，以便更快地安装、更新和管理软件包</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 创建文件夹并将光盘挂载到新建的文件中[root@harbor ~]# mkdir -p /GuaZai/Iso[root@harbor ~]# mount /dev/sr0 /GuaZai/Isomount: /GuaZai/Iso: WARNING: source write-protected, mounted read-only.[root@harbor ~]# cd /GuaZai/Iso[root@harbor Iso]# lsAppStream  BaseOS  EFI  EULA  extra_files.json  GPL  images  isolinux  media.repo  RPM-GPG-KEY-redhat-beta  RPM-GPG-KEY-redhat-release#配置yum文件[root@harbor ~]# vim /etc/yum.repos.d/rhel9.repo[BaseOS]name=rhel9-BaseOSbaseurl=file:///GuaZai/Iso/BaseOSgpgcheck=0[Appstream]name=rhel9-Appstreambaseurl=file:///GuaZai/Iso/AppStreamgpgcheck=0# 查看仓库序列[root@harbor ~]# yum repolist# 生成yum缓存[root@harbor ~]# yum makecache<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-2-主机名和IP地址映射"><a href="#3-2-主机名和IP地址映射" class="headerlink" title="3.2 主机名和IP地址映射"></a>3.2 主机名和IP地址映射</h2><p>  配置Harbor主机的主机名和IP地址映射，映射文件“/etc/hosts”加入如下内容</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@harbor ~]# vim /etc/hosts192.168.8.52 registry.luovip.cn<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="3-3-部署Docker-CE"><a href="#3-3-部署Docker-CE" class="headerlink" title="3.3 部署Docker CE"></a>3.3 部署Docker CE</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 检测系统是否安装了docker并卸载旧版本的容器[root@harbor ~]# sudo dnf remove docker \                  docker-client \                  docker-client-latest \                  docker-common \                  docker-latest \                  docker-latest-logrotate \                  docker-logrotate \                  docker-engine \                  podman \                  runc# 安装依赖[root@harbor ~]# sudo yum install -y yum-utils[root@harbor ~]# sudo dnf -y install dnf-plugins-core[root@harbor ~]# sudo dnf config-manager --add-repo https://download.docker.com/linux/rhel/docker-ce.repo# 安装docker[root@harbor ~]# sudo sed -i 's+https://download.docker.com+https://mirror.nju.edu.cn/docker-ce+' /etc/yum.repos.d/docker-ce.repo[root@harbor ~]# sudo yum install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin# 查看docker状态[root@harbor ~]# sudo systemctl enable --now dockerCreated symlink /etc/systemd/system/multi-user.target.wants/docker.service → /usr/lib/systemd/system/docker.service.[root@harbor ~]# sudo systemctl status docker[root@harbor ~]# docker info                         <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-4-Docker镜像加速器"><a href="#3-4-Docker镜像加速器" class="headerlink" title="3.4 Docker镜像加速器"></a>3.4 Docker镜像加速器</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@harbor ~]# mkdir -p /etc/docker[root@harbor ~]# cd /etc/docker[root@harbor docker]# vim /etc/docker/daemon.json{  "registry-mirrors": [        "https://docker.mirrors.ustc.edu.cn",        "https://mirror.baidubce.com",        "https://docker.m.daocloud.io",        "https://mirror.ccs.tencentyun.com",        "https://docker.nju.edu.cn",        "https://docker.mirrors.sjtug.sjtu.edu.cn",        "https://mirror.gcr.io",        "https://docker.registry.cyou",        "https://docker-cf.registry.cyou",        "https://dockercf.jsdelivr.fyi",        "https://docker.jsdelivr.fyi",        "https://dockertest.jsdelivr.fyi",        "https://mirror.aliyuncs.com",        "https://dockerproxy.com"  ],  "data-root": "/data/docker"   # 自定义Docker的镜像存储路径}[root@harbor ~]# mkdir -p /data/docker[root@harbor ~]# cp -a /var/lib/docker/* /data/docker/[root@harbor ~]# systemctl daemon-reload[root@harbor ~]# systemctl restart docker[root@harbor ~]# docker info# 测试[root@harbor ~]# docker pull nginx[root@harbor ~]# docker imagesREPOSITORY   TAG       IMAGE ID       CREATED       SIZEnginx        latest    a830707172e8   3 weeks ago   192MB<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-5-Compose支持"><a href="#3-5-Compose支持" class="headerlink" title="3.5 Compose支持"></a>3.5 Compose支持</h2><p>  添加Compose支持，并启动Docker服务</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 下载docker-compose并放在/usr/local/bin下curl -L "https://github.com/docker/compose/releases/download/v2.36.0/docker-compose-linux-x86_64" -o /usr/local/bin/docker-composechmod +x /usr/local/bin/docker-composesystemctl daemon-reloadsystemctl restart docker[root@harbor ~]# docker-compose versionDocker Compose version v2.36.0# 注明：github可能会访问不了，故先从github下载到本地，再上传到服务器https://github.com/docker/compose/releases<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-6-下载Harbor"><a href="#3-6-下载Harbor" class="headerlink" title="3.6 下载Harbor"></a>3.6 下载Harbor</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@harbor ~]# wget https://github.com/goharbor/harbor/releases/download/v2.13.0/harbor-offline-installer-v2.13.0.tgz[root@harbor ~]# tar xf harbor-offline-installer-v2.13.0.tgz -C /usr/local/bin# 使用docker load命令将解压后的tar文件加载为Docker镜像[root@harbor ~]# cd /usr/local/bin[root@harbor bin]# lltotal 72004-rwxr-xr-x. 1 root root 73731911 May 14 14:25 docker-composedrwxr-xr-x. 2 root root      123 May 14 16:33 harbor[root@harbor bin]# cd harbor[root@harbor harbor]# docker load -i harbor.v2.13.0.tar.gz<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-7-修改harbor-yml文件"><a href="#3-7-修改harbor-yml文件" class="headerlink" title="3.7 修改harbor.yml文件"></a>3.7 修改harbor.yml文件</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mv harbor.yml.tmpl harbor.yml# 备份harbor.yml文件cp harbor.yml harbor.yml.bak[root@harbor ~]# vim /usr/local/bin/harbor/harbor.yml1.修改hostname为192.168.8.522.修改http的端口为823.修改harbor_admin_password为admin# 如果不启用https就注释掉12行-20行<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-8-安装Harbor"><a href="#3-8-安装Harbor" class="headerlink" title="3.8 安装Harbor"></a>3.8 安装Harbor</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 加载配置并安装[root@harbor harbor]# ./prepare[root@harbor harbor]# ./install.sh...[Step 5]: starting Harbor ...[+] Running 10/10 ✔ Network harbor_harbor        Created    0.0s                                                     ✔ Container harbor-log         Started    0.3s                                                       ✔ Container registryctl        Started    0.8s                                                     ✔ Container harbor-db          Started    1.2s                                                      ✔ Container redis              Started    1.2s                                                  ✔ Container harbor-portal      Started    1.2s                                                           ✔ Container registry           Started    1.3s                                                  ✔ Container harbor-core        Started    1.4s                                               ✔ Container harbor-jobservice  Started    2.0s                                                ✔ Container nginx              Started    2.0s                                           ✔ ----Harbor has been installed and started successfully.----<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-9-重启Harbor"><a href="#3-9-重启Harbor" class="headerlink" title="3.9 重启Harbor"></a>3.9 重启Harbor</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@harbor harbor]# docker-compose down[root@harbor harbor]# ./prepare[root@harbor harbor]# docker-compose up -d# 浏览器访问Harbor   http://192.168.8.52:82  用户名/密码:admin/admin<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-10-生成服务文件"><a href="#3-10-生成服务文件" class="headerlink" title="3.10 生成服务文件"></a>3.10 生成服务文件</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cat &gt; /etc/systemd/system/harbor.service &lt;&lt;EOF[Unit]Description=HarborAfter=docker.service systemd-networkd.service systemd-resolved.serviceRequires=docker.serviceDocumentation=http://github.com/vmware/harbor[Service]Type=simpleRestart=on-failureRestartSec=5ExecStart=/usr/local/bin/docker-compose -f /usr/local/bin/harbor/docker-compose.yml upExecStop=/usr/local/bin/docker-compose -f /usr/local/bin/harbor/docker-compose.yml down[Install]WantedBy=multi-user.targetEOF[root@harbor ~]# systemctl daemon-reload[root@harbor ~]# systemctl enable harbor --now[root@harbor ~]# systemctl stop harbor[root@harbor ~]# systemctl status harbor[root@harbor ~]# systemctl start harbor[root@harbor ~]# systemctl restart harbor<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-11-推送镜像到Harbor"><a href="#3-11-推送镜像到Harbor" class="headerlink" title="3.11 推送镜像到Harbor"></a>3.11 推送镜像到Harbor</h2><p>  将registry.luovip.cn以及其对应的IP添加到/etc/hosts，然后将上述实验中的httpd:v1镜像，改名为带上IP:PORT形式，上传的镜像到本地仓库</p><p>  1.添加域名解析</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@docker ~]# vim /etc/hosts192.168.8.52 registry.luovip.cn<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>  2.编辑文件“/usr/lib/systemd/system/docker.service”，输入以下内容。其中，my.harbor.com是Harbor主机的主机名</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@docker ~]# vim /usr/lib/systemd/system/docker.serviceExecStart=/usr/bin/dockerd --insecure-registry registry.luovip.cn<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>  3.编辑“/etc/docker/daemon.json”文件，在该文件中指定私有镜像仓库地址</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@docker ~]# vim /etc/docker/daemon.json"insecure-registries": [        "192.168.8.52:82"  ][root@docker ~]# systemctl daemon-reload[root@docker ~]# systemctl restart docker.service<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  4.推送的命令</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># Docker推送命令:1.在项目中标记镜像:docker tag SOURCE_IMAGE[:TAG] 192.168.8.52:82/library/REPOSITORY[:TAG]2.推送镜像到当前项目：docker push 192.168.8.52:82/library/REPOSITORY[:TAG]Podman推送命令：1.推送镜像到当前项目：podman push IMAGE_ID 192.168.8.52:82/library/REPOSITORY[:TAG]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  5.推送镜像</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@docker ~]# docker imagesREPOSITORY   TAG       IMAGE ID       CREATED        SIZEtomcat       latest    c6c6349a7df2   47 hours ago   468MBnginx        latest    a830707172e8   4 weeks ago    192MB[root@docker ~]# docker login 192.168.8.52:82[root@docker ~]# docker tag c6c6349a7df2 192.168.8.52:82/library/tomcat:v2[root@docker ~]# docekr images-bash: docekr: command not found[root@docker ~]# docker imagesREPOSITORY                       TAG       IMAGE ID       CREATED        SIZE192.168.8.52:82/library/tomcat   v2        c6c6349a7df2   47 hours ago   468MBtomcat                           latest    c6c6349a7df2   47 hours ago   468MBnginx                            latest    a830707172e8   4 weeks ago    192MB[root@docker ~]# docker push 192.168.8.52:82/library/tomcat:v2[root@docker ~]# docker pull 192.168.8.52:82/library/tomcat:v2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="4-管理容器的资源"><a href="#4-管理容器的资源" class="headerlink" title="4 管理容器的资源"></a>4 管理容器的资源</h1><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 创建容器并观察内存量[root@docker ~]# docker run -d --name=httpd_server httpd[root@docker ~]# docker run -d --name=httpd_tomcat tomcat[root@docker ~]# docker ps -aCONTAINER ID   IMAGE     COMMAND              CREATED         STATUS         PORTS      NAMES796227a2aac7   tomcat    "catalina.sh run"    2 minutes ago   Up 2 minutes   8080/tcp   httpd_tomcatb025ca41d951   httpd     "httpd-foreground"   3 minutes ago   Up 3 minutes   80/tcp     httpd_server[root@docker ~]# docker exec -it httpd_server grep MemTotal /proc/meminfoMemTotal:        3974748 kB[root@docker ~]# docker exec -it httpd_tomcat grep MemTotal /proc/meminfoMemTotal:        3974748 kB<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-1-容器的内存配额"><a href="#4-1-容器的内存配额" class="headerlink" title="4.1 容器的内存配额"></a>4.1 容器的内存配额</h2><p>  根据以上得出结论，每个容器的内存量，全部等于物理宿主机的内存总量，这意味这更好的性能，但同时也意味着一旦业务需求上升，将有可能发生资源争用，这通常在运维规划时，应当极力避免</p><p>  容器可使用的内存：物理内存和交换空间(Swap)</p><p>  Docker默认没有设置内存限制。可以通过相关选项限制设置：</p><p>  1.-m(–memory)：设置容器可用的最大内存，该值最低为4MB</p><p>  2.–memory-swap：允许容器置入磁盘交换空间中的内存大小</p><h3 id="4-1-1-用户内存限制"><a href="#4-1-1-用户内存限制" class="headerlink" title="4.1.1 用户内存限制"></a>4.1.1 用户内存限制</h3><p>  Docker提供4种方式设置容器的用户内存使用:</p><p>  1.对容器内存使用无限制（两个选项都不使用）</p><p>  2.设置内存限制并取消<a href="https://so.csdn.net/so/search?q=%E4%BA%A4%E6%8D%A2%E7%A9%BA%E9%97%B4&amp;spm=1001.2101.3001.7020">交换空间</a>内存限制</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#使用300内存和尽可能多的交换空间[root@docker ~]# docker run -it -m 300M --memory-swap -1 ubuntu /bin/bash<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>  3.只设置内存限制</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"> # 300MB的内存和300MB的交换空间 # 默认情况下虚拟内存总量将设置为内存大小的两倍，因此容器能使用300M的交换空间[root@docker ~]# docker run -it -m 300M ubuntu /bin/bash<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>  4.同时设置内存和交换空间</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 300MB的内存和700MB的交换空间[root@docker ~]# docker run -it -m 300M --memory-swap 700m ubuntu /bin/bash<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="4-1-2-内核内存限制"><a href="#4-1-2-内核内存限制" class="headerlink" title="4.1.2 内核内存限制"></a>4.1.2 内核内存限制</h3><p>  内核内存不能交换到磁盘中，无法使用交换空间，消耗过多可能导致其阻塞系统服务</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 在500MB的内存中，可以使用最高50MB的内核内存[root@docker ~]# docker run -it -m 500M --kernel-memory 50M ubuntu /bin/bash# 只可以使用50MB的内核内存[root@docker ~]# docker run -it --kernel-memory 50M ubuntu /bin/bash<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-1-3-内存预留实现软限制"><a href="#4-1-3-内存预留实现软限制" class="headerlink" title="4.1.3 内存预留实现软限制"></a>4.1.3 内存预留实现软限制</h3><p>  使用–memory-reservation选项设置内存预留，它是一种内存软限制，允许更多的内存共享。设置后，Docker将检测内存争用或内存不足，并强制容器将其内存消耗限制为预留值</p><p>  内存预留值应当始终低于硬限制，作为一个软限制功能，内存预留并不能保证不会超过限制</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 限制内存为500MB，内存预留值(软限制)为200MB。# 当容器消耗内存大于200MB、小于500MB时，下一次系统内存回收将尝试将容器内存缩减到200MB以下[root@docker ~]# docker run -it -m 500M --memory-reservation 200M ubuntu /bin/bashdocker run –it –m 500M --memory-reservation 200M ubuntu /bin/bash# 设置内存软限制为1GB[root@docker ~]# docker run -it —-memory-reservation 1G ubuntu /bin/bash<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-2-容器的CPU配额"><a href="#4-2-容器的CPU配额" class="headerlink" title="4.2 容器的CPU配额"></a>4.2 容器的CPU配额</h2><p>  默认情况下，所有容器都可以使用相同的CPU资源，并且没有任何限制，这和内存问题一样，一旦CPU需求业务上升，同样会引起CPU资源的争用，但是和内存指定绝对量的不同，CPU是通过指定相对权重值来进行的配额</p><p>  使用–cpu-shares参数对CPU来进行配额分配，默认情况下，这个值为1024</p><p>  当前容器中的业务空闲时，其他的容器有权利使用其空闲的CPU周期，这将确保业务的性能</p><p>  CPU限额的分配，只有在物理机资源不足的时候才会生效，并且是根据不同的优先级进行的，当其他容器空闲时，忙碌的容器可以获得全部可用的CPU资源</p><h3 id="4-2-1-CPU份额限制"><a href="#4-2-1-CPU份额限制" class="headerlink" title="4.2.1 CPU份额限制"></a>4.2.1 CPU份额限制</h3><p>  -c(–cpu-shares)选项将CPU份额权重设置为指定的值</p><p>  默认值为1024，如果设置为0，系统将忽略该值并使用默认值1024</p><h3 id="4-2-2-CPU周期限制"><a href="#4-2-2-CPU周期限制" class="headerlink" title="4.2.2 CPU周期限制"></a>4.2.2 CPU周期限制</h3><p>  –cpu-period选项(以μs为单位)设置CPU周期以限制容器CPU资源的使用</p><p>  默认的CFS(完全公平调度器)周期为100ms(100000μs)</p><p>  通常将–cpu-period与–cpu-quota这两个选项配合使用：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 如果只有1个CPU，则容器可以每50ms(50000μs)获得50%(25000/50000)的CPU运行时间[root@docker ~]# docker run -it --cpu-period=50000 --cpu-quota=25000 ubuntu /bin/bash# 可用--cpus选项指定容器的可用CPU资源来达到同样的目的# --cpus选项值是一个浮点数，默认值为0.000，表示不受限制# 上述可改为[root@docker ~]# docker run -it --cpus=0.5 ubuntu /bin/bash# --cpu-period和--cpu-quota选项都是以1个CPU为基准<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-2-3-CPU放置限制"><a href="#4-2-3-CPU放置限制" class="headerlink" title="4.2.3 CPU放置限制"></a>4.2.3 CPU放置限制</h3><p>  –cpuset-cpus选项限制容器进程在指定的CPU上执行</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 容器中的进程可以在cpu1和cpu3上执行[root@docker ~]# docker run -it --cpuset-cpus="1,3" ubuntu:14.04 /bin/bash# 容器中的进程可以在cpu0、cpu1和cpu 2上执行[root@docker ~]# docker run -it --cpuset-cpus="0-2" ubuntu:14.04 /bin/bash<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-2-4-CPU配额限制"><a href="#4-2-4-CPU配额限制" class="headerlink" title="4.2.4 CPU配额限制"></a>4.2.4 CPU配额限制</h3><p>  –cpu-quota选项限制容器的CPU配额，默认值为0表示容器占用100%的CPU资源个CPU</p><p>  CFS用于处理进程执行的资源分配，是由内核使用的默认Linux调度程序。将此值设置50000意味着限制容器至多使用CPU资源的50%，对于多个CPU而言，调整–cpu-quota选项必要的</p><h2 id="4-3-容器的I-O配额"><a href="#4-3-容器的I-O配额" class="headerlink" title="4.3 容器的I/O配额"></a>4.3 容器的I/O配额</h2><p>  默认情况下，所有容器都可以使用相同的I/O资源(500权重)，并且没有任何限制，这和内存、 CPU问题一样，一旦I/O需求业务上升，硬盘读写会变得非常迟缓，所以为了更好的提供服务，也应该对容器使用硬盘方面进行调整</p><p>  块I/O带宽(Block I/O Bandwidth，Blkio)是另一种可以限制容器使用的资源</p><p>  块I/O指磁盘的写，Docker可通过设置权重限制每秒字节数(B/s)和每秒I/O次数(IO/s)的方式控制容器读写盘的带宽</p><h3 id="4-3-1-设置块I-O权重"><a href="#4-3-1-设置块I-O权重" class="headerlink" title="4.3.1 设置块I/O权重"></a>4.3.1 设置块I/O权重</h3><p>  –blkio-weight选项更改比例(原默认为500)，设置相对于所有其他正在运行的容器的块I/O带宽权重</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 创建两个有不同块I/O带宽权重的容器[root@docker ~]# docker run -it --name c1 --blkio-weight 300 ubuntu /bin/bash[root@docker ~]# docker run -it --name c2 --blkio-weight 600 ubuntu /bin/bash在以下案例中，权重为600的容器将比300的在I/O能力方面多出两倍:[root@docker ~]# docker run -d --name 300io --blkio-weight 300 httpd[root@docker ~]# docker run -d --name 600io --blkio-weight 600 httpd命令测试I/O性能:[root@docker ~]# time dd if=/dev/zero of=test.out bs=1M count=10241024+0 records in1024+0 records out1073741824 bytes (1.1 GB, 1.0 GiB) copied, 4.05265 s, 265 MB/sreal    0m4.055suser    0m0.000ssys     0m4.036s注：此设定在I/O争用时，才会体现<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-3-2-限制设备读写速率"><a href="#4-3-2-限制设备读写速率" class="headerlink" title="4.3.2 限制设备读写速率"></a>4.3.2 限制设备读写速率</h3><p>  Docker根据两类指标限制容器的设备读写速率：一类是每秒字节数，另一类是每秒I/O次数</p><p>  1.限制每秒字节数</p><p>  –device-read-bps选项限制指定设备的读取速率，即每秒读取的字节数</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 创建一个容器，并限制对/dev/mapper/rhel-swap设备的读取速率为每秒1MB[root@docker ~]# docker run -it --device-read-bps /dev/mapper/rhel-swap:1mb ubuntudocker run -it --device-read-bps /dev/sda:1mb ubuntu# 类似地，可使用--device-write-bps选项限制指定设备的写入速率。格式： &lt;设备&gt;:&lt;速率值&gt;[单位]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  2.限制每秒I/O次数</p><p>  –device-read-iops和–device-write-iops选项制指定设备的读取和写入速率，用每秒I/O次数表示</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 创建一个容器，限制它对/dev/mapper/rhel-swap设备的读取速率为每秒1000次[root@docker ~]# docker run -it --device-read-iops /dev/mapper/rhel-swap:1000 ubuntu<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="4-4-容器底层技术实现"><a href="#4-4-容器底层技术实现" class="headerlink" title="4.4 容器底层技术实现"></a>4.4 容器底层技术实现</h2><p>  对容器使用的内存、CPU和块I/O带宽资源的限制具体是由控制组(Cgroup)的相应子系统来实现的</p><p>  1.memory子系统设置控制组中的住务所使用的内存限制</p><p>  2.cpu子系统通过调度程序提供对CPU的控制组任务的访问</p><p>  3.blkio子系统为块设备(如磁盘、固态硬盘、USB等)设置输入和输出限制</p><p>  在docker run命令中使用–cpu-shares、–memory、–device-read-bps等选项实际上就是在配置控制组，相关的配置文件保存在/sys/fs/cgroup目录中</p><h3 id="4-4-1-资源限制的底层实现"><a href="#4-4-1-资源限制的底层实现" class="headerlink" title="4.4.1 资源限制的底层实现"></a>4.4.1 资源限制的底层实现</h3><p>  Linux通过cgroup来分配进程使用的CPU、memory、I/O资源的配额，可以通过/sys/fs/cgroup/下面的设定来查看容器的配额部分</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 启动一个容器，设置内存限额为300MB，CPU权重为512[root@docker ~]# docker run --rm -d -p 8080:80 -m 300M --cpu-shares=512 httpd1dc9a3907b6b82521addd810d52d2514c6ab5fed1e274f03a90e5a1454d16a49# 动态更改容器的资源限制# docker update命令可以动态地更新容器配置，其语法：docker update [选项] 容器 [容器...][root@docker ~]# docker update -m 500M --cpu-shares=10245 1dc9a3907b6b82521addd810d52d2514c6ab5fed1e274f03a90e5a1454d16a491dc9a3907b6b82521addd810d52d2514c6ab5fed1e274f03a90e5a1454d16a49<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-4-2-容器的隔离底层实现"><a href="#4-4-2-容器的隔离底层实现" class="headerlink" title="4.4.2 容器的隔离底层实现"></a>4.4.2 容器的隔离底层实现</h3><p>  每个容器貌似都有自己独立的根目录以及/etc、/var等目录，而且貌似都有自己的独立网卡，但事实上物理宿主机只有一个网卡，那么容器之间是怎么实现的“独立性”的呢？</p><p>  Linux使用namespace技术来实现了容器间的资源隔离，namespace管理着宿主机中的全局唯一资源，并且可以让每个容器都会认为自己拥有且只有自己在使用资源，namespace一共有6种，分别为：mount、UTS、IPC、PID、Network、User</p><h3 id="4-4-3-namespace"><a href="#4-4-3-namespace" class="headerlink" title="4.4.3 namespace"></a>4.4.3 namespace</h3><p>  Mount namespace让容器看上去拥有整个文件系统，容器有自己的根目录</p><p>  UTS namespace可以让容器有自己的主机名，默认情况下，容器的主机名是它本身的短ID，可通过-h或者–hostname设置主机名</p><p>  IPC namespace可以让容器拥有自己的共享内存和信号量来实现进程间通信</p><p>  PID namespace让容器拥有自己的进程树，可以在容器中执行ps命令查看</p><p>  Network namespace可以让容器拥有自己独立的网卡、IP、路由等资源</p><p>  User namespace 让容器能够管理自己的用户，而不是和宿主机公用/etc/passwd</p><h1 id="5-容器原生网络与存储"><a href="#5-容器原生网络与存储" class="headerlink" title="5 容器原生网络与存储"></a>5 容器原生网络与存储</h1><h2 id="5-1-容器原生网络"><a href="#5-1-容器原生网络" class="headerlink" title="5.1 容器原生网络"></a>5.1 容器原生网络</h2><p>  docker原生提供了以下几种网络，如果对原生网络不满意，还可以创建自定义网络<br>  原生网络分为：none、bridge、host，这些网络在docker安装的时候会自动创建，可以通过以下命令来查看</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@docker ~]# docker network lsNETWORK ID     NAME      DRIVER    SCOPEf85881372579   bridge    bridge    local668aba04b5b0   host      host      local3fa8ef65ab94   none      null      local<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  如果容器使用的是none网络，那么此容器将不具备常规理解上的网卡，只具备lo网络，如果要使用这个网络，在创建容器时，指定–network=none即可</p><p>  None网络是比较封闭的网络，对一些安全要求比较高并且不需要联网的场景，可以用none网络，比如手机上接收的验证码、随机数生成等场景，就可以放在none网络中以避免被窃取</p><p>  Host网络是一个共享宿主机网络栈的一个容器共享网络，可以通过–network=host在创建容器 的时候指定host网络，处于host网络模式的容器，网络配置和宿主机是完全一样的，也就是说，在容器中可以看到宿主机的所有网卡，并且主机名也是宿主机的，这最大的好处就是性能很高，传输速率特别好，但是宿主机上已经使用的端口，容器就不可以使用</p><h2 id="5-2-容器和层"><a href="#5-2-容器和层" class="headerlink" title="5.2 容器和层"></a>5.2 容器和层</h2><p>  容器和镜像最大的不同在于最顶上的可写层，所有在容器中的数据写入和修改都会直接存储到这个可写层中，这就意味着，当容器被删除时，可写层中的数据就丢失了，虽然每个容器都有自己不同的可写层，但是容器底层的镜像却是可以同时共享的</p><p><img src="/images/%E5%AE%B9%E5%99%A8%E5%92%8C%E5%B1%82.png"></p><h2 id="5-3-主流存储驱动"><a href="#5-3-主流存储驱动" class="headerlink" title="5.3 主流存储驱动"></a>5.3 主流存储驱动</h2><p>  在容器设计和使用的时候，在容器的可写层中写入的数据是非常少的，但在运维中大部分数据是必须要具备持久化保存的能力，所以在容器中引入了多种的存储驱动来解决上面说的可写层数据的易失性</p><p>  目前主流受支持的存储驱动有：</p><p><img src="/images/%E5%AD%98%E5%82%A8%E9%A9%B1%E5%8A%A8.png"></p><h2 id="5-4-Copy-on-write策略"><a href="#5-4-Copy-on-write策略" class="headerlink" title="5.4 Copy-on-write策略"></a>5.4 Copy-on-write策略</h2><p><img src="/images/Copy-on-write.png"></p><h2 id="5-5-容器数据管理"><a href="#5-5-容器数据管理" class="headerlink" title="5.5 容器数据管理"></a>5.5 容器数据管理</h2><p>  容器中持久化数据一般采用两种存储方式：</p><p>   1.volume</p><p>   2.bind mount</p><p><img src="/images/%E6%8C%81%E4%B9%85%E5%8C%96%E6%95%B0%E6%8D%AE.png"></p><h1 id="6-Kubernetes"><a href="#6-Kubernetes" class="headerlink" title="6 Kubernetes"></a>6 Kubernetes</h1><h2 id="6-1-K8S的概念"><a href="#6-1-K8S的概念" class="headerlink" title="6.1 K8S的概念"></a>6.1 K8S的概念</h2><p>  Kubernetes是一个可移植的、可扩展的开源平台，用于管理容器化的工作负载和服务，可促进声明式配置和自动化</p><p>  Kubernetes拥有一个庞大且快速增长的生态系统。Kubernetes 的服务、支持和工具广泛可用</p><p><img src="/images/k8s.png"></p><h2 id="6-2-K8S的特点"><a href="#6-2-K8S的特点" class="headerlink" title="6.2 K8S的特点"></a>6.2 K8S的特点</h2><p>  Kubernetes具有以下几个特点：</p><p>   1.可移植: 支持公有云、私有云、混合云、多重云（multi-cloud）</p><p>   2.可扩展: 模块化、插件化、可挂载、可组合</p><p>   3.自动化: 自动部署、自动重启、自动复制、自动伸缩/扩展</p><h2 id="6-3-K8S的作用"><a href="#6-3-K8S的作用" class="headerlink" title="6.3 K8S的作用"></a>6.3 K8S的作用</h2><p>  Kubernetes的主要职责是容器编排(Container Orchestration)，即在一组服务器上启动、 监控、回收容器，在满足排程的同时，保证容器可以健康的运行</p><p><img src="/images/k8s%E7%9A%84%E4%BD%9C%E7%94%A8.png"></p><h2 id="6-4-K8S的整体架构"><a href="#6-4-K8S的整体架构" class="headerlink" title="6.4 K8S的整体架构"></a>6.4 K8S的整体架构</h2><p><img src="/images/k8s%E7%9A%84%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84.png"></p><h3 id="6-4-1-Master节点"><a href="#6-4-1-Master节点" class="headerlink" title="6.4.1 Master节点"></a>6.4.1 Master节点</h3><p>1.kube-apiserver</p><p>  API服务器是Kubernetes控制面的前端</p><p>  Kubernetes API服务器的主要实现是kube-apiserver</p><p>  kube-apiserver设计上考虑了水平伸缩，可通过部署多个实例进行伸缩。 可以运行kube-apiserver的多个实例，并在这些实例之间平衡流</p><p>2.etcd</p><p>  etcd是兼具一致性和高可用性的键值数据库，可以作为保存Kubernetes所有集群数据的后台数据库</p><p>3.cloud-controller-manager</p><p>  cloud-controller-manager仅运行特定于云平台的控制回路</p><p>  如果在自己的环境中运行Kubernetes，或者在本地计算机中运行学习环境， 所部署的环境中不需要云控制器管理器</p><p>4.kube-scheduler</p><p>  控制平面组件，负责监视新创建的、未指定运行节点（node）的 Pods，选择节点让 Pod 在上面运行</p><p>5.kube-controller-manager</p><p>  这些控制器包括:</p><p>  节点控制器（Node Controller）: 负责在节点出现故障时进行通知和响应</p><p>  任务控制器（Job controller）: 监测代表一次性任务的Job对象，然后创建Pods来运行这些任务直至完成</p><p>  端点控制器（Endpoints Controller）: 填充端点(Endpoints)对象(即加入 Service 与 Pod)</p><p>  服务帐户和令牌控制器（Service Account &amp; Token Controllers）: 为新的命名空间创建默认帐户和API访问令牌</p><h3 id="6-4-2-Node节点"><a href="#6-4-2-Node节点" class="headerlink" title="6.4.2 Node节点"></a>6.4.2 Node节点</h3><p>1.kubelet</p><p>  一个在集群中每个节点（node）上运行的代理，保证容器（containers）都运行在Pod中</p><p>2.kube-proxy</p><p>  kube-proxy是集群中每个节点上运行的网络代理， 实现Kubernetes服务(Service)概念的一部分</p><p>  kube-proxy 维护节点上的网络规则。这些网络规则允许从集群内部或外部的网络会话与Pod进行网络通信</p><p>  如果操作系统提供了数据包过滤层并可用的话，kube-proxy会通过它来实现网络规则。否则， kube-proxy仅转发流量本身</p><p>3.容器运行时（Container Runtime）</p><p>  Kubernetes支持多个容器运行环境: Docker、 containerd、CRI-O以及任何实现Kubernetes CRI (容器运行环境接口)</p><h3 id="6-4-3-插件-Addons"><a href="#6-4-3-插件-Addons" class="headerlink" title="6.4.3 插件(Addons)"></a>6.4.3 插件(Addons)</h3><p>  插件使用Kubernetes资源（DaemonSet、 Deployment等）实现集群功能。 因为这些插件提供集群级别的功能，插件中命名空间域的资源属于kube-system命名空间</p><p>  1.Core-dns：为整个集群提供DNS服务</p><p>  2.Ingress Controller：为service提供外网访问入口</p><p>  3.Dashboard: 提供图形化管理界面</p><p>  4.Flannel/ Calico ：为kubernetes提供方便的网络规划服务</p><h1 id="7-Kubernetes集群部署"><a href="#7-Kubernetes集群部署" class="headerlink" title="7 Kubernetes集群部署"></a>7 Kubernetes集群部署</h1><h2 id="7-1-Kubernetes的安装流程"><a href="#7-1-Kubernetes的安装流程" class="headerlink" title="7.1 Kubernetes的安装流程"></a>7.1 Kubernetes的安装流程</h2><h3 id="7-1-1-先决条件"><a href="#7-1-1-先决条件" class="headerlink" title="7.1.1 先决条件"></a>7.1.1 先决条件</h3><p>  1.最小配置：2G内存2核CPU</p><p>  2.集群中的所有机器的网络彼此均能相互连接(公网和内网都可以)</p><p>  3.节点之中不可以有重复的主机名、MAC 地址或product_uuid</p><p>  4.禁用交换分区</p><p>  5.开启机器上的某些端口</p><h3 id="7-1-2-安装runtime"><a href="#7-1-2-安装runtime" class="headerlink" title="7.1.2 安装runtime"></a>7.1.2 安装runtime</h3><p>  默认情况下，Kubernetes使用容器运行时接口（Container Runtime Interface，CRI） 与所选择的容器运行时交互</p><p>  如果不指定运行时，则kubeadm会自动尝试检测到系统上已经安装的运行时， 方法是扫描一组众所周知的Unix域套接字，docker启用shim来对接K8S</p><p>  运行时的域套接字：<br>  Docker unix:///var/run/cri-dockerd.sock</p><p>  containerd /run/containerd/containerd.sock</p><p>  CRI-O /var/run/crio/crio.sock</p><h3 id="7-1-3-安装kubeadm、kubelet和kubectl"><a href="#7-1-3-安装kubeadm、kubelet和kubectl" class="headerlink" title="7.1.3 安装kubeadm、kubelet和kubectl"></a>7.1.3 安装kubeadm、kubelet和kubectl</h3><p>  需要在每台机器上安装以下软件包：</p><p>  kubeadm：用来初始化集群的指令</p><p>  kubelet：在集群中的每个节点上用来启动Pod和容器等</p><p>  kubectl：用来与集群通信的命令行工具</p><p>  确保它们与通过kubeadm安装的控制平面的版本相匹配。 不然可能会导致一些预料之外的错误和问题。 然而，控制平面与kubelet间的相差一个次要版本不一致是支持的，但kubelet的版本不可以超过API服务器的版本。 例如，1.7.0 版本的kubelet可以完全兼容1.8.0版本的API 服务器，反之则不可以</p><h3 id="7-1-4-检查所需端口"><a href="#7-1-4-检查所需端口" class="headerlink" title="7.1.4 检查所需端口"></a>7.1.4 检查所需端口</h3><p>1.控制平面</p><table><thead><tr><th align="left">协议</th><th align="left">方向</th><th align="left">端口范围</th><th align="left">作用</th><th align="left">使用者</th></tr></thead><tbody><tr><td align="left">TCP</td><td align="left">入站</td><td align="left">6443</td><td align="left">Kubernetes API服务器</td><td align="left">所有组件</td></tr><tr><td align="left">TCP</td><td align="left">入站</td><td align="left">2379-2380</td><td align="left">etcd服务器客户端API</td><td align="left">kube-apiserver,etcd</td></tr><tr><td align="left">TCP</td><td align="left">入站</td><td align="left">10250</td><td align="left">Kubelet API</td><td align="left">kubelet自身、控制平面组件</td></tr><tr><td align="left">TCP</td><td align="left">入站</td><td align="left">10251</td><td align="left">kube-scheduler</td><td align="left">kube-scheduler自身</td></tr><tr><td align="left">TCP</td><td align="left">入站</td><td align="left">10252</td><td align="left">kube-controller-manager</td><td align="left">kube-controller-manager自身</td></tr></tbody></table><p>2.工作节点</p><table><thead><tr><th align="left">协议</th><th align="left">方向</th><th align="left">端口范围</th><th align="left">作用</th><th align="left">使用者</th></tr></thead><tbody><tr><td align="left">TCP</td><td align="left">入站</td><td align="left">10250</td><td align="left">Kubelet API</td><td align="left">kubelet自身、控制平面组件</td></tr><tr><td align="left">TCP</td><td align="left">入站</td><td align="left">30000-32767</td><td align="left">NodePort服务</td><td align="left">所有组件</td></tr></tbody></table><h3 id="7-1-5-Iptables桥接流量"><a href="#7-1-5-Iptables桥接流量" class="headerlink" title="7.1.5 Iptables桥接流量"></a>7.1.5 Iptables桥接流量</h3><p>  为了让Linux节点上的iptables能够正确地查看桥接流量，需要确保sysctl配置中将net.bridge.bridge-nf-call-iptables设置为1</p><p><img src="/images/iptables.png"></p><h3 id="7-1-6-环境准备"><a href="#7-1-6-环境准备" class="headerlink" title="7.1.6 环境准备"></a>7.1.6 环境准备</h3><p>  本K8S集群使用3台机器(ubuntu)进行部署，各节点信息如下表：</p><p>  注明：使用的容器为Docker</p><table><thead><tr><th align="left">主机名</th><th align="left">角色</th><th align="left">IP</th><th align="left">VMware网络类型</th><th align="left">用户名</th><th align="left">密码</th><th align="left">互联网连接</th></tr></thead><tbody><tr><td align="left">k8s-master</td><td align="left">控制平面</td><td align="left">192.168.8.3</td><td align="left">NAT</td><td align="left">vagrant root</td><td align="left">vagrant vargrant</td><td align="left">是</td></tr><tr><td align="left">k8s-worker1</td><td align="left">数据平面</td><td align="left">192.168.8.4</td><td align="left">NAT</td><td align="left">vagrant root</td><td align="left">vagrant vargrant</td><td align="left">是</td></tr><tr><td align="left">k8s-worker2</td><td align="left">数据平面</td><td align="left">192.168.8.5</td><td align="left">NAT</td><td align="left">vagrant root</td><td align="left">vagrant vargrant</td><td align="left">是</td></tr></tbody></table><p>准备DNS解析：</p><p>  这一步需要在所有机器上完成</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 这一步需要在所有机器上完成cat &gt;&gt; /etc/hosts &lt;&lt;EOF192.168.8.3 k8s-master192.168.8.4 k8s-worker1192.168.8.5 k8s-worker2192.168.30.133 registry.xiaohui.cnEOF<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="7-2-Docker-CE-部署"><a href="#7-2-Docker-CE-部署" class="headerlink" title="7.2 Docker CE 部署"></a>7.2 Docker CE 部署</h2><h3 id="7-2-1-添加Docker仓库"><a href="#7-2-1-添加Docker仓库" class="headerlink" title="7.2.1 添加Docker仓库"></a>7.2.1 添加Docker仓库</h3><p>  这一步要在所有机器上完成：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 安装依赖sudo apt-get updatesudo apt-get install -y ca-certificates curl gnupg lsb-release# 添加公钥到系统sudo mkdir -p /etc/apt/keyringscurl -fsSL https://mirrors.nju.edu.cn/docker-ce/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg# 添加仓库到系统echo "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://mirrors.nju.edu.cn/docker-ce/linux/ubuntu $(lsb_release -cs) stable" | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null# 判断仓库是否已做好sudo apt-get update<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="7-2-2-安装Docker-CE"><a href="#7-2-2-安装Docker-CE" class="headerlink" title="7.2.2 安装Docker CE"></a>7.2.2 安装Docker CE</h3><p>  这一步要在所有机器上完成：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo apt-get install -y docker-ce docker-ce-cli containerd.io docker-compose-plugin# 部署完Docker CE之后，还需要cri-docker shim才可以和Kubernetes集成<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="7-2-3-CRI-Docker部署"><a href="#7-2-3-CRI-Docker部署" class="headerlink" title="7.2.3 CRI-Docker部署"></a>7.2.3 CRI-Docker部署</h3><p>  这一步要在所有机器上完成：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 下载cri-dockerwget http://hub.gitmirror.com/https://github.com/Mirantis/cri-dockerd/releases/download/v0.3.17/cri-dockerd_0.3.17.3-0.ubuntu-jammy_amd64.deb# 安装cri-dockerdpkg -i cri-dockerd_0.3.17.3-0.ubuntu-jammy_amd64.deb<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="7-2-4-Docker镜像加速器"><a href="#7-2-4-Docker镜像加速器" class="headerlink" title="7.2.4 Docker镜像加速器"></a>7.2.4 Docker镜像加速器</h3><p>  这一步要在所有机器上完成：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">vim /etc/docker/daemon.json{  "registry-mirrors": [        "https://docker.mirrors.ustc.edu.cn",        "https://mirror.baidubce.com",        "https://docker.m.daocloud.io",        "https://mirror.ccs.tencentyun.com",        "https://docker.nju.edu.cn",        "https://docker.mirrors.sjtug.sjtu.edu.cn",        "https://mirror.gcr.io",        "https://docker.registry.cyou",        "https://docker-cf.registry.cyou",        "https://dockercf.jsdelivr.fyi",        "https://docker.jsdelivr.fyi",        "https://dockertest.jsdelivr.fyi",        "https://mirror.aliyuncs.com",        "https://dockerproxy.com"  ],  "exec-opts": ["native.cgroupdriver=systemd"]}systemctl daemon-reloadsystemctl restart docker<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="7-2-5-将镜像指引到国内"><a href="#7-2-5-将镜像指引到国内" class="headerlink" title="7.2.5 将镜像指引到国内"></a>7.2.5 将镜像指引到国内</h3><p>  这一步要在所有机器上完成：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cp /lib/systemd/system/cri-docker.service /etc/systemd/system/cri-docker.servicesed -i 's/ExecStart=.*/ExecStart=\/usr\/bin\/cri-dockerd --container-runtime-endpoint fd:\/\/ --network-plugin=cni --pod-infra-container-image=registry.cn-hangzhou.aliyuncs.com\/google_containers\/pause:3.10/' /etc/systemd/system/cri-docker.servicesystemctl daemon-reloadsystemctl restart cri-docker.servicesystemctl enable cri-docker.service<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="7-3-Kubernetes部署"><a href="#7-3-Kubernetes部署" class="headerlink" title="7.3 Kubernetes部署"></a>7.3 Kubernetes部署</h2><h3 id="7-3-1-关闭swap分区"><a href="#7-3-1-关闭swap分区" class="headerlink" title="7.3.1 关闭swap分区"></a>7.3.1 关闭swap分区</h3><p>  这一步要在所有机器上完成：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 实时关闭swapoff -a# 永久关闭sed -i 's/.*swap.*/#&amp;/' /etc/fstab<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="7-3-2-允许iptables检查桥接流量"><a href="#7-3-2-允许iptables检查桥接流量" class="headerlink" title="7.3.2 允许iptables检查桥接流量"></a>7.3.2 允许iptables检查桥接流量</h3><p>  这一步要在所有机器上完成：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cat &lt;&lt;EOF | sudo tee /etc/modules-load.d/k8s.confbr_netfilterEOFmodprobe br_netfiltercat &lt;&lt;EOF | sudo tee /etc/sysctl.d/k8s.confnet.bridge.bridge-nf-call-ip6tables = 1net.bridge.bridge-nf-call-iptables = 1net.ipv4.ip_forward = 1EOFsudo sysctl --system<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="7-3-3-安装kubeadm"><a href="#7-3-3-安装kubeadm" class="headerlink" title="7.3.3 安装kubeadm"></a>7.3.3 安装kubeadm</h3><p>  这一步要在所有机器上完成：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 安装依赖apt-get update &amp;&amp; apt-get install -y apt-transport-https curl# 安装K8S软件包仓库-阿里云cat &gt; /etc/apt/sources.list.d/k8s.list &lt;&lt;EOFdeb https://mirrors.aliyun.com/kubernetes-new/core/stable/v1.32/deb /EOF# 安装软件包仓库的公钥curl -fsSL https://mirrors.aliyun.com/kubernetes-new/core/stable/v1.32/deb/Release.key | apt-key add -# 更新软件包的仓库索引apt-get update# 开始安装apt-get install -y kubelet kubeadm kubectl# 操作系统所有软件包升级时将忽略kubelet、kubeadm、kubectlapt-mark hold kubelet kubeadm kubectl<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="7-3-4-添加命令自动补齐"><a href="#7-3-4-添加命令自动补齐" class="headerlink" title="7.3.4 添加命令自动补齐"></a>7.3.4 添加命令自动补齐</h3><p>  这一步要在所有机器上完成：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">kubectl completion bash &gt; /etc/bash_completion.d/kubectlkubeadm completion bash &gt; /etc/bash_completion.d/kubeadmsource /etc/bash_completion.d/kubectlsource /etc/bash_completion.d/kubeadm<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="7-3-5-集成CRI-Docker"><a href="#7-3-5-集成CRI-Docker" class="headerlink" title="7.3.5 集成CRI-Docker"></a>7.3.5 集成CRI-Docker</h3><p>  这一步要在所有机器上完成：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">crictl config --set runtime-endpoint unix:///run/cri-dockerd.sockcrictl images<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="7-3-6-集群部署"><a href="#7-3-6-集群部署" class="headerlink" title="7.3.6 集群部署"></a>7.3.6 集群部署</h3><p>  kubeadm.yaml中name字段必须在网络中可被解析，也可以将解析记录添加到集群中所有机器的/etc/hosts中</p><p>  初始化集群部署的操作只能在k8s-master上执行</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 初始化配置kubeadm config print init-defaults &gt; kubeadm.yamlsed -i 's/.*advert.*/  advertiseAddress: 192.168.8.3/g' kubeadm.yamlsed -i 's/.*name.*/  name: k8s-master/g' kubeadm.yamlsed -i 's|imageRepo.*|imageRepository: registry.cn-hangzhou.aliyuncs.com/google_containers|g' kubeadm.yamlsed -i "/^\\s*networking:/a\\  podSubnet: 172.16.0.0/16" kubeadm.yaml# 注意下面的替换，只有在集成的是CRI-Docker时才需要执行，Containerd不需要sed -i 's/  criSocket.*/  criSocket: unix:\/\/\/run\/cri-dockerd.sock/' kubeadm.yaml# 模块加载modprobe br_netfilter # 集群初始化kubeadm init --config kubeadm.yamlYour Kubernetes control-plane has initialized successfully!......kubeadm join 192.168.8.3:6443 --token abcdef.0123456789abcdef \        --discovery-token-ca-cert-hash sha256:c2546a856290440a8ccaf9223c14fd1c2098ac74f4a584acf5f3c5a373005207                # 授权管理权限mkdir -p $HOME/.kubesudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/configsudo chown $(id -u):$(id -g) $HOME/.kube/config# 查看集群状态root@k8s-master:~# kubectl get nodesNAME         STATUS     ROLES           AGE   VERSIONk8s-master   NotReady   control-plane   62m   v1.32.5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="7-3-7-部署Calico网络插件"><a href="#7-3-7-部署Calico网络插件" class="headerlink" title="7.3.7 部署Calico网络插件"></a>7.3.7 部署Calico网络插件</h3><p>  Calico网络插件部署的操作在所有节点上执行</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 使用operator安装calico组件-可能会失败# 以下为github的地址，可能会失败root@k8s-master:~# kubectl create -f https://raw.gitmirror.com/projectcalico/calico/refs/tags/v3.29.3/manifests/tigera-operator.yaml# 解决办法：# 1.获取Calico images到本地    见Calico.txt    # 2.发布本地的yaml到集群-masterkubectl create -f https://www.linuxcenter.cn/files/cka/cka-yaml/tigera-operator-calico-3.29.3.yamlroot@k8s-master:~# kubectl get pod -ANAMESPACE         NAME                                 READY   STATUS    RESTARTS   AGEkube-system       coredns-76fccbbb6b-l7jq9             0/1     Pending   0          163mkube-system       coredns-76fccbbb6b-nd68g             0/1     Pending   0          163mkube-system       etcd-k8s-master                      1/1     Running   0          163mkube-system       kube-apiserver-k8s-master            1/1     Running   0          163mkube-system       kube-controller-manager-k8s-master   1/1     Running   0          163mkube-system       kube-proxy-mcwv7                     1/1     Running   0          163mkube-system       kube-scheduler-k8s-master            1/1     Running   0          163mtigera-operator   tigera-operator-75b4cd596c-9hjml     1/1     Running   0          7m5s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="7-3-8-设置calico在集群的网段"><a href="#7-3-8-设置calico在集群的网段" class="headerlink" title="7.3.8 设置calico在集群的网段"></a>7.3.8 设置calico在集群的网段</h3><p>  这一步在k8s-master上执行</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 使用下面的自定义资源设置一下calico在集群中的网段# 以下为github的地址，可能会失败root@k8s-master:~# wget https://raw.gitmirror.com/projectcalico/calico/refs/tags/v3.29.3/manifests/custom-resources.yaml# 3.使用下面的地址执行root@k8s-master:~# wget https://www.linuxcenter.cn/files/cka/cka-yaml/custom-resources-calico-3.29.3.yamlroot@k8s-master:~# mv custom-resources-calico-3.29.3.yaml custom-resources.yaml<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="7-3-9-确认资源的地址"><a href="#7-3-9-确认资源的地址" class="headerlink" title="7.3.9 确认资源的地址"></a>7.3.9 确认资源的地址</h3><p>  这一步在k8s-master上执行</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@k8s-master:~# vim custom-resources.yaml# This section includes base Calico installation configuration.# For more information, see: https://docs.tigera.io/calico/latest/reference/installation/api#operator.tigera.io/v1.InstallationapiVersion: operator.tigera.io/v1kind: Installationmetadata:  name: defaultspec:  # Configures Calico networking.  calicoNetwork:    ipPools:    - name: default-ipv4-ippool      blockSize: 26      cidr: 172.16.0.0/16      #这里换成上面规定好的172.16.0.0/16      encapsulation: VXLANCrossSubnet      natOutgoing: Enabled      nodeSelector: all()---# This section configures the Calico API server.# For more information, see: https://docs.tigera.io/calico/latest/reference/installation/api#operator.tigera.io/v1.APIServerapiVersion: operator.tigera.io/v1kind: APIServermetadata:  name: defaultspec: {}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="7-3-10-自定义资源发布到集群"><a href="#7-3-10-自定义资源发布到集群" class="headerlink" title="7.3.10 自定义资源发布到集群"></a>7.3.10 自定义资源发布到集群</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@k8s-master:~# kubectl apply -f custom-resources.yamlroot@k8s-master:~# kubectl get nodesNAME         STATUS   ROLES           AGE    VERSIONk8s-master   Ready    control-plane   173m   v1.32.5root@k8s-master:~# kubectl get pod -ANAMESPACE          NAME                                       READY   STATUS    RESTARTS   AGEcalico-apiserver   calico-apiserver-6499c768c8-wvrnt          1/1     Running   0          60scalico-apiserver   calico-apiserver-6499c768c8-zmvh6          1/1     Running   0          60scalico-system      calico-kube-controllers-85fb6564b7-gtsfr   1/1     Running   0          60scalico-system      calico-node-4mqfj                          1/1     Running   0          60scalico-system      calico-typha-65d47d7478-ttzx6              1/1     Running   0          60scalico-system      csi-node-driver-7j8pf                      2/2     Running   0          60skube-system        coredns-76fccbbb6b-l7jq9                   1/1     Running   0          172mkube-system        coredns-76fccbbb6b-nd68g                   1/1     Running   0          172mkube-system        etcd-k8s-master                            1/1     Running   0          172mkube-system        kube-apiserver-k8s-master                  1/1     Running   0          172mkube-system        kube-controller-manager-k8s-master         1/1     Running   0          172mkube-system        kube-proxy-mcwv7                           1/1     Running   0          172mkube-system        kube-scheduler-k8s-master                  1/1     Running   0          172mtigera-operator    tigera-operator-75b4cd596c-9hjml           1/1     Running   0          16m<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="7-3-11-加入Worker节点"><a href="#7-3-11-加入Worker节点" class="headerlink" title="7.3.11 加入Worker节点"></a>7.3.11 加入Worker节点</h3><p>  加入节点操作需在所有的worker节点完成，这里要注意，Worker节点需要完成以下先决条件才能执行kubeadm join</p><p>   1.Docker、CRI-Docker 部署</p><p>   2.Swap分区关闭</p><p>   3.iptables桥接流量的允许</p><p>   4.安装kubeadm等软件</p><p>   5.集成CRI-Docker</p><p>   6.所有节点的/etc/hosts中互相添加对方的解析</p><p>  如果时间长忘记了join参数，可以在master节点上用以下方法重新生成</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@k8s-master:~# kubeadm token create --print-join-commandkubeadm join 192.168.8.3:6443 --token 5mffg7.lq7ujh6vot0jzrci --discovery-token-ca-cert-hash sha256:c2546a856290440a8ccaf9223c14fd1c2098ac74f4a584acf5f3c5a373005207<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>  如果有多个CRI对象，在worker节点上执行以下命令加入节点时，指定CRI对象，案例如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@k8s-worker1:~# kubeadm token create --print-join-commandkubeadm join 192.168.8.3:6443 --token 5mffg7.lq7ujh6vot0jzrci --discovery-token-ca-cert-hash sha256:c2546a856290440a8ccaf9223c14fd1c2098ac74f4a584acf5f3c5a373005207failed to load admin kubeconfig: open /root/.kube/config: no such file or directoryTo see the stack trace of this error execute with --v=5 or higherfound multiple CRI endpoints on the host. Please define which one do you wish to use by setting the 'criSocket' field in the kubeadm configuration file: unix:///var/run/containerd/containerd.sock, unix:///var/run/cri-dockerd.sockTo see the stack trace of this error execute with --v=5 or higher# 加入两个节点1.节点worker1root@k8s-worker1:~# kubeadm join 192.168.8.3:6443 --token 5mffg7.lq7ujh6vot0jzrci --discovery-token-ca-cert-hash sha256:c2546a856290440a8ccaf9223c14fd1c2098ac74f4a584acf5f3c5a373005207 --cri-socket=unix:///var/run/cri-dockerd.sock2.节点worker2root@k8s-worker2:~#  kubeadm join 192.168.8.3:6443 --token 5mffg7.lq7ujh6vot0jzrci --discovery-token-ca-cert-hash sha256:c2546a856290440a8ccaf9223c14fd1c2098ac74f4a584acf5f3c5a373005207 --cri-socket=unix:///var/run/cri-dockerd.sock3.查看各节点状态root@k8s-master:~# kubectl get nodesNAME          STATUS   ROLES           AGE     VERSIONk8s-master    Ready    control-plane   3h28m   v1.32.5k8s-worker1   Ready    &lt;none&gt;          2m2s    v1.32.5k8s-worker2   Ready    &lt;none&gt;          2m2s    v1.32.54.查看pod信息root@k8s-master:~# kubectl get pod -ANAMESPACE          NAME                                       READY   STATUS    RESTARTS   AGEcalico-apiserver   calico-apiserver-6499c768c8-wvrnt          1/1     Running   0          37mcalico-apiserver   calico-apiserver-6499c768c8-zmvh6          1/1     Running   0          37mcalico-system      calico-kube-controllers-85fb6564b7-gtsfr   1/1     Running   0          37mcalico-system      calico-node-4mqfj                          1/1     Running   0          37mcalico-system      calico-node-rkd6k                          1/1     Running   0          3m37scalico-system      calico-node-vxflh                          1/1     Running   0          3m37scalico-system      calico-typha-65d47d7478-cmrtt              1/1     Running   0          3m28scalico-system      calico-typha-65d47d7478-ttzx6              1/1     Running   0          37mcalico-system      csi-node-driver-7j8pf                      2/2     Running   0          37mcalico-system      csi-node-driver-nhg4c                      2/2     Running   0          3m37scalico-system      csi-node-driver-z6p7p                      2/2     Running   0          3m37skube-system        coredns-76fccbbb6b-l7jq9                   1/1     Running   0          3h29mkube-system        coredns-76fccbbb6b-nd68g                   1/1     Running   0          3h29mkube-system        etcd-k8s-master                            1/1     Running   0          3h29mkube-system        kube-apiserver-k8s-master                  1/1     Running   0          3h29mkube-system        kube-controller-manager-k8s-master         1/1     Running   0          3h29mkube-system        kube-proxy-8n6x5                           1/1     Running   0          3m37skube-system        kube-proxy-mcwv7                           1/1     Running   0          3h29mkube-system        kube-proxy-xk4h4                           1/1     Running   0          3m37skube-system        kube-scheduler-k8s-master                  1/1     Running   0          3h29mtigera-operator    tigera-operator-75b4cd596c-9hjml           1/1     Running   0          52m<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  注意上描述命令最后的–cri-socket参数，在系统中部署了docker和cri-docker时，必须明确指明此参数，并将此参数指向我们的cri-docker，不然命令会报告有两个重复的CRI的错误</p><p>  在k8s-master机器上执行以下内容给节点打上角色标签，k8s-worker1和k8s-worker2分别打上了worker1和worker2的标签</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@k8s-master:~# kubectl label nodes k8s-worker1 node-role.kubernetes.io/worker1=node/k8s-worker1 labeledroot@k8s-master:~# kubectl label nodes k8s-worker2 node-role.kubernetes.io/worker2=node/k8s-worker2 labeledroot@k8s-master:~# kubectl get nodesNAME          STATUS   ROLES           AGE     VERSIONk8s-master    Ready    control-plane   3h33m   v1.32.5k8s-worker1   Ready    worker1         7m37s   v1.32.5k8s-worker2   Ready    worker2         7m37s   v1.32.5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="7-3-12-重置集群"><a href="#7-3-12-重置集群" class="headerlink" title="7.3.12 重置集群"></a>7.3.12 重置集群</h3><p>  如果在安装好集群的情况下，想重复练习初始化集群，或者包括初始化集群报错在内的任何原因，想重新初始化集群时，可以用下面的方法重置集群，重置后，集群就会被删除，可以用于重新部署，一般来说，这个命令仅用于k8s-master这个节点</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@k8s-master:~# kubeadm reset --cri-socket=unix:///var/run/cri-dockerd.sock# 根据提示，手工完成文件和规则的清理   清理后就可以重新部署集群了root@k8s-master:~# rm -rf /etc/cni/net.droot@k8s-master:~# iptables -Froot@k8s-master:~# rm -rf $HOME/.kube/config<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="7-3-13-标签和注解"><a href="#7-3-13-标签和注解" class="headerlink" title="7.3.13 标签和注解"></a>7.3.13 标签和注解</h3><p>  标签(Labels)和注解(Annotations)是附加到Kubernetes 对象(比如Pods)上的键值对</p><p>  标签旨在用于指定对用户有意义的标识属性，但不直接对核心系统有语义含义。可以用来选择对象和查找满足某些条件的对象集合</p><p>  注解不用于标识和选择对象。有效的注解键分为两部分： 可选的前缀和名称，以斜杠（/）分隔。 名称段是必需项，并且必须在63个字符以内</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@k8s-master:~# kubectl get node --show-labelsNAME          STATUS   ROLES           AGE     VERSION   LABELSk8s-master    Ready    control-plane   4h11m   v1.32.5   beta.kubernetes.io/arch=amd64,beta.kubernetes.io/os=linux,kubernetes.io/arch=amd64,kubernetes.io/hostname=k8s-master,kubernetes.io/os=linux,node-role.kubernetes.io/control-plane=,node.kubernetes.io/exclude-from-external-load-balancers=k8s-worker1   Ready    worker1         45m     v1.32.5   beta.kubernetes.io/arch=amd64,beta.kubernetes.io/os=linux,kubernetes.io/arch=amd64,kubernetes.io/hostname=k8s-worker1,kubernetes.io/os=linux,node-role.kubernetes.io/worker1=k8s-worker2   Ready    worker2         45m     v1.32.5   beta.kubernetes.io/arch=amd64,beta.kubernetes.io/os=linux,kubernetes.io/arch=amd64,kubernetes.io/hostname=k8s-worker2,kubernetes.io/os=linux,node-role.kubernetes.io/worker2=root@k8s-master:~# kubectl get nodesNAME          STATUS   ROLES           AGE     VERSIONk8s-master    Ready    control-plane   4h11m   v1.32.5k8s-worker1   Ready    worker1         45m     v1.32.5k8s-worker2   Ready    worker2         45m     v1.32.5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="8-Kubernetes的语法"><a href="#8-Kubernetes的语法" class="headerlink" title="8 Kubernetes的语法"></a>8 Kubernetes的语法</h1><p>  kubectl [command] [TYPE] [NAME] [flags]<br>  command：指定要对一个或多个资源执行的操作，例如create、get、describe、delete<br>  TYPE：指定资源类型，资源类型不区分大小写，可以指定单数、复数或缩写形式<br>  NAME：指定资源的名称，名称区分大小写<br>  fags：指定可选的参数。例如，可以使用-s或-server参数指定Kubernetes API服务器的地址和端口</p><p><img src="/images/k8s%E8%AF%AD%E6%B3%95%E7%A4%BA%E4%BE%8B.png"></p><h2 id="8-1-Yaml语法"><a href="#8-1-Yaml语法" class="headerlink" title="8.1 Yaml语法"></a>8.1 Yaml语法</h2><p><img src="/images/yaml%E8%AF%AD%E6%B3%95.png"></p><p>  注意每个层级之间的点（.），在YAML文件中，每个层级之间一般用两个空格来表</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@k8s-master:~# kubectl explain Pod.metadataKIND:       PodVERSION:    v1FIELD: metadata &lt;ObjectMeta&gt;...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="8-1-1-生成YAML文件框架"><a href="#8-1-1-生成YAML文件框架" class="headerlink" title="8.1.1 生成YAML文件框架"></a>8.1.1 生成YAML文件框架</h3><p>  通过在创建资源时加上—dry-run=client –o yaml来生成YAML文件框架，可以用重定向到文件的方式生成文件，只需要稍作修改即可</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@k8s-master:~# kubectl create deployment --image httpd deployname --dry-run=client -o yamlapiVersion: apps/v1kind: Deploymentmetadata:  creationTimestamp: null  labels:    app: deployname  name: deploynamespec:  replicas: 1  selector:    matchLabels:      app: deployname  strategy: {}  template:    metadata:      creationTimestamp: null      labels:        app: deployname    spec:      containers:      - image: httpd        name: httpd        resources: {}status: {}# 重定向到文件root@k8s-master:~# kubectl create deployment --image httpd deployname --dry-run=client -o yaml &gt; k8s.yml<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="8-1-2-apiVersion"><a href="#8-1-2-apiVersion" class="headerlink" title="8.1.2 apiVersion"></a>8.1.2 apiVersion</h3><p>Alpha:</p><p>  1.版本名称包含了alpha</p><p>  2.可能是有缺陷的。启用该功能可能会带来问题，默认是关闭的</p><p>  3.支持的功能可能在没有通知的情况下随时删除</p><p>  4.API的更改可能会带来兼容性问题，但是在后续的软件发布中不会有任何通知</p><p>  5.由于bugs风险的增加和缺乏长期的支持，推荐在短暂的集群测试中使用。</p><p>Beta:</p><p>  1.版本名称包含了beta</p><p>  2.代码已经测试过。启用该功能被 认为是安全的，功能默认已启用</p><p>  3.所有已支持的功能不会被删除，细节可能会发生变化</p><p>  4.对象的模式和/或语义可能会在后续的beta测试版或稳定版中以不兼容的方式进行更改。</p><p>  5.建议仅用于非业务关键型用途，因为后续版本中可能存在不兼容的更改。 如果有多个可以独立升级的集群，则可以放宽此限制</p><p>Stable：</p><p>  1.版本名称是 vX，其中X是整数</p><p>  2.功能的稳定版本将出现在许多后续版本的发行软件中</p><p>  3.有时候也会被称为GA或者毕业等词汇</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@k8s-master:~# kubectl api-resourcesNAME                 SHORTNAMES    APIVERSION                   NAMESPACED      KINDbindings                           v1                           true            Bindingcomponentstatuses    cs            v1                           false           ComponentStatusconfigmaps           cm            v1                           true            ConfigMapendpoints            ep            v1                           true            Endpointsevents               ev            v1                           true            Eventlimitranges          limits        v1                           true            LimitRangenamespaces           ns            v1                           false           Namespacenodes                no            v1                           false           Node...# 可以使用单数、复数、缩写root@k8s-master:~# kubectl get configmapsNAME               DATA   AGEkube-root-ca.crt   1      5h17mroot@k8s-master:~# kubectl get cmNAME               DATA   AGEkube-root-ca.crt   1      5h17mroot@k8s-master:~# kubectl get configmapNAME               DATA   AGEkube-root-ca.crt   1      5h17m<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="8-2-Namespace"><a href="#8-2-Namespace" class="headerlink" title="8.2 Namespace"></a>8.2 Namespace</h2><p>  Kubernetes支持多个虚拟集群，它们底层依赖于同一个物理集群。 这些虚拟集群被称为命名空间，它适用于存在很多跨多个团队或项目的用户的场景，命名空间为名称提供了一个范围</p><p>  资源的名称需要在名字空间内是唯一的，但不能跨名字空间</p><p>  名字空间不能相互嵌套，每个Kubernetes资源只能在一个名字空间中</p><p>  命名空间是在多个用户之间通过资源配额划分集群资源的一种方法</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@k8s-master:~# kubectl get namespaceNAME               STATUS   AGEcalico-apiserver   Active   3h18mcalico-system      Active   3h18mdefault            Active   6h10mkube-node-lease    Active   6h10mkube-public        Active   6h10mkube-system        Active   6h10mtigera-operator    Active   3h33mroot@k8s-master:~# kubectl get podNo resources found in default namespace.root@k8s-master:~# kubectl get pod -n kube-systemNAME                                 READY   STATUS    RESTARTS   AGEcoredns-76fccbbb6b-l7jq9             1/1     Running   0          6h14mcoredns-76fccbbb6b-nd68g             1/1     Running   0          6h14metcd-k8s-master                      1/1     Running   0          6h15mkube-apiserver-k8s-master            1/1     Running   0          6h14mkube-controller-manager-k8s-master   1/1     Running   0          6h15mkube-proxy-8n6x5                     1/1     Running   0          169mkube-proxy-mcwv7                     1/1     Running   0          6h14mkube-proxy-xk4h4                     1/1     Running   0          169mkube-scheduler-k8s-master            1/1     Running   0          6h15m<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="8-2-1-命令行创建"><a href="#8-2-1-命令行创建" class="headerlink" title="8.2.1 命令行创建"></a>8.2.1 命令行创建</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@k8s-master:~# kubectl create namespace luovipnamespace/luovip createdroot@k8s-master:~# kubectl get namespaceNAME               STATUS   AGEcalico-apiserver   Active   3h26mcalico-system      Active   3h26mdefault            Active   6h18mkube-node-lease    Active   6h18mkube-public        Active   6h18mkube-system        Active   6h18mluovip             Active   7stigera-operator    Active   3h41m<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="8-2-2-YAML文件创建"><a href="#8-2-2-YAML文件创建" class="headerlink" title="8.2.2 YAML文件创建"></a>8.2.2 YAML文件创建</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cat &gt; namespace.yml &lt;&lt;EOFapiVersion: v1kind: Namespacemetadata:  name: luovipyuEOFroot@k8s-master:~# kubectl create -f namespace.ymlnamespace/luovipyu createdroot@k8s-master:~# kubectl get namespaceNAME               STATUS   AGEcalico-apiserver   Active   3h33mcalico-system      Active   3h33mdefault            Active   6h25mkube-node-lease    Active   6h25mkube-public        Active   6h25mkube-system        Active   6h25mluovip             Active   6m54sluovipyu           Active   26stigera-operator    Active   3h48m<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="8-2-3-删除namespace"><a href="#8-2-3-删除namespace" class="headerlink" title="8.2.3 删除namespace"></a>8.2.3 删除namespace</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@k8s-master:~# kubectl delete namespace luovipyu   # 会删除名字空间下的所有内容namespace "luovipyu" deletedroot@k8s-master:~# kubectl create -f namespace.ymlnamespace/luovipyu createdroot@k8s-master:~# cat namespace.ymlapiVersion: v1kind: Namespacemetadata:  name: luovipyuroot@k8s-master:~# kubectl get namespaceNAME               STATUS   AGEcalico-apiserver   Active   3h39mcalico-system      Active   3h39mdefault            Active   6h30mkube-node-lease    Active   6h30mkube-public        Active   6h30mkube-system        Active   6h30mluovip             Active   12mluovipyu           Active   13stigera-operator    Active   3h54m<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="8-2-4-创建带有namespace属性的资源"><a href="#8-2-4-创建带有namespace属性的资源" class="headerlink" title="8.2.4 创建带有namespace属性的资源"></a>8.2.4 创建带有namespace属性的资源</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@k8s-master:~# kubectl run httpd --image=httpd --namespace=luovipyupod/httpd createdroot@k8s-master:~# kubectl get pod -n luovipyuNAME    READY   STATUS             RESTARTS   AGEhttpd   1/1     Running            0          18snginx   0/1     ImagePullBackOff   0          106s# 每次查询和创建资源都需要带–namespace=luovipyu挺麻烦，可以设置默认值root@k8s-master:~# kubectl config set-context --current --namespace=luovipyuContext "kubernetes-admin@kubernetes" modified.root@k8s-master:~# kubectl config view | grep namespace    namespace: luovipyuroot@k8s-master:~# kubectl get podNAME    READY   STATUS             RESTARTS   AGEhttpd   1/1     Running            0          3m3snginx   0/1     ImagePullBackOff   0          4m31s# 删除namespace会删除其下所有资源，但如果要删除已经切换为默认值的namespace时，可能会卡住，所以先把默认值切换为其他，然后再删除root@k8s-master:~# kubectl config set-context --current --namespace=defaultContext "kubernetes-admin@kubernetes" modified.root@k8s-master:~# kubectl delete namespaces luovip luovipyunamespace "luovip" deletednamespace "luovipyu" deletedroot@k8s-master:~# kubectl get namespaceNAME               STATUS   AGEcalico-apiserver   Active   3h49mcalico-system      Active   3h49mdefault            Active   6h41mkube-node-lease    Active   6h41mkube-public        Active   6h41mkube-system        Active   6h41mtigera-operator    Active   4h4m<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="8-3-CRD自定义资源"><a href="#8-3-CRD自定义资源" class="headerlink" title="8.3 CRD自定义资源"></a>8.3 CRD自定义资源</h2><p>  CRD（Custom Resource Definition，自定义资源定义）是Kubernetes提供的一种扩展机制，允许用户通过YAML文件定义自定义资源类型，并将其注册到Kubernetes API中，使其与内置资源（如Pod、 Deployment）一样被管理</p><p>  本质：CRD是对自定义资源的元数据描述，定义了资源的名称、结构、版本、作用域等<br>  作用：扩展Kubernetes API，支持用户自定义资源的管理和自动化操作</p><p>CRD核心字段：</p><table><thead><tr><th align="left">字段</th><th align="left">说明</th><th align="left">示例</th></tr></thead><tbody><tr><td align="left">apiVersion</td><td align="left">CRD的API版本，固定为apiextensions.k8s.io/v1</td><td align="left">apiVersion:apiextensions.k8s.io/v1</td></tr><tr><td align="left">kind</td><td align="left">资源类型，固定为CustomResourceDefinition</td><td align="left">kind: CustomResourceDefinition</td></tr><tr><td align="left">metadata</td><td align="left">元数据，如名称、命名空间等(名称需符合DNS子域名规则)</td><td align="left">name:crontabs.stable.example.com</td></tr><tr><td align="left">spec</td><td align="left">核心配置，包括 API组、版本、资源范围 (Namespaced/Cluster)、字段验证规则等</td><td align="left">group: stable.example.com</td></tr><tr><td align="left">versions</td><td align="left">支持的API版本列表，需指定至少一个存储版本( storage:true)</td><td align="left">version:[v1][@ref)</td></tr><tr><td align="left">names</td><td align="left">资源的复数形式、单数形式、简称等(如plural:crontabs)</td><td align="left">plural: crontabs</td></tr><tr><td align="left">scope</td><td align="left">资源作用域，Namespaced(命名空间级别)或Cluster(集群级别)</td><td align="left">scope: Namespaced</td></tr></tbody></table><h3 id="8-3-1-CRD介绍"><a href="#8-3-1-CRD介绍" class="headerlink" title="8.3.1 CRD介绍"></a>8.3.1 CRD介绍</h3><p>  K8S资源类型不止有namespace，还有很多，不过那都是系统自带的，现在我们来看看怎么自定义k8s中的资源</p><p>1.什么是CRD？</p><p>  CRD（Custom Resource Definition）是 Kubernetes 提供的一种机制，允许用户定义自己的资源类型</p><p>  这些自定义资源可以像 Kubernetes 原生资源（如 Pod、Service、Deployment 等）一样被管理。<br>2.为什么需要CRD？</p><p>  扩展 Kubernetes API：Kubernetes 的原生资源可能无法满足所有用户的需求。CRD 允许用户定义自己的资源类型，从而扩展 Kubernetes 的功能。</p><p>  管理复杂应用：有些应用可能需要管理一些特定的资源，这些资源不属于Kubernetes原生支持的范围。通过CRD可以将这些资源纳入 Kubernetes的管理范围，实现统一的资源管理</p><p>3.CRD的作用</p><p>  定义资源结构：CRD 允许你定义资源的结构，包括其字段和数据类型</p><p>  管理资源生命周期：Kubernetes 将为你管理这些自定义资源的生命周期，包括创建、更新、删除等操作</p><p>  集成 Kubernetes 生态系统：CRD 可以与 Kubernetes 的其他组件（如控制器、操作符等）集成，实现更复杂的业务逻辑</p><p>  在Kubernetes 的自定义资源定义（CRD）中，CRD 本身只定义了资源的结构和 API，但它不会直接执行任何创建、更新或删除操作。这些操作需要通过一个控制器（Controller）来实现。控制器是一个独立的程序，它监听 CRD 的变化，并根据这些变化执行实际的操作</p><h3 id="8-3-2-查询CRD以及API资源"><a href="#8-3-2-查询CRD以及API资源" class="headerlink" title="8.3.2 查询CRD以及API资源"></a>8.3.2 查询CRD以及API资源</h3><p>  1.先看看系统中的api资源都有哪些，然后创建一个</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@k8s-master:~# kubectl api-resourcesNAME                 SHORTNAMES    APIVERSION                   NAMESPACED      KINDbindings                           v1                           true            Bindingcomponentstatuses    cs            v1                           false           ComponentStatusconfigmaps           cm            v1                           true            ConfigMapendpoints            ep            v1                           true            Endpointsevents               ev            v1                           true            Eventlimitranges          limits        v1                           true            LimitRangenamespaces           ns            v1                           false           Namespacenodes                no            v1                           false           Node...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  2.查看现在都有哪些自定义资源</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 以下资源不属于K8s，但是k8s是有的root@k8s-master:~# kubectl get crdNAME                                                  CREATED ATadminnetworkpolicies.policy.networking.k8s.io         2025-05-17T03:05:26Zapiservers.operator.tigera.io                         2025-05-17T03:05:26Zbgpconfigurations.crd.projectcalico.org               2025-05-17T03:05:26Zbgpfilters.crd.projectcalico.org                      2025-05-17T03:05:26Zbgppeers.crd.projectcalico.org                        2025-05-17T03:05:26Zblockaffinities.crd.projectcalico.org                 2025-05-17T03:05:26Zcaliconodestatuses.crd.projectcalico.org              2025-05-17T03:05:26Zclusterinformations.crd.projectcalico.org             2025-05-17T03:05:26Zfelixconfigurations.crd.projectcalico.org             2025-05-17T03:05:26Zglobalnetworkpolicies.crd.projectcalico.org           2025-05-17T03:05:26Zglobalnetworksets.crd.projectcalico.org               2025-05-17T03:05:26Zhostendpoints.crd.projectcalico.org                   2025-05-17T03:05:26Zimagesets.operator.tigera.io                          2025-05-17T03:05:26Zinstallations.operator.tigera.io                      2025-05-17T03:05:26Zipamblocks.crd.projectcalico.org                      2025-05-17T03:05:26Zipamconfigs.crd.projectcalico.org                     2025-05-17T03:05:26Zipamhandles.crd.projectcalico.org                     2025-05-17T03:05:26Zippools.crd.projectcalico.org                         2025-05-17T03:05:26Zipreservations.crd.projectcalico.org                  2025-05-17T03:05:26Zkubecontrollersconfigurations.crd.projectcalico.org   2025-05-17T03:05:26Znetworkpolicies.crd.projectcalico.org                 2025-05-17T03:05:26Znetworksets.crd.projectcalico.org                     2025-05-17T03:05:26Ztiers.crd.projectcalico.org                           2025-05-17T03:05:26Ztigerastatuses.operator.tigera.io                     2025-05-17T03:05:26Z<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="8-3-3-创建CRD以及API资源"><a href="#8-3-3-创建CRD以及API资源" class="headerlink" title="8.3.3 创建CRD以及API资源"></a>8.3.3 创建CRD以及API资源</h3><p>  1.创建一个自己的crd，crd将注册为api资源</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cat &gt; crd.yaml &lt;&lt;-'EOF'apiVersion: apiextensions.k8s.io/v1kind: CustomResourceDefinitionmetadata:  # 名字必需与下面的 spec 字段匹配，并且格式为 '&lt;名称的复数形式&gt;.&lt;组名&gt;'  name: crontabs.stable.example.comspec:  # 组名称，用于 REST API：/apis/&lt;组&gt;/&lt;版本&gt;  group: stable.example.com  # 列举此 CustomResourceDefinition 所支持的版本  versions:    - name: v1      # 每个版本都可以通过 served 标志来独立启用或禁止      served: true      # 其中一个且只有一个版本必需被标记为存储版本      storage: true      schema:        openAPIV3Schema:          type: object          properties:            spec:              type: object              properties:                cronSpec:                  type: string                image:                  type: string                replicas:                  type: integer  # 可以是 Namespaced 或 Cluster  scope: Namespaced  names:    # 名称的复数形式，用于 URL：/apis/&lt;组&gt;/&lt;版本&gt;/&lt;名称的复数形式&gt;    plural: crontabs    # 名称的单数形式，作为命令行使用时和显示时的别名    singular: crontab    # kind 通常是单数形式的驼峰命名（CamelCased）形式。你的资源清单会使用这一形式。    kind: CronTab    # shortNames 允许你在命令行使用较短的字符串来匹配资源    shortNames:    - ctEOFroot@k8s-master:~# kubectl apply -f crd.yamlcustomresourcedefinition.apiextensions.k8s.io/crontabs.stable.example.com created<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  2.再看就会有自己的crd资源和api资源了</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@k8s-master:~# kubectl get crdNAME                                                  CREATED AT...crontabs.stable.example.com                           2025-05-17T06:16:04Z...root@k8s-master:~# kubectl api-resources | grep crontabsNAME          SHORTNAMES                      APIVERSION                          NAMESPACED   KINDcrontabs      ct                              stable.example.com/v1               true         CronTabroot@k8s-master:~# kubectl describe crd crontabs.stable.example.com<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="8-3-4-查询API资源结构与参数"><a href="#8-3-4-查询API资源结构与参数" class="headerlink" title="8.3.4 查询API资源结构与参数"></a>8.3.4 查询API资源结构与参数</h3><p>  既然已经注册为api资源，来看看能否explain字段？</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@k8s-master:~# kubectl explain crontabsGROUP:      stable.example.comKIND:       CronTabVERSION:    v1DESCRIPTION:    &lt;empty&gt;FIELDS:  apiVersion    &lt;string&gt;  kind  &lt;string&gt;  metadata      &lt;ObjectMeta&gt;  spec  &lt;Object&gt;...# 查看有哪些specroot@k8s-master:~# kubectl explain crontabs.specGROUP:      stable.example.comKIND:       CronTabVERSION:    v1FIELD: spec &lt;Object&gt;DESCRIPTION:    &lt;empty&gt;FIELDS:  cronSpec      &lt;string&gt;    &lt;no description&gt;  image &lt;string&gt;    &lt;no description&gt;  replicas      &lt;integer&gt;    &lt;no description&gt;# 一切正常，看来已经创建了自定义资源，接下来就是等开发人员通过编程等方式创建operator等控制器，来使用我们的资源了<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="9-Pod"><a href="#9-Pod" class="headerlink" title="9 Pod"></a>9 Pod</h1><h2 id="9-1-关于pod"><a href="#9-1-关于pod" class="headerlink" title="9.1 关于pod"></a>9.1 关于pod</h2><p>  Pod由一个或多个紧密耦合的容器组成</p><p>  它们之间共享网络、存储等资源</p><p>  pod是Kubernetes中最小的工作单元</p><p>  Pod中的容器会一起启动和停止</p><h2 id="9-2-Pod生命周期"><a href="#9-2-Pod生命周期" class="headerlink" title="9.2 Pod生命周期"></a>9.2 Pod生命周期</h2><p>  Pod遵循一个预定义的生命周期，起始于Pending阶段，如果至少其中有一个主要容器正常启动，则进入Running，之后取决于Pod中是否有容器以失败状态结束而进入Succeeded或者Failed阶段。但有时集群节点之间出现网络故障，无法获取Pod状态时，就会出现Unknown状态</p><h2 id="9-3-创建Pod"><a href="#9-3-创建Pod" class="headerlink" title="9.3 创建Pod"></a>9.3 创建Pod</h2><p>  1.一个Pod中只有一个业务容器</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 1.yml文件创建podcat &gt; pod.yml &lt;&lt;EOFapiVersion: v1kind: Podmetadata:  name: luovippodspec:  containers:  - name: hello    image: httpd    imagePullPolicy: IfNotPresent    command: ['sh', '-c', 'echo "Hello, China!" &amp;&amp; sleep 3600']  restartPolicy: OnFailureEOFroot@k8s-master:~# kubectl create -f pod.ymlpod/luovippod createdroot@k8s-master:~# kubectl get podNAME        READY   STATUS    RESTARTS   AGEluovippod   1/1     Running   0          5sroot@k8s-master:~# kubectl logs luovippodHello, China!root@k8s-master:~# kubectl delete pod luovippod    删除pod# 2.命令行创建podroot@k8s-master:~# kubectl run luoyupod --image=nginx --port=80pod/luoyupod createdroot@k8s-master:~# kubectl get podNAME        READY   STATUS    RESTARTS   AGEluovippod   1/1     Running   0          7m56sluoyupod    1/1     Running   0          3m38sroot@k8s-master:~# kubectl get pod -o wideNAME        READY   STATUS    RESTARTS   AGE     IP              NODE          NOMINATED NODE   READINESS GATESluovippod   1/1     Running   0          8m6s    172.16.194.71   k8s-worker1   &lt;none&gt;           &lt;none&gt;luoyupod    1/1     Running   0          3m48s   172.16.194.72   k8s-worker1   &lt;none&gt;           &lt;none&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  2.一个Pod中有多个业务容器</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cat &gt; multicontainer.yml &lt;&lt;EOFapiVersion: v1kind: Podmetadata:  name: podspec:  containers:  - name: nginx    image: nginx    imagePullPolicy: IfNotPresent    command: ['sh', '-c', 'echo "Hello, luoyu!" &amp;&amp; sleep 3600']  - name: httpd    image: httpd    imagePullPolicy: IfNotPresent    ports:      - name: web        containerPort: 80  restartPolicy: OnFailureEOFroot@k8s-master:~# kubectl create -f multicontainer.ymlpod/pod createdroot@k8s-master:~# kubectl get podNAME        READY   STATUS    RESTARTS   AGEluovippod   1/1     Running   0          18mluoyupod    1/1     Running   0          14mpod         2/2     Running   0          9sroot@k8s-master:~# kubectl get -f multicontainer.yml -o wideNAME   READY   STATUS    RESTARTS   AGE   IP             NODE          NOMINATED NODE   READINESS GATESpod    2/2     Running   0          68s   172.16.126.3   k8s-worker2   &lt;none&gt;           &lt;none&gt;root@k8s-master:~# curl 172.16.126.3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="9-4-修改Pod"><a href="#9-4-修改Pod" class="headerlink" title="9.4 修改Pod"></a>9.4 修改Pod</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 直接修改yaml文件，然后执行以下命令kubectl apply -f pod.yml# 编辑Etcd数据kubectl edit pod luovippod# patch参数kubectl get pod luovippod -o jsonkubectl get pod luovippod -o json | grep cnlxh注明：工作中的修改pod一般时k8s会创建新的pod并删除旧的pod<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="9-5-进入pod中的容器"><a href="#9-5-进入pod中的容器" class="headerlink" title="9.5 进入pod中的容器"></a>9.5 进入pod中的容器</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@k8s-master:~# kubectl get pod -o wideNAME        READY   STATUS    RESTARTS   AGE   IP              NODE          NOMINATED NODE   READINESS GATESluovippod   1/1     Running   0          37m   172.16.194.71   k8s-worker1   &lt;none&gt;           &lt;none&gt;luoyupod    1/1     Running   0          33m   172.16.194.72   k8s-worker1   &lt;none&gt;           &lt;none&gt;pod         2/2     Running   0          19m   172.16.126.3    k8s-worker2   &lt;none&gt;           &lt;none&gt;root@k8s-master:~# kubectl exec -it pod -c httpd  -- /bin/bashroot@pod:/usr/local/apache2# echo MyCity is ChengDu! &gt; htdocs/index.htmlroot@pod:/usr/local/apache2# exitexitroot@k8s-master:~# curl http://172.16.126.3MyCity is ChengDu!#参数说明： 1、-c 参数可以指定需要进入pod中的哪个容器 2、-- 是K8S命令和预期容器内部执行命令的连接符 3、/bin/sh是指进入容器中执行什么命令  4、退出执行exit<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="9-6-Init类型容器"><a href="#9-6-Init类型容器" class="headerlink" title="9.6 Init类型容器"></a>9.6 Init类型容器</h2><p>  Init容器是一种特殊容器，在Pod内的应用容器启动之前运行，如果Pod的Init容器失败，kubelet会不断地重启该 Init 容器直到该容器成功为止。 然而，如果 Pod 对应的 restartPolicy 值为 “Never”，并且 Pod的 Init 容器失败， 则 Kubernetes 会将整个 Pod 状态设置为失败</p><p>  Init容器与普通的容器非常像，除了如下两点：</p><p>   1.正常情况下，它们最终都会处于completed状态</p><p>   2.每个都必须在下一个启动之前成功完成</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 根据安排，myapp-container的容器将等待两个init结束之后才会启动，也就是40秒之后才会启动cat &gt; init.yml &lt;&lt;EOFapiVersion: v1kind: Podmetadata:  name: initpd  labels:    app: myappspec:  containers:  - name: myapp-container    image: busybox    imagePullPolicy: IfNotPresent    command: ['sh', '-c', 'echo The app is running! &amp;&amp; sleep 3600']  initContainers:  - name: init-myservice    image: busybox    imagePullPolicy: IfNotPresent    command: ['sh', '-c', "sleep 20"]  - name: init-mydb    image: busybox    imagePullPolicy: IfNotPresent    command: ['sh', '-c', "sleep 20"]EOFroot@k8s-master:~# kubectl create -f init.ymlpod/initpd created# -w参数可以实时查看pod的状态变化root@k8s-master:~# kubectl get -f init.yml -wNAME     READY   STATUS     RESTARTS   AGEinitpd   0/1     Init:0/2   0          19sinitpd   0/1     Init:1/2   0          21sinitpd   0/1     Init:1/2   0          22sinitpd   0/1     PodInitializing   0          42sinitpd   1/1     Running           0          43sroot@k8s-master:~# kubectl get pod -wNAME        READY   STATUS     RESTARTS   AGEinitpd      0/1     Init:1/2   0          34sluovippod   1/1     Running    0          56mluoyupod    1/1     Running    0          51mpod         2/2     Running    0          37mroot@k8s-master:~# kubectl get podsNAME        READY   STATUS    RESTARTS   AGEinitpd      1/1     Running   0          104sluovippod   1/1     Running   0          57mluoyupod    1/1     Running   0          52mpod         2/2     Running   0          39m<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="9-7-Sidecar类型容器"><a href="#9-7-Sidecar类型容器" class="headerlink" title="9.7 Sidecar类型容器"></a>9.7 Sidecar类型容器</h2><p>  一般来讲，Sidecar容器可以：</p><p>   1.日志代理/转发，例如 fluentd</p><p>   2.Service Mesh，比如 Istio，Linkerd</p><p>   3.代理，比如 Docker Ambassador</p><p>   4.探活：检查某些组件是不是正常工作</p><p>   5.其他辅助性的工作，比如拷贝文件，下载文件等</p><p><img src="/images/Sidecar.png"></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 两个容器挂载了同一个目录，一个容器负责写入数据，一个容器负责对外展示cat &gt; sidecar.yml &lt;&lt;EOFapiVersion: v1kind: Podmetadata:  name: sidecarpodspec:  containers:  - name: httpd    image: httpd    imagePullPolicy: IfNotPresent    volumeMounts:      - mountPath: /usr/local/apache2/htdocs/        name: luoyuvolume  - name: busybox    image: busybox    imagePullPolicy: IfNotPresent    command: ['sh', '-c', 'echo "Hello sidecar" &gt; /usr/local/apache2/htdocs/index.html &amp;&amp; sleep 3600']    volumeMounts:      - mountPath: /usr/local/apache2/htdocs/        name: luoyuvolume  restartPolicy: OnFailure  volumes:    - name: luoyuvolume      emptyDir: {}EOFroot@k8s-master:~# kubectl create -f sidecar.ymlpod/sidecarpod createdroot@k8s-master:~# kubectl get -f sidecar.yml -o wideNAME         READY   STATUS    RESTARTS   AGE   IP              NODE       NOMINATED NODE   READINESS GATESsidecarpod   2/2     Running   0          9s    172.16.194.74   k8s-worker1   &lt;none&gt;           &lt;none&gt;root@k8s-master:~# curl http://172.16.194.74Hello sidecar<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="9-8-静态Pod"><a href="#9-8-静态Pod" class="headerlink" title="9.8 静态Pod"></a>9.8 静态Pod</h2><p>  静态 Pod 在指定的节点上由 kubelet 守护进程直接管理，不需要 API 服务器监管。 与由控制面管理的Pod（例如，Deployment） 不同；kubelet 监视每个静态 Pod（在它崩溃之后重新启动）</p><p>  静态 Pod 永远都会绑定到一个指定节点上的 Kubelet</p><p>  kubelet 会尝试通过 Kubernetes API 服务器为每个静态 Pod 自动创建一个 mirror Pod。 这意味着节点上运行的静态 Pod 对 API 服务来说是可见的，但是不能通过 API 服务器来控制。 Pod 名称将把以连字符开头的节点主机名作为后缀</p><p>  运行中的 kubelet 会定期扫描配置的目录中的变化， 并且根据文件中出现/消失的 Pod 来添加/删除Pod</p><p>1.查找静态pod的编写路径</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@k8s-master:~# systemctl status kubelet...    Drop-In: /usr/lib/systemd/system/kubelet.service.d             └─10-kubeadm.conf...root@k8s-master:~# tail /usr/lib/systemd/system/kubelet.service.d/10-kubeadm.conf[Service]...Environment="KUBELET_CONFIG_ARGS=--config=/var/lib/kubelet/config.yaml"...root@k8s-master:~# grep -i static /var/lib/kubelet/config.yamlstaticPodPath: /etc/kubernetes/manifests<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2.编写静态pod</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cat &gt; static.yml &lt;&lt;EOFapiVersion: v1kind: Podmetadata:  name: staticpodspec:  containers:  - name: hello    image: busybox    imagePullPolicy: IfNotPresent    command: ['sh', '-c', 'echo "Hello, lixiaohui!" &amp;&amp; sleep 3600']  restartPolicy: OnFailureEOF# 把这个yaml文件复制到/etc/kubernetes/manifests，然后观察pod列表，然后把yaml文件移出此文件夹，再观察pod列表root@k8s-master:~# cp static.yml /etc/kubernetes/manifests/root@k8s-master:~# kubectl get podNAME                   READY   STATUS      RESTARTS   AGEinitpd                 1/1     Running     0          40mluovippod              0/1     Completed   0          95mluoyupod               1/1     Running     0          91mpod                    1/2     NotReady    0          77msidecarpod             2/2     Running     0          31mstaticpod-k8s-master   1/1     Running     0          12s# 删除/etc/kubernetes/manifests文件中的yml文件，再观察pod列表root@k8s-master:~# rm -rf /etc/kubernetes/manifests/static.ymlroot@k8s-master:~# kubectl get podNAME         READY   STATUS      RESTARTS   AGEinitpd       1/1     Running     0          41mluovippod    0/1     Completed   0          97mluoyupod     1/1     Running     0          92mpod          1/2     NotReady    0          78msidecarpod   2/2     Running     0          32m# 维持集群运行的文件如下：root@k8s-master:/etc/kubernetes/manifests# lsetcd.yaml  kube-apiserver.yaml  kube-controller-manager.yaml  kube-scheduler.yaml  static.yml<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="9-9-Pod删除"><a href="#9-9-Pod删除" class="headerlink" title="9.9 Pod删除"></a>9.9 Pod删除</h2><p>  kubectl delete pod –all会删除所有pod</p><p>  kubectl delete pod pod名称—删除指定的pod</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@k8s-master:~# kubectl get podsNAME                   READY   STATUS    RESTARTS   AGEinitpd                 1/1     Running   0          13mluovippod              1/1     Running   0          9m23sluoyupod               1/1     Running   0          169mpod                    2/2     Running   0          7m51ssidecarpod             2/2     Running   0          27sstaticpod-k8s-master   1/1     Running   0          2sroot@k8s-master:~# kubectl delete pod luovippodroot@k8s-master:~# kubectl delete pod -allroot@k8s-master:~# kubectl get podsNo resources found in default namespace.root@k8s-master:~# kubectl get pod -n kube-systemNAME                                 READY   STATUS    RESTARTS   AGEcoredns-76fccbbb6b-l7jq9             1/1     Running   0          35hcoredns-76fccbbb6b-nd68g             1/1     Running   0          35hetcd-k8s-master                      1/1     Running   0          35hkube-apiserver-k8s-master            1/1     Running   0          35hkube-controller-manager-k8s-master   1/1     Running   0          35hkube-proxy-8n6x5                     1/1     Running   0          32hkube-proxy-mcwv7                     1/1     Running   0          35hkube-proxy-xk4h4                     1/1     Running   0          32hkube-scheduler-k8s-master            1/1     Running   0          35h<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="10-Kubernetes控制器"><a href="#10-Kubernetes控制器" class="headerlink" title="10 Kubernetes控制器"></a>10 Kubernetes控制器</h1><h2 id="10-1-什么是控制器"><a href="#10-1-什么是控制器" class="headerlink" title="10.1 什么是控制器"></a>10.1 什么是控制器</h2><p>  当你设置了温度，告诉了空调遥控器你的期望状态（Desired State）。 房间的实际温度是当前状态（Current State）。 通过对遥控器的开关控制，遥控器让其当前状态接近期望状态<br>  在 Kubernetes 中，控制器通过监控集群的公共状态，并致力于将当前状态转变为期望的状态</p><p>  作为设计原则之一，Kubernetes 使用了很多控制器，每个控制器管理集群状态的一个特定方面。 最常见的一个特定的控制器使用一种类型的资源作为它的期望状态， 控制器管理控制另外一种类型的资源向它的期望状态演化</p><h2 id="10-2-Replica-Set概念"><a href="#10-2-Replica-Set概念" class="headerlink" title="10.2 Replica Set概念"></a>10.2 Replica Set概念</h2><p>  ReplicationController确保在任何时候都有特定数量的Pod副本处于运行状态。 换句话说，ReplicationController 确保一个 Pod 或一组同类的 Pod 总是可用的<br>  ReplicaSet的目的是维护一组在任何时候都处于运行状态的 Pod 副本的稳定集合。 因此，它通常用来保证给定数量的、完全相同的 Pod 的可用性。</p><p>说明： 现在推荐使用配置ReplicaSet的Deployment来建立副本管理机制</p><h2 id="10-3-Replica-Set-工作原理"><a href="#10-3-Replica-Set-工作原理" class="headerlink" title="10.3 Replica Set 工作原理"></a>10.3 Replica Set 工作原理</h2><p>  RepicaSet是通过一组字段来定义的，包括一个用来识别可获得的 Pod 的集合的选择算符、一个用来标明应该维护的副本个数的数值、一个用来指定应该创建新 Pod 以满足副本个数条件时要使用的 Pod 模板等等。 每个 ReplicaSet 都通过根据需要创建和 删除 Pod 以使得副本个数达到期望值， 进而实现其存在价值。当 ReplicaSet 需要创建新的 Pod 时，会使用所提供的 Pod 模板</p><p>  1.ReplicaSet也需要apiVersion、kind和metadata字段</p><p>  2.Pod 选择算符：.spec.selector 字段是一个标签选择算符。在 ReplicaSet 中，.spec.template.metadata.labels 的值必须与 spec.selector 值 相匹配，否则该配置会被API拒绝</p><p>  3.可以通过设置 .spec.replicas 来指定要同时运行的 Pod个数。 ReplicaSet 创建、删除 Pods 以与此值匹配</p><h2 id="10-4-ReplicaSet使用"><a href="#10-4-ReplicaSet使用" class="headerlink" title="10.4 ReplicaSet使用"></a>10.4 ReplicaSet使用</h2><p>  使用nginx镜像创建具有3个pod的RS,并分配合适的标签</p><h3 id="10-4-1-创建yml文件"><a href="#10-4-1-创建yml文件" class="headerlink" title="10.4.1 创建yml文件"></a>10.4.1 创建yml文件</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cat &gt; rs.yml &lt;&lt;EOFapiVersion: apps/v1kind: ReplicaSetmetadata:  name: nginxrstest  labels:    app: nginxrstestspec:  replicas: 3  selector:    matchLabels:      app: nginxrstest  template:    metadata:      labels:        app: nginxrstest    spec:      containers:      - name: nginx        image: nginx        imagePullPolicy: IfNotPresent        ports:          - name: http            containerPort: 80        imagePullPolicy: IfNotPresentEOF<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="10-4-2-操作ReplicaSet"><a href="#10-4-2-操作ReplicaSet" class="headerlink" title="10.4.2 操作ReplicaSet"></a>10.4.2 操作ReplicaSet</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@k8s-master:~# kubectl create -f rs.ymlroot@k8s-master:~# kubectl get rsNAME          DESIRED   CURRENT   READY   AGEnginxrstest   3         3         3       3m45sroot@k8s-master:~# kubectl get pod --show-labelsNAME                READY   STATUS    RESTARTS   AGE    LABELSnginxrstest-5bvpr   1/1     Running   0          7m1s   app=nginxrstestnginxrstest-9d86s   1/1     Running   0          7m1s   app=nginxrstestnginxrstest-k79cw   1/1     Running   0          7m1s   app=nginxrstest# 被动高可用root@k8s-master:~# kubectl delete pod --allpod "nginxrstest-5bvpr" deletedpod "nginxrstest-9d86s" deletedpod "nginxrstest-k79cw" deletedroot@k8s-master:~# kubectl get replicasets.apps,podsNAME                          DESIRED   CURRENT   READY   AGEreplicaset.apps/nginxrstest   3         3         3       12mNAME                    READY   STATUS    RESTARTS   AGEpod/nginxrstest-86dd7   1/1     Running   0          3m6spod/nginxrstest-bbzxd   1/1     Running   0          3m6spod/nginxrstest-ndgxg   1/1     Running   0          3m6s# 扩容root@k8s-master:~# kubectl scale replicaset nginxrstest --replicas 4replicaset.apps/nginxrstest scaledroot@k8s-master:~# kubectl get replicasets.apps nginxrstestNAME          DESIRED   CURRENT   READY   AGEnginxrstest   4         4         4       16mroot@k8s-master:~# kubectl get replicasets.apps,pods -o wide# 删除root@k8s-master:~# kubectl delete replicasets.apps nginxrstestreplicaset.apps "nginxrstest" deletedroot@k8s-master:~# kubectl get podNo resources found in default namespace.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="10-5-Deployment"><a href="#10-5-Deployment" class="headerlink" title="10.5 Deployment"></a>10.5 Deployment</h2><p>  ReplicaSet确保任何时间都有指定数量的Pod副本在运行。 然而，Deployment是一个更高级的概念，它管理ReplicaSet，并向Pod提供声明式的更新以及许多其他有用的功能。 因此，建议使用 Deployment 而不是直接使用 ReplicaSet，除非需要自定义更新业务流程或根本不需要更新<br>  这实际上意味着，可能永远不需要操作ReplicaSet对象：而是使用Deployment，并在spec部分定义应用</p><p><img src="/images/Deployment.png"></p><h3 id="10-5-1-创建yml文件"><a href="#10-5-1-创建yml文件" class="headerlink" title="10.5.1 创建yml文件"></a>10.5.1 创建yml文件</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cat &gt; deployment.yml &lt;&lt;EOFapiVersion: apps/v1kind: Deploymentmetadata:  name: nginx-deployment  labels:    app: nginxspec:  replicas: 3  selector:    matchLabels:      app: nginx  template:    metadata:      labels:        app: nginx    spec:      containers:      - name: nginx        image: nginx:1.16.1        imagePullPolicy: IfNotPresent        ports:        - containerPort: 80EOF<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="10-5-2-创建Deployment"><a href="#10-5-2-创建Deployment" class="headerlink" title="10.5.2 创建Deployment"></a>10.5.2 创建Deployment</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 使用nginx镜像创建具有3个副本的Deployment，并分配合适的属性# 发现deployment管理了一个RS，而RS又实现了3个podroot@k8s-master:~# kubectl create -f deployment.ymldeployment.apps/nginx-deployment createdroot@k8s-master:~# kubectl get deployment.appsNAME               READY   UP-TO-DATE   AVAILABLE   AGEnginx-deployment   3/3     3            3           20s# kubectl get pods --show-labels(可选)  Deployment控制器将pod-template-hash标签添加到Deployment所创建或收留的每个ReplicaSet，此标签可确保Deployment的子 ReplicaSets不重叠root@k8s-master:~# kubectl get pods --show-labelsNAME                               READY   STATUS    RESTARTS   AGE   LABELSnginx-deployment-8d94c585f-ngm9d   1/1     Running   0          51s   app=nginx,pod-template-hash=8d94c585fnginx-deployment-8d94c585f-wf4mc   1/1     Running   0          51s   app=nginx,pod-template-hash=8d94c585fnginx-deployment-8d94c585f-wjzkw   1/1     Running   0          51s   app=nginx,pod-template-hash=8d94c585froot@k8s-master:~# kubectl get deployments.apps,replicasets.apps,pods -l app=nginxNAME                               READY   UP-TO-DATE   AVAILABLE   AGEdeployment.apps/nginx-deployment   3/3     3            3           2m20sNAME                                         DESIRED   CURRENT   READY   AGEreplicaset.apps/nginx-deployment-8d94c585f   3         3         3       2m20sNAME                                   READY   STATUS    RESTARTS   AGEpod/nginx-deployment-8d94c585f-ngm9d   1/1     Running   0          2m20spod/nginx-deployment-8d94c585f-wf4mc   1/1     Running   0          2m20spod/nginx-deployment-8d94c585f-wjzkw   1/1     Running   0          2m20s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="10-5-3-更新Deployment"><a href="#10-5-3-更新Deployment" class="headerlink" title="10.5.3 更新Deployment"></a>10.5.3 更新Deployment</h3><p>  1.将deployment的镜像更改一次</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># Deployment的更新策略root@k8s-master:~# kubectl get deployments.apps nginx-deployment -o yamlapiVersion: apps/v1kind: Deployment...  strategy:    rollingUpdate:      maxSurge: 25%      maxUnavailable: 25%    type: RollingUpdate...root@k8s-master:~# kubectl set image deployments/nginx-deployment nginx=nginx:1.17.1 --recordFlag --record has been deprecated, --record will be removed in the futuredeployment.apps/nginx-deployment image updated# 查看更新的进度---更新过程是多了一个replicasetroot@k8s-master:~# kubectl rollout status deployment/nginx-deploymentWaiting for deployment "nginx-deployment" rollout to finish: 1 out of 3 new replicas have been updated...Waiting for deployment "nginx-deployment" rollout to finish: 1 out of 3 new replicas have been updated...Waiting for deployment "nginx-deployment" rollout to finish: 1 out of 3 new replicas have been updated...Waiting for deployment "nginx-deployment" rollout to finish: 2 out of 3 new replicas have been updated...Waiting for deployment "nginx-deployment" rollout to finish: 2 out of 3 new replicas have been updated...Waiting for deployment "nginx-deployment" rollout to finish: 2 out of 3 new replicas have been updated...Waiting for deployment "nginx-deployment" rollout to finish: 1 old replicas are pending termination...Waiting for deployment "nginx-deployment" rollout to finish: 1 old replicas are pending termination...deployment "nginx-deployment" successfully rolled outroot@k8s-master:~# kubectl get deployments.apps,replicasets.apps,pods -l app=nginxNAME                               READY   UP-TO-DATE   AVAILABLE   AGEdeployment.apps/nginx-deployment   3/3     3            3           5m43sNAME                                          DESIRED   CURRENT   READY   AGEreplicaset.apps/nginx-deployment-5d457cdfc8   3         3         3       84sreplicaset.apps/nginx-deployment-8d94c585f    0         0         0       5m43sNAME                                    READY   STATUS    RESTARTS   AGEpod/nginx-deployment-5d457cdfc8-7whnx   1/1     Running   0          66spod/nginx-deployment-5d457cdfc8-b7njk   1/1     Running   0          84spod/nginx-deployment-5d457cdfc8-x4zv8   1/1     Running   0          55s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  2.更新的策略</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 首先创建了一个新的Pod，然后删除了一些旧的Pods， 并创建了新的Pods。不会杀死老Pods，直到有足够的数量新的Pods已经出现# 在足够数量的旧Pods被杀死前并没有创建新Pods。确保至少2个Pod可用，同时最多总共4个pod可用# Deployment可确保在更新时仅关闭一定数量的Pod。默认情况下确保至少所需Pods 75%处于运行状态（最大不可用比例为 25%）root@k8s-master:~# kubectl describe deployments.apps nginx-deployment<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="10-5-4-回滚Deployment"><a href="#10-5-4-回滚Deployment" class="headerlink" title="10.5.4 回滚Deployment"></a>10.5.4 回滚Deployment</h3><p>  假设在更新时犯错误了，将镜像名称命名设置为nginx:1.172，而不是nginx:1.17.2，发现永远无法更新成功，此时就需要回退</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@k8s-master:~# kubectl set image deployments/nginx-deployment nginx=nginx:1.172 --recordFlag --record has been deprecated, --record will be removed in the futuredeployment.apps/nginx-deployment image updatedroot@k8s-master:~# kubectl rollout status deployment/nginx-deploymentWaiting for deployment "nginx-deployment" rollout to finish: 1 out of 3 new replicas have been updated...# 镜像拉取失败root@k8s-master:~# kubectl get podsNAME                                READY   STATUS             RESTARTS   AGEnginx-deployment-5d457cdfc8-7whnx   1/1     Running            0          7m50snginx-deployment-5d457cdfc8-b7njk   1/1     Running            0          8m8snginx-deployment-5d457cdfc8-x4zv8   1/1     Running            0          7m39snginx-deployment-6b7d6c469c-zcjps   0/1     ImagePullBackOff   0          92s# 开始回滚1.查看历史版本root@k8s-master:~# kubectl rollout history deployments/nginx-deploymentdeployment.apps/nginx-deploymentREVISION  CHANGE-CAUSE1         &lt;none&gt;2         kubectl set image deployments/nginx-deployment nginx=nginx:1.17.1 --record=true3         kubectl set image deployments/nginx-deployment nginx=nginx:1.172 --record=true2.查看某个版本root@k8s-master:~# kubectl rollout history deployment.v1.apps/nginx-deployment --revision=2deployment.apps/nginx-deployment with revision #2Pod Template:  Labels:       app=nginx        pod-template-hash=5d457cdfc8  Annotations:  kubernetes.io/change-cause: kubectl set image deployments/nginx-deployment nginx=nginx:1.17.1 --record=true  Containers:   nginx:    Image:      nginx:1.17.1    Port:       80/TCP    Host Port:  0/TCP    Environment:        &lt;none&gt;    Mounts:     &lt;none&gt;  Volumes:      &lt;none&gt;  Node-Selectors:       &lt;none&gt;  Tolerations:  &lt;none&gt;3.回滚到某个版本root@k8s-master:~# kubectl rollout undo deployments/nginx-deployment --to-revision=2deployment.apps/nginx-deployment rolled backroot@k8s-master:~# kubectl rollout status deployment/nginx-deploymentdeployment "nginx-deployment" successfully rolled outroot@k8s-master:~# kubectl get deployment.appsNAME               READY   UP-TO-DATE   AVAILABLE   AGEnginx-deployment   3/3     3            3           23m<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="10-5-5-伸缩Deployment"><a href="#10-5-5-伸缩Deployment" class="headerlink" title="10.5.5 伸缩Deployment"></a>10.5.5 伸缩Deployment</h3><p>  将指定的deployment副本更改为10</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@k8s-master:~# kubectl scale deployments/nginx-deployment --replicas=10deployment.apps/nginx-deployment scaledroot@k8s-master:~# kubectl get deployments.apps,replicasets.apps -l app=nginxNAME                               READY   UP-TO-DATE   AVAILABLE   AGEdeployment.apps/nginx-deployment   10/10   10           10          25mNAME                                          DESIRED   CURRENT   READY   AGEreplicaset.apps/nginx-deployment-5d457cdfc8   10        10        10      21mreplicaset.apps/nginx-deployment-6b7d6c469c   0         0         0       14mreplicaset.apps/nginx-deployment-8d94c585f    0         0         0       25mroot@k8s-master:~# kubectl delete deployments.apps nginx-deployment<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="10-6-DaemonSet"><a href="#10-6-DaemonSet" class="headerlink" title="10.6 DaemonSet"></a>10.6 DaemonSet</h2><p>  DaemonSet确保全部（或某些）节点上运行一个 Pod 的副本。 当有节点加入集群时， 也会为他们新增一个 Pod 。 当有节点从集群移除时，这些 Pod 也会被回收。删除DaemonSet将会删除它创建的所有Pod</p><p>  DaemonSet 的一些典型用法：</p><p>  1.在每个节点上运行集群守护进程</p><p>  2.在每个节点上运行日志收集守护进程</p><p>  3.在每个节点上运行监控守护进程</p><p><img src="/images/DaemonSet.png"></p><p>使用busybox镜像，在每一个节点上都运行一个pod：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cat &gt; daemonset.yml &lt;&lt;EOFapiVersion: apps/v1kind: DaemonSetmetadata:  name: luovip  labels:    daemonset: testspec:  selector:    matchLabels:      name: testpod  template:    metadata:      labels:        name: testpod    spec:      containers:      - name: hello        image: busybox        imagePullPolicy: IfNotPresent        command: ['sh', '-c', 'sleep 3600']EOFroot@k8s-master:~# kubectl create -f daemonset.ymldaemonset.apps/luovip createdroot@k8s-master:~# kubectl get daemonsets.appsNAME     DESIRED   CURRENT   READY   UP-TO-DATE   AVAILABLE   NODE SELECTOR   AGEluovip   2         2         2       2            2           &lt;none&gt;          19sroot@k8s-master:~# kubectl get pod -o wideNAME      READY   STATUS    RESTARTS   AGE   IP               NODE          NOMINATED NODE   READINESS GATESluovip-bxkmh      1/1     Running   0          95s   172.16.126.33    k8s-worker2   &lt;none&gt;           &lt;none&gt;luovip-fj5mz      1/1     Running   0          95s   172.16.194.105   k8s-worker1   &lt;none&gt;           &lt;none&gt;...root@k8s-master:~# kubectl delete -f daemonset.yml<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  DaemonSet总结：</p><p>  1.默认情况下， DaemonSet会在所有Node上创建一个Pod</p><p>  2.如果将运行的pod删除，DaemonSet会自动启动一个新的</p><p>  3.当有新节点加入集群时，会自动向其部署Pod</p><p>  4.当节点离开集群时，其上的节点会销毁，而不会跑到其他节点上</p><h2 id="10-7-StatefulSet"><a href="#10-7-StatefulSet" class="headerlink" title="10.7 StatefulSet"></a>10.7 StatefulSet</h2><p>  StatefulSet管理基于相同容器规约的一组 Pod。但和Deployment不同的是， StatefulSet为它们的每个Pod维护了一个有粘性的 ID。这些 Pod 是基于相同的规约来创建的， 但是不能相互替换：无论怎么调度，每个 Pod 都有一个永久不变的 ID<br>  StatefulSets 对于需要满足以下一个或多个需求的应用程序很有价值：</p><p>  1.稳定的、唯一的网络标识符</p><p>  2.稳定的、持久的存储</p><p>  3.有序的、优雅的部署和缩放</p><p>  4.有序的、自动的滚动更新</p><p><img src="/images/StatefulSet.png"></p><h3 id="10-7-1-创建yml文件"><a href="#10-7-1-创建yml文件" class="headerlink" title="10.7.1 创建yml文件"></a>10.7.1 创建yml文件</h3><p>  使用nginx镜像，创建一个副本数为3的有状态应用，并挂载本地目录到容器中</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cat &gt; statefulset.yml &lt;&lt;EOFapiVersion: apps/v1kind: StatefulSetmetadata:  name: webspec:  selector:    matchLabels:      app: nginx  serviceName: "nginx"  replicas: 3  template:    metadata:      labels:        app: nginx    spec:      containers:      - name: nginx        image: nginx:1.17.2        imagePullPolicy: IfNotPresent        ports:        - containerPort: 80          name: web        volumeMounts:        - name: www          mountPath: /usr/share/nginx/html      volumes:         - name: www           emptyDir: {}EOF<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="10-7-2-操作StatefulSet"><a href="#10-7-2-操作StatefulSet" class="headerlink" title="10.7.2 操作StatefulSet"></a>10.7.2 操作StatefulSet</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 发现创建的过程是有次序的，这也验证了有状态应用的启动顺序root@k8s-master:~# kubectl create -f statefulset.ymlstatefulset.apps/web createdroot@k8s-master:~# kubectl get pods -wNAME                                READY   STATUS    RESTARTS   AGEweb-0                               0/1     Pending   0          0sweb-0                               0/1     Pending   0          0sweb-0                               0/1     ContainerCreating   0          1sweb-0                               0/1     ContainerCreating   0          1sweb-0                               0/1     ErrImagePull        0          82sweb-0                               0/1     ImagePullBackOff    0          96sweb-0                               1/1     Running             0          108sweb-1                               0/1     Pending             0          0sweb-1                               0/1     Pending             0          0sweb-1                               0/1     ContainerCreating   0          0sweb-1                               0/1     ContainerCreating   0          0sweb-1                               1/1     Running             0          11sweb-2                               0/1     Pending             0          0sweb-2                               0/1     Pending             0          0sweb-2                               0/1     ContainerCreating   0          0sweb-2                               0/1     ContainerCreating   0          0sweb-2                               1/1     Running             0          1sroot@k8s-master:~# kubectl get podsNAME                                READY   STATUS    RESTARTS   AGEweb-0                               1/1     Running   0          3m36sweb-1                               1/1     Running   0          108sweb-2                               1/1     Running   0          97sroot@k8s-master:~# kubectl delete -f statefulset.ymlstatefulset.apps "web" deleted<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="10-8-Job"><a href="#10-8-Job" class="headerlink" title="10.8 Job"></a>10.8 Job</h2><p>  不断打印CKA JOB字符串，失败最多重试4次</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cat &gt; job.yml &lt;&lt;EOFapiVersion: batch/v1kind: Jobmetadata:  name: pispec:  template:    spec:      containers:      - name: pi        image: busybox        imagePullPolicy: IfNotPresent        command: ["sh",  "-c", "while true;do echo CKA JOB;done"]      restartPolicy: Never  backoffLimit: 4EOFroot@k8s-master:~# kubectl create -f job.ymljob.batch/pi createdroot@k8s-master:~# kubectl get jobs,podsNAME           STATUS    COMPLETIONS   DURATION   AGEjob.batch/pi   Running   0/1           10s        10sNAME           READY   STATUS    RESTARTS   AGEpod/pi-rglzp   1/1     Running   0          10sroot@k8s-master:~# kubectl logs pi-rglzpCKA JOBCKA JOBCKA JOB...root@k8s-master:~# kubectl delete -f job.ymljob.batch "pi" deleted<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="10-9-CronJob"><a href="#10-9-CronJob" class="headerlink" title="10.9 CronJob"></a>10.9 CronJob</h2><p>  每分钟打印一次指定字符串</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cat &gt; cronjob.yml &lt;&lt;EOFapiVersion: batch/v1kind: CronJobmetadata:  name: cronjobtestspec:  schedule: "*/1 * * * *"  jobTemplate:    spec:      template:        spec:          containers:          - name: hello            image: busybox            imagePullPolicy: IfNotPresent            command:            - /bin/sh            - -c            - date; echo Hello from the Kubernetes cluster          restartPolicy: OnFailureEOFroot@k8s-master:~# kubectl create -f cronjob.ymlcronjob.batch/cronjobtest createdroot@k8s-master:~# kubectl get cronjobs,podNAME                        SCHEDULE      TIMEZONE   SUSPEND   ACTIVE   LAST SCHEDULE   AGEcronjob.batch/cronjobtest   */1 * * * *   &lt;none&gt;     False     0        34s             35sNAME                             READY   STATUS      RESTARTS   AGEpod/cronjobtest-29127403-mb9qx   0/1     Completed   0          34sroot@k8s-master:~# kubectl logs cronjobtest-29127403-mb9qxMon May 19 08:43:01 UTC 2025Hello from the Kubernetes clusterroot@k8s-master:~# kubectl get cronjobs,podNAME                        SCHEDULE      TIMEZONE   SUSPEND   ACTIVE   LAST SCHEDULE   AGEcronjob.batch/cronjobtest   */1 * * * *   &lt;none&gt;     False     0        9s              2m10sNAME                             READY   STATUS      RESTARTS   AGEpod/cronjobtest-29127403-mb9qx   0/1     Completed   0          2m9spod/cronjobtest-29127404-9jmbj   0/1     Completed   0          69spod/cronjobtest-29127405-h5cc7   0/1     Completed   0          9s# 关于展示的任务次数的显示等的修改root@k8s-master:~# kubectl explain cronjob.specroot@k8s-master:~# kubectl delete -f cronjob.ymlcronjob.batch "cronjobtest" deleted<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="11-Service-服务发现"><a href="#11-Service-服务发现" class="headerlink" title="11 Service 服务发现"></a>11 Service 服务发现</h1><h2 id="11-1-Service"><a href="#11-1-Service" class="headerlink" title="11.1 Service"></a>11.1 Service</h2><p>  Pod是非永久性资源，每个Pod都有自己的IP地址</p><p>  如果一组Pod（称为“后端”）为集群内的其他Pod（称为“前端”）提供功能， 那么前端如何找出并跟踪要连接的IP地址，以便前端可以使用提供工作负载的后端部分</p><p><img src="/images/Service.png"></p><h2 id="11-2-Service类型"><a href="#11-2-Service类型" class="headerlink" title="11.2 Service类型"></a>11.2 Service类型</h2><p>  ClusterIP：通过集群的内部IP暴露服务，选择该值时服务只能够在集群内部访问。 这也是默认的ServiceType<br>  NodePort：通过每个节点上的IP和静态端口（NodePort）暴露服务。 NodePort服务会路由到自动创建的ClusterIP服务。 通过请求 &lt;节点 IP&gt;:&lt;节点端口&gt;，可以从集群的外部访问一个NodePort服务<br>  LoadBalancer：使用云提供商的负载均衡器向外部暴露服务。 外部负载均衡器可以将流量路由到自动创建的NodePort服务和ClusterIP 服务上<br>  ExternalName：通过返回CNAME和对应值，可以将服务映射到externalName字段的内容（例如，foo.bar.example.com）。 无需创建任何类型代理</p><p><img src="/images/Service%E8%AE%BF%E9%97%AE.png"></p><h2 id="11-3-iptables代理模式的Service"><a href="#11-3-iptables代理模式的Service" class="headerlink" title="11.3 iptables代理模式的Service"></a>11.3 iptables代理模式的Service</h2><p>  kube-proxy会监视Kubernetes 控制节点对Service对象和Endpoints对象的添加和移除。 对每个Service，它会配置iptables规则，从而捕获到达该Service的clusterIP和端口的请求，进而将请求重定向到 Service 的一组后端中的某个Pod上面。 对于每个Endpoints对象，它也会配置iptables规则，这个规则会选择一个后端组合<br>  默认的策略是，kube-proxy在iptables模式下随机选择一个后端<br>  使用iptables处理流量具有较低的系统开销，因为流量由Linux netfilter处理， 而无需在用户空间和内核空间之间切换。 这种方法也可能更可靠</p><h2 id="11-4-IPVS代理模式的Service"><a href="#11-4-IPVS代理模式的Service" class="headerlink" title="11.4 IPVS代理模式的Service"></a>11.4 IPVS代理模式的Service</h2><p>  在ipvs模式下，kube-proxy监视Kubernetes服务和端点，调用netlink接口相应地创建IPVS规则， 并定期将IPVS规则与Kubernetes服务和端点同步。 该控制循环可确保IPVS 状态与所需状态匹配。访问服务时，IPVS将流量定向到后端Pod之一<br>  IPVS代理模式基于类似于iptables模式的netfilter挂钩函数， 但是使用哈希表作为基础数据结构，并且在内核空间中工作。 这意味着，与 iptables模式下的kube-proxy相比，IPVS模式下的kube-proxy重定向通信的延迟要短，并且在同步代理规则时具有更好的性能。 与其他代理模式相比，IPVS模式还支持更高的网络流量吞吐量</p><h2 id="11-5-生成Service"><a href="#11-5-生成Service" class="headerlink" title="11.5 生成Service"></a>11.5 生成Service</h2><h3 id="11-5-1-准备后端Pod"><a href="#11-5-1-准备后端Pod" class="headerlink" title="11.5.1 准备后端Pod"></a>11.5.1 准备后端Pod</h3><p>  用nginx镜像准备一个3副本的deployment作为后端，并开放80端口</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cat &gt; deployment-service.yml &lt;&lt;EOFapiVersion: apps/v1kind: Deploymentmetadata:  name: nginx-deployment-servicetest  labels:    app: nginxspec:  replicas: 3  selector:    matchLabels:      app: nginx  template:    metadata:      labels:        app: nginx    spec:      containers:      - name: nginx        image: nginx:1.16.1        imagePullPolicy: IfNotPresent        ports:        - containerPort: 80EOFroot@k8s-master:~# kubectl create -f deployment-service.ymldeployment.apps/nginx-deployment-servicetest createdroot@k8s-master:~# kubectl get pods -o wideNAME      READY   STATUS    RESTARTS   AGE   IP        NODE          NOMINATED NODE   READINESS GATESnginx-deployment-servicetest-8d94c585f-6ktj9 1/1  Running 0 13s 172.16.126.35 k8s-worker2 &lt;none&gt;   &lt;none&gt;nginx-deployment-servicetest-8d94c585f-jclrr 1/1  Running 0 13s 172.16.194.117 k8s-worker1 &lt;none&gt;     &lt;none&gt;nginx-deployment-servicetest-8d94c585f-wgztv 1/1  Running 0 13s 172.16.194.116 k8s-worker1   &lt;none&gt;  &lt;none&gt;root@k8s-master:~# curl 172.16.126.35<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="11-5-2-命令行生成Service"><a href="#11-5-2-命令行生成Service" class="headerlink" title="11.5.2 命令行生成Service"></a>11.5.2 命令行生成Service</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 用kubectl expose的命令创建一个针对deployment的服务，并查询endpoint是否准备就绪root@k8s-master:~# kubectl expose deployment nginx-deployment-servicetest --port=9000 --name=luoyuservice --target-port=80 --type=NodePortservice/luoyuservice exposedroot@k8s-master:~# kubectl get service,endpointsNAME                   TYPE        CLUSTER-IP     EXTERNAL-IP   PORT(S)          AGEservice/kubernetes     ClusterIP   10.96.0.1      &lt;none&gt;        443/TCP          2d13hservice/luoyuservice   NodePort    10.105.8.223   &lt;none&gt;        9000:32646/TCP   26sNAME                     ENDPOINTS                                              AGEendpoints/kubernetes     192.168.8.3:6443                                       2d13hendpoints/luoyuservice   172.16.126.35:80,172.16.194.116:80,172.16.194.117:80   26sroot@k8s-master:~# curl http://192.168.8.3:32646...&lt;title&gt;Welcome to nginx!&lt;/title&gt;root@k8s-master:~# kubectl delete service luoyuserviceservice "luoyuservice" deleted<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="11-6-ClusterIP类型的Service"><a href="#11-6-ClusterIP类型的Service" class="headerlink" title="11.6 ClusterIP类型的Service"></a>11.6 ClusterIP类型的Service</h2><p>  ClusterIP是默认的Service类型，对外提供8000端口，并把流量引流到具有app: nginx的后端80端口上</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cat &gt; clusterip.yml &lt;&lt;EOFapiVersion: v1kind: Servicemetadata:  name: my-servicespec:  selector:    app: nginx  ports:    - protocol: TCP      port: 8000      targetPort: 80EOFroot@k8s-master:~# kubectl create -f clusterip.ymlservice/my-service createdroot@k8s-master:~# kubectl get service,endpointsNAME                 TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)    AGEservice/kubernetes   ClusterIP   10.96.0.1       &lt;none&gt;        443/TCP    3d2hservice/my-service   ClusterIP   10.101.56.206   &lt;none&gt;        8000/TCP   2m35sNAME                   ENDPOINTS                                              AGEendpoints/kubernetes   192.168.8.3:6443                                       3d2hendpoints/my-service   172.16.126.35:80,172.16.194.116:80,172.16.194.117:80   2m35sroot@k8s-master:~# curl 10.101.56.206:8000...&lt;title&gt;Welcome to nginx!&lt;/title&gt;root@k8s-master:~# kubectl delete -f clusterip.ymlservice "my-service" deleted<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="11-7-NodePort类型的Service"><a href="#11-7-NodePort类型的Service" class="headerlink" title="11.7 NodePort类型的Service"></a>11.7 NodePort类型的Service</h2><p>  Type: NodePort将会在节点的特定端口上开通服务，指定了端口为31788</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cat &gt; nodeport.yml &lt;&lt;EOFapiVersion: v1kind: Servicemetadata:  name: nodeservicespec:  type: NodePort  selector:    app: nginx  ports:    - protocol: TCP      port: 8000      targetPort: 80      nodePort: 31788EOFroot@k8s-master:~# kubectl create -f nodeport.ymlservice/nodeservice createdroot@k8s-master:~# kubectl get service,endpointsNAME                  TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)          AGEservice/kubernetes    ClusterIP   10.96.0.1        &lt;none&gt;        443/TCP          3d3hservice/nodeservice   NodePort    10.102.124.139   &lt;none&gt;        8000:31788/TCP   27sNAME                    ENDPOINTS                                              AGEendpoints/kubernetes    192.168.8.3:6443                                       3d3hendpoints/nodeservice   172.16.126.35:80,172.16.194.116:80,172.16.194.117:80   27s# 因为是nodeport，所以用节点IProot@k8s-master:~# curl 192.168.8.4:31788...&lt;title&gt;Welcome to nginx!&lt;/title&gt;root@k8s-master:~# kubectl delete -f nodeport.ymlservice "nodeservice" deleted<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="11-8-Headless类型的Service"><a href="#11-8-Headless类型的Service" class="headerlink" title="11.8 Headless类型的Service"></a>11.8 Headless类型的Service</h2><h3 id="11-8-1-服务实现"><a href="#11-8-1-服务实现" class="headerlink" title="11.8.1 服务实现"></a>11.8.1 服务实现</h3><p>  在此类型的Service中，将不会只返回Service IP，会直接返回众多Pod 的IP地址，所以需要进入pod中用集群内DNS进行测试</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cat &gt; headless.yml &lt;&lt;EOFapiVersion: v1kind: Servicemetadata:  name: headlessspec:  clusterIP: None  selector:    app: nginx  ports:    - protocol: TCP      port: 8000      targetPort: 80EOFroot@k8s-master:~# kubectl create -f headless.ymlservice/headless createdroot@k8s-master:~# kubectl get service,endpointsNAME                 TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)    AGEservice/headless     ClusterIP   None         &lt;none&gt;        8000/TCP   25sservice/kubernetes   ClusterIP   10.96.0.1    &lt;none&gt;        443/TCP    3d3hNAME                   ENDPOINTS                                              AGEendpoints/headless     172.16.126.35:80,172.16.194.116:80,172.16.194.117:80   25sendpoints/kubernetes   192.168.8.3:6443                                       3d3h<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="11-8-2-测试Headless服务发现"><a href="#11-8-2-测试Headless服务发现" class="headerlink" title="11.8.2 测试Headless服务发现"></a>11.8.2 测试Headless服务发现</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@k8s-master:~# kubectl run --rm --image=busybox:1.28 -it testpodIf you don't see a command prompt, try pressing enter./ # nslookup headlessServer:    10.96.0.10Address 1: 10.96.0.10 kube-dns.kube-system.svc.cluster.localName:      headlessAddress 1: 172.16.194.117 172-16-194-117.headless.default.svc.cluster.localAddress 2: 172.16.194.116 172-16-194-116.headless.default.svc.cluster.localAddress 3: 172.16.126.35 172-16-126-35.headless.default.svc.cluster.local/ # exitSession ended, resume using 'kubectl attach testpod -c testpod -i -t' command when the pod is runningpod "testpod" deletedroot@k8s-master:~# kubectl delete -f headless.ymlservice "headless" deleted<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>服务的DNS记录名称为：</p><p>  servicename.namespace.svc.cluster.local</p><p>deployment中Pod的DNS记录名称为：</p><p>  podIP.servicename.namespace.svc.cluster.local</p><p>Client访问服务时，可以使用DNS记录便捷抵达服务，甚至与服务在同一namespace时，直接用 servicename进行访问</p><h2 id="11-9-LoadBalancer类型的Service"><a href="#11-9-LoadBalancer类型的Service" class="headerlink" title="11.9 LoadBalancer类型的Service"></a>11.9 LoadBalancer类型的Service</h2><h3 id="11-9-1-部署metallb负载均衡"><a href="#11-9-1-部署metallb负载均衡" class="headerlink" title="11.9.1 部署metallb负载均衡"></a>11.9.1 部署metallb负载均衡</h3><p>1.先部署一个metallb controller和Speaker：</p><p>  1.metallb controller用于负责监听Kubernetes Service的变化，当服务类型被设置为LoadBalancer时，Controller会从一个预先配置的IP地址池中分配一个 IP地址给该服务，并管理这个IP地址的生命周期</p><p>  2.Speaker负责将服务的 IP 地址通过标准的路由协议广播到网络中，确保外部流量能够正确路由到集群中的服务</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@k8s-master:~# kubectl apply -f https://www.linuxcenter.cn/files/cka/cka-yaml/metallb-native.yaml<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>2.定义一组由负载均衡对外分配的IP地址范围</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cat &gt; ippool.yml &lt;&lt;-EOFapiVersion: metallb.io/v1beta1kind: IPAddressPoolmetadata:  name: lxh-ip-pool-192-168-8-10-100  namespace: metallb-systemspec:  addresses:  - 192.168.8.10-192.168.8.100EOFroot@k8s-master:~# kubectl apply -f ippool.ymlipaddresspool.metallb.io/lxh-ip-pool-192-168-8-10-100 created<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>3.在 Layer 2 模式下用于控制如何通过 ARP（Address Resolution Protocol）或 NDP（Neighbor Discovery Protocol）协议宣告服务的 IP 地址，使得这些 IP 地址在本地网络中可解析</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cat &gt; l2Advertisement.yml &lt;&lt;-EOFapiVersion: metallb.io/v1beta1kind: L2Advertisementmetadata:  name: l2-myippool  namespace: metallb-systemspec:  ipAddressPools:  - lxh-ip-pool-192-168-8-10-100EOFroot@k8s-master:~# kubectl apply -f l2Advertisement.ymll2advertisement.metallb.io/l2-myippool created<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="11-9-2-部署LoadBalancer服务"><a href="#11-9-2-部署LoadBalancer服务" class="headerlink" title="11.9.2 部署LoadBalancer服务"></a>11.9.2 部署LoadBalancer服务</h3><p>  负载均衡准备好之后，创建LoadBalancer类型的服务</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cat &gt; loadbalancer.yml &lt;&lt;-EOFapiVersion: v1kind: Servicemetadata:  name: loadbalance-servicespec:  selector:    app: nginx  ports:    - protocol: TCP      port: 80      targetPort: 80  type: LoadBalancerEOFroot@k8s-master:~# kubectl apply -f loadbalancer.ymlservice/loadbalance-service created# 获取服务看看是否分配到了负载均衡IP  从输出上看，分配到了192.168.8.10root@k8s-master:~# kubectl get serviceNAME                  TYPE           CLUSTER-IP     EXTERNAL-IP    PORT(S)        AGEkubernetes            ClusterIP      10.96.0.1      &lt;none&gt;         443/TCP        3d4hloadbalance-service   LoadBalancer   10.99.147.16   192.168.8.10   80:30972/TCP   10s# 用负载均衡IP访问root@k8s-master:~# curl 192.168.8.10...&lt;title&gt;Welcome to nginx!&lt;/title&gt;# 删除service资源root@k8s-master:~# kubectl delete -f loadbalancer.ymlservice "loadbalance-service" deleted<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="11-10-Ingress"><a href="#11-10-Ingress" class="headerlink" title="11.10 Ingress"></a>11.10 Ingress</h2><p>  Ingress公开了从集群外部到集群内服务的HTTP和HTTPS路由</p><p>  流量路由由Ingress资源上定义的规则控制</p><p>  Ingress可以提供负载均衡、SSL卸载和基于名称的虚拟托管，为了让Ingress资源工作，集群必须有一个正在运行的Ingress控制器</p><p><img src="/images/Ingress.png"></p><h3 id="11-10-1-Ingress控制器部署"><a href="#11-10-1-Ingress控制器部署" class="headerlink" title="11.10.1 Ingress控制器部署"></a>11.10.1 Ingress控制器部署</h3><p>  Ingress需要Ingress控制器支持，先部署控制器</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 拉取v1.1.0版本的yaml文件# 使用如下路径下载-可能会失败wget https://raw.githubusercontent.com/kubernetes/ingress-nginx/controller-v1.1.0/deploy/static/provider/baremetal/deploy.yamlroot@k8s-master:~# wget https://www.linuxcenter.cn/files/cka/cka-yaml/ingressdeploy.yaml# 从阿里云的镜像仓库上面拉取镜像docker pull registry.cn-hangzhou.aliyuncs.com/google_containers/nginx-ingress-controller:v1.12.1docker pull registry.cn-hangzhou.aliyuncs.com/google_containers/kube-webhook-certgen:v1.5.2# 在Kubernetes Ingress 的使用场景中，尤其是使用Ingress-Nginx作为 Ingress Controller 时，kube-webhook-certgen工具被用来创建和更新用于TLS认证的证书。这些证书被用于确保 Webhook 与 Kubernetes API 服务器之间的通信是安全的# 修改ingressdeploy.yaml文件440行改为 image: registry.cn-hangzhou.aliyuncs.com/google_containers/nginx-ingress-controller:v1.12.1542行改为image: registry.cn-hangzhou.aliyuncs.com/google_containers/kube-webhook-certgen:v1.5.2596行改为 image: registry.cn-hangzhou.aliyuncs.com/google_containers/kube-webhook-certgen:v1.5.2root@k8s-master:~# kubectl apply -f ingressdeploy.yamlroot@k8s-master:~# kubectl get pod -n ingress-nginxNAME                                   READY   STATUS      RESTARTS   AGEingress-nginx-admission-create-k9smq   0/1     Completed   0          17mingress-nginx-admission-patch-46hk7    0/1     Completed   2          17mingress-nginx-controller-47nzv         1/1     Running     0          17mingress-nginx-controller-svcpx         1/1     Running     0          17m# admission相关pod状态为Completed为正常<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="11-10-2-Ingress路径类型"><a href="#11-10-2-Ingress路径类型" class="headerlink" title="11.10.2 Ingress路径类型"></a>11.10.2 Ingress路径类型</h3><p>  Ingress中的每个路径都需要有对应的路径类型，未明确设置pathType的路径无法通过合法性检查。当前支持的路径类型有三种：</p><p>  1.ImplementationSpecific：对于这种路径类型，匹配方法取决于IngressClass。 具体实现可以将其作为单独的pathType处理或者与Prefix或 Exact类型作相同处理</p><p>  2.Exact：精确匹配URL路径，且区分大小写</p><p>  3.Prefix：基于以 / 分隔的URL路径前缀匹配。匹配区分大小写，并且对路径中的元素逐个完成。 路径元素指的是由/分隔符分隔的路径中的标签列表。 如果每个p都是请求路径p的元素前缀，则请求与路径p匹配</p><h3 id="11-10-3-Ingress的使用"><a href="#11-10-3-Ingress的使用" class="headerlink" title="11.10.3 Ingress的使用"></a>11.10.3 Ingress的使用</h3><p>  用nginx镜像生成一个3副本的Pod，并通过Service提供服务，然后再用ingress，以特定域名的方式对外暴露</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cat &gt; ingress.yml &lt;&lt;EOFapiVersion: apps/v1kind: Deploymentmetadata:  name: nginx-deployment-ingress  labels:    app: nginxspec:  replicas: 3  selector:    matchLabels:      app: nginx  template:    metadata:      labels:        app: nginx    spec:      containers:      - name: nginx        image: nginx:1.16.1        imagePullPolicy: IfNotPresent        ports:        - containerPort: 80---apiVersion: v1kind: Servicemetadata:  name: ingressservicespec:  selector:    app: nginx  ports:    - protocol: TCP      port: 80      targetPort: 80---apiVersion: networking.k8s.io/v1kind: Ingressmetadata:  name: luovipspec:  ingressClassName: nginx  rules:    - host: www.luovip.com      http:        paths:          - pathType: Prefix            path: "/"            backend:              service:                name: ingressservice                port:                  number: 80EOFroot@k8s-master:~# kubectl create -f ingress.ymldeployment.apps/nginx-deployment-ingress createdservice/ingressservice createdingress.networking.k8s.io/luovip createdroot@k8s-master:~# kubectl get deployments,service,ingressNAME                                           READY   UP-TO-DATE   AVAILABLE   AGEdeployment.apps/nginx-deployment-ingress       3/3     3            3           38sdeployment.apps/nginx-deployment-servicetest   3/3     3            3           24hNAME                     TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)   AGEservice/ingressservice   ClusterIP   10.98.162.124   &lt;none&gt;        80/TCP    38sservice/kubernetes       ClusterIP   10.96.0.1       &lt;none&gt;        443/TCP   3d13hNAME                               CLASS   HOSTS            ADDRESS                   PORTS   AGEingress.networking.k8s.io/luovip   nginx   www.luovip.com   192.168.8.4,192.168.8.5   80      38s# 把上述ADDRESS部分的IP和域名绑定解析root@k8s-master:~# echo 192.168.8.4 www.luovip.com &gt;&gt; /etc/hostsroot@k8s-master:~# curl http://www.luovip.comroot@k8s-master:~# kubectl delete -f ingress.yml<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="11-11-Gateway-API"><a href="#11-11-Gateway-API" class="headerlink" title="11.11 Gateway API"></a>11.11 Gateway API</h2><h3 id="11-11-1-Gateway-API-基本介绍"><a href="#11-11-1-Gateway-API-基本介绍" class="headerlink" title="11.11.1 Gateway API 基本介绍"></a>11.11.1 Gateway API 基本介绍</h3>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 容器&amp;K8S </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux服务</title>
      <link href="/2024/07/28/linux/linux-fu-wu/"/>
      <url>/2024/07/28/linux/linux-fu-wu/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux服务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库基础</title>
      <link href="/2024/05/14/shu-ju-ku/shu-ju-ku-ji-chu/"/>
      <url>/2024/05/14/shu-ju-ku/shu-ju-ku-ji-chu/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ansible的基本使用</title>
      <link href="/2024/04/28/zi-dong-hua-yun-wei/ansible-de-ji-ben-shi-yong/"/>
      <url>/2024/04/28/zi-dong-hua-yun-wei/ansible-de-ji-ben-shi-yong/</url>
      
        <content type="html"><![CDATA[<h1 id="1-介绍Ansible"><a href="#1-介绍Ansible" class="headerlink" title="1 介绍Ansible"></a>1 介绍Ansible</h1><p>  Ansible是python开发的、开源的批量自动化运维工具</p><p>  官方网站：<a href="https://www.ansible.com、https//docs.ansible.com/">https://www.ansible.com、https://docs.ansible.com/</a></p><p><img src="/images/ansible.png"></p><h2 id="1-1-Ansible的概念和架构"><a href="#1-1-Ansible的概念和架构" class="headerlink" title="1.1 Ansible的概念和架构"></a>1.1 Ansible的概念和架构</h2><p>  通过inventor定义Managed node，并由SSH与python进行连通：</p><p>  1.管理机上管理被管机</p><p>  2.inventory(清单)分组被管机</p><p>  3.基于SSH、PowerShell进行PUSH ad-hoc或基于YML文件Playbook</p><p>  4.Python模块、插件、API</p>]]></content>
      
      
      <categories>
          
          <category> 自动化运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ansible的基本使用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux进阶</title>
      <link href="/2023/05/28/linux/linux-jin-jie/"/>
      <url>/2023/05/28/linux/linux-jin-jie/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux进阶 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux的基本使用</title>
      <link href="/2022/05/28/linux/linux-de-ji-ben-shi-yong/"/>
      <url>/2022/05/28/linux/linux-de-ji-ben-shi-yong/</url>
      
        <content type="html"><![CDATA[<h1 id="1-访问命令行"><a href="#1-访问命令行" class="headerlink" title="1 访问命令行"></a>1 访问命令行</h1><h2 id="1-1-登录Linux系统"><a href="#1-1-登录Linux系统" class="headerlink" title="1.1 登录Linux系统"></a>1.1 登录Linux系统</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">图形化：系统菜单-注销-或切换用户字符界面：Ctrl+alt+F2-F6   在本机上切换用户：su - root退出登录：ctrl+d、exit、logout)网络登录：ssh ip、ssh 主机名[kiosk@foundation0 ~]$ ssh serverassh 用户名@ip/主机名[kiosk@foundation0 ~]$ ssh student@servera<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="1-2-终端切换"><a href="#1-2-终端切换" class="headerlink" title="1.2 终端切换"></a>1.2 终端切换</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">CLI   Ctrl+alt+Fx   xin （2，6）GUI   Ctrl+alt+F1  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="1-3-Shell简介"><a href="#1-3-Shell简介" class="headerlink" title="1.3 Shell简介"></a>1.3 Shell简介</h2><p>  是一个解释器，可以帮助用户将指令信息传递内核</p><p>  红帽企业Linux中为用户提供的默认shell是bash，bash是与UNIX类似的系统上使用的其中一个最成功的shell改进版本</p><h2 id="1-4-基本组成"><a href="#1-4-基本组成" class="headerlink" title="1.4 基本组成"></a>1.4 基本组成</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[kiosk@foundation0 ~]$                    #$普通用户[kiosk@foundation0 ~]$ su - root          #切换用户：su - 用户名Password:                                 #输入用户登录密码Last login: Sat Feb 22 15:11:13 CST 2020 on tty3[root@foundation0 ~]#                    #超级用户ctrl+d or exit                           退出登录<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注明：</p><p>  1.bash shell在概念上与微软的cmd相似，但bash具有更加复杂的脚本语言</p><p>  2.与win系统powershell类似、mac的管理终端使用工具也是使用的bash shell</p><h2 id="1-5-GNOME-Shell"><a href="#1-5-GNOME-Shell" class="headerlink" title="1.5 GNOME Shell"></a>1.5 GNOME Shell</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ALT+F2  输入 gnome-terminal    # 启动终端win+l  # 锁定#  关闭                 重启  init 0               init 6  poweroff             reboot  systemctl poweroff   systemctl reboot  shutdown -h 20：00   shutdown -r 0ctrl+alt 上\|下 箭头   # 工作区切换<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="1-6-Shell的特性"><a href="#1-6-Shell的特性" class="headerlink" title="1.6 Shell的特性"></a>1.6 Shell的特性</h2><h3 id="1-6-1-linux命令语法"><a href="#1-6-1-linux命令语法" class="headerlink" title="1.6.1 linux命令语法"></a>1.6.1 linux命令语法</h3><p>  完成具体功能的命令、扩展该命令功能的选项、命令要操作的对象</p><p>  cmd 【-option】 【arg1】 【arg2】</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">简单的命令示例：whoamidatetouch file1；mkdir dir1完成某些工作的指令扩展命令功能的选项参数lsls -a    ls -a    ~/.bashrcls -a  -l  ~/.bashrcls -al  ~/.bashrc<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-6-2-命令的基础分类"><a href="#1-6-2-命令的基础分类" class="headerlink" title="1.6.2 命令的基础分类"></a>1.6.2 命令的基础分类</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 回显式命令date +%Y%m%ddate +%Y-%m-%d# 交互式命令passwd# tab补全按一下是补全按两下列出可用命令tab键  输入单词或命令前面几个首字母后，保证唯一可补全，不唯一可列出能选择的命令# 历史命令-historyenv--能容纳1000条[root@servera ~]# env | grep SIZEHISTSIZE=1000[root@servera ~]# history -w [root@servera ~]# vim ~/.bash_history     记录历史命令文件，vim是一个文本工具，可以打开后面的文件，进入后:q退出[root@servera ~]# history -c   清除[root@servera ~]# history history的其他方法：！！！23    历史命令的编号！h      命令首字母当前历史命令支持的最大条数[root@foundation0 /]# grep ^HISTSIZE /etc/profileHISTSIZE=1000历史命令存放文件路径[root@foundation0 /]# set | grep HISTFILEHISTFILE=/root/.bash_historyvim /etc/profileexport HISTFILE=/root/.newfilesource /etc/profilehistory -wcat /root/.newfilectrl+R 搜索历史命令<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="1-7-命令行快捷键"><a href="#1-7-命令行快捷键" class="headerlink" title="1.7 命令行快捷键"></a>1.7 命令行快捷键</h2><table><thead><tr><th align="left">快捷键</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">ctrl + shift + t</td><td align="left">当前画面添加一个标签</td></tr><tr><td align="left">ctrl + shift + n</td><td align="left">打开一个新的标签</td></tr><tr><td align="left">alt + 1，alt + 2</td><td align="left">切换标签</td></tr><tr><td align="left">ctrl + shift + =，ctrl + -</td><td align="left">扩大与缩小终端字体</td></tr><tr><td align="left">ctrl + shift + w</td><td align="left">关闭标签</td></tr></tbody></table><h2 id="1-8-Shell常用快捷键"><a href="#1-8-Shell常用快捷键" class="headerlink" title="1.8 Shell常用快捷键"></a>1.8 Shell常用快捷键</h2><table><thead><tr><th align="left">快捷键</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">ctrl + a</td><td align="left">光标跳至行首</td></tr><tr><td align="left">ctrl + e</td><td align="left">光标跳至行尾</td></tr><tr><td align="left">ctrl + u</td><td align="left">从光标所在位置清空至行首</td></tr><tr><td align="left">ctrl + k</td><td align="left">从光标所在位置清空至行末</td></tr><tr><td align="left">ctrl + 左箭头</td><td align="left">光标向左跳一个单词</td></tr><tr><td align="left">ctrl + 右箭头</td><td align="left">光标向右跳一个单词</td></tr><tr><td align="left">ctrl + w</td><td align="left">回删一个单词</td></tr><tr><td align="left">alt + d</td><td align="left">删除光标后一个单词</td></tr><tr><td align="left">esc + . 或 alt + .</td><td align="left">调用之前使用过的路径，alt+.一直点可以向上翻阅路径</td></tr></tbody></table><h1 id="2-从命令行管理文件"><a href="#2-从命令行管理文件" class="headerlink" title="2 从命令行管理文件"></a>2 从命令行管理文件</h1><h2 id="2-1-系统目录结构"><a href="#2-1-系统目录结构" class="headerlink" title="2.1 系统目录结构"></a>2.1 系统目录结构</h2><p>  根(/)目录下每个目录的作用:</p><table><thead><tr><th align="left">目录名</th><th align="left">作用</th></tr></thead><tbody><tr><td align="left">bin</td><td align="left">用户可执行目录(命令root和普通)</td></tr><tr><td align="left">sbin</td><td align="left">系统可执行目录(命令root)</td></tr><tr><td align="left">lib</td><td align="left">库文件目录(32位)</td></tr><tr><td align="left">lib64</td><td align="left">库文件目录(64位)</td></tr><tr><td align="left">dev</td><td align="left">设备文件目录dev</td></tr><tr><td align="left">usr</td><td align="left">应用程序目录</td></tr><tr><td align="left">var</td><td align="left">服务器数据目录(数据日志)</td></tr><tr><td align="left">src</td><td align="left">服务器数据目录</td></tr><tr><td align="left">etc</td><td align="left">配置文件目录</td></tr><tr><td align="left">tmp</td><td align="left">临时文件目录</td></tr><tr><td align="left">boot</td><td align="left">服务器启动目录(内核和启动文件)</td></tr><tr><td align="left">media</td><td align="left">媒介目录(u盘、cdrom)</td></tr><tr><td align="left">mnt</td><td align="left">其他挂载点</td></tr><tr><td align="left">opt</td><td align="left">第三方应用程序目录</td></tr><tr><td align="left">proc</td><td align="left">伪文件系统(内核参数、进程信息、硬件信息)</td></tr><tr><td align="left">sys</td><td align="left">伪文件系统(配置文件目录、内核参数、进程信息、硬件信息)</td></tr><tr><td align="left">run</td><td align="left">进程锁目录</td></tr><tr><td align="left">root</td><td align="left">root管理员家目录</td></tr><tr><td align="left">home</td><td align="left">普通用户家目录</td></tr></tbody></table><h2 id="2-2-文件类型"><a href="#2-2-文件类型" class="headerlink" title="2.2 文件类型"></a>2.2 文件类型</h2><table><thead><tr><th align="left">文件类型</th><th align="left">说明</th><th align="left">全称</th></tr></thead><tbody><tr><td align="left">-</td><td align="left">普通文件</td><td align="left">file</td></tr><tr><td align="left">d</td><td align="left">目录文件</td><td align="left">directory</td></tr><tr><td align="left">c</td><td align="left">字符设备文件</td><td align="left">character</td></tr><tr><td align="left">b</td><td align="left">块设备文件</td><td align="left">block</td></tr><tr><td align="left">s</td><td align="left">套接字文件</td><td align="left">socket</td></tr><tr><td align="left">p</td><td align="left">管道文件</td><td align="left">pipe</td></tr><tr><td align="left">l</td><td align="left">符号链接文件(软链接)</td><td align="left">symbolic</td></tr></tbody></table><h2 id="2-3-文件名定位文件"><a href="#2-3-文件名定位文件" class="headerlink" title="2.3 文件名定位文件"></a>2.3 文件名定位文件</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@foundation0 home]# cd /[root@foundation0 /]# cd /etc/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="2-4-路径"><a href="#2-4-路径" class="headerlink" title="2.4 路径"></a>2.4 路径</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 路径的表示:1.绝对路径(通常以/开头)  例如：根开头    cd /etc/sysconfig2.相对路径:  非根开头 cd  ..  # 导航路径# pwd[root@foundation0 yum.repos.d]# pwd/etc/yum.repos.d# cdcd -   返回之前的目录cd or cd ~  家目录cd .    当前目录cd ..    上一级目录# lslsls -a ls -a /home ls -a -l ls -al[root@foundation0 ~]# ls -a .viminfo.viminfo[root@foundation0 ~]# ls -a -l .viminfo-rw-------. 1 root root 2545 Mar 13 13:12 .viminfo[root@foundation0 ~]# ls -al .viminfo-rw-------. 1 root root 2545 Mar 13 13:12 .viminfo[root@foundation0 /]# ls -l -d /homedrwxr-xr-x. 4 root root 30 Mar 13 11:38 /home<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-5-查看文件内容"><a href="#2-5-查看文件内容" class="headerlink" title="2.5 查看文件内容"></a>2.5 查看文件内容</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cat    cat /etc/passwd             # 将文件内容打印到屏幕上tail   tail /var/log/message       # 默认查看文件后10行。-F （追踪）指定文件不存在时再创建相同名称文件       tail -n 5 或 tail -5 /var/log/message   head   head /var/log/message       # 默认查看文件头10行       head -5 /var/log/message                less   less /var/log/message           more   more /var/log/message         vim    vim /etc/passwd             # 文本编辑器<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-6-命令行管理文件-目录"><a href="#2-6-命令行管理文件-目录" class="headerlink" title="2.6 命令行管理文件/目录"></a>2.6 命令行管理文件/目录</h2><h3 id="2-6-1-管理文件-目录的命令"><a href="#2-6-1-管理文件-目录的命令" class="headerlink" title="2.6.1 管理文件/目录的命令"></a>2.6.1 管理文件/目录的命令</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"> 创建   touch   mkdir -p 改名   mv      mv 移动   mv      mv 拷贝   cp      cp -r 删除   rm      rm -rtouch、mkdir、rm、cp、mv<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-6-2-touch命令-管理文件"><a href="#2-6-2-touch命令-管理文件" class="headerlink" title="2.6.2 touch命令(管理文件)"></a>2.6.2 touch命令(管理文件)</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@servera opt]# man touch[root@servera opt]# touch /file4 /tmp/file5[root@servera opt]# ls /file4;ls /tmp/file5/file4/tmp/file5[root@servera opt]# touch file{10..20}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-6-3-mkdir命令-管理目录"><a href="#2-6-3-mkdir命令-管理目录" class="headerlink" title="2.6.3 mkdir命令(管理目录)"></a>2.6.3 mkdir命令(管理目录)</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mkdir选项： -p：递归创建     -v：显示过程[root@servera opt]# lsdir1[root@servera opt]# mkdir dir2 /dir3[root@servera opt]# lsdir1  dir2[root@servera opt]# mkdir dir3/dir4mkdir: cannot create directory ‘dir3/dir4’: No such file or directory[root@servera opt]# mkdir -pv dir3/dir4mkdir: created directory 'dir3'mkdir: created directory 'dir3/dir4'[root@servera opt]# ls -R dir3  # -R递归查看，可以查看多级目录内容dir3:dir4dir3/dir4:[root@servera opt]# ll -R dir3/dir4dir3/dir4:total 0[root@servera opt]# ll  dir3total 0drwxr-xr-x. 2 root root 6 Mar 13 22:23 dir4[root@servera opt]# ll  dir3/dir4/total 0[root@servera opt]# ll  dir3/dir4/ -ddrwxr-xr-x. 2 root root 6 Mar 13 22:23 dir3/dir4/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-6-4-rm命令-删除"><a href="#2-6-4-rm命令-删除" class="headerlink" title="2.6.4 rm命令(删除)"></a>2.6.4 rm命令(删除)</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@servera opt]# man rm[root@servera opt]# lsdir1  dir2  dir3  file1  file2  file3[root@servera opt]# rm file1rm: remove regular empty file 'file1'? y    # 询问是否删除y删除n不删除[root@servera opt]# rm file2rm: remove regular empty file 'file2'? n[root@servera opt]# rm -f file2             强制删除不询问[root@servera opt]# lsdir1  dir2  dir3  file3[root@servera opt]# rm -f file*         *代表一个或多个字符[root@servera opt]# lsdir1  dir2  dir3[root@servera opt]# rm dir1             rm: cannot remove 'dir1': Is a directory[root@servera opt]# rm -r dir1          删除目录需要-r表示递归rm: remove directory 'dir1'? y[root@servera opt]# rm -rf dir2[root@servera opt]# lsdir3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-6-5-copy命令-复制"><a href="#2-6-5-copy命令-复制" class="headerlink" title="2.6.5 copy命令(复制)"></a>2.6.5 copy命令(复制)</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@servera opt]# lsdir1  dir2  file1  file2  file3[root@servera opt]# cp file1 /tmp/[root@servera opt]# ls /tmp/file1/tmp/file1[root@servera opt]# cp file1 /tmp/file10[root@servera opt]# ls /tmp/file10/tmp/file10[root@servera opt]# cp /etc/man_db.conf .[root@servera opt]# lsdir1  dir2  file1  file2  file3  man_db.conf<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-6-6-mv命令-移动文件-目录"><a href="#2-6-6-mv命令-移动文件-目录" class="headerlink" title="2.6.6 mv命令(移动文件/目录)"></a>2.6.6 mv命令(移动文件/目录)</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@servera opt]# mv file1 /[root@servera opt]# lsdir1  dir2  file2  file3  man_db.conf[root@servera opt]# mv file2 /file20[root@servera opt]# lsdir1  dir2  file3  man_db.conf[root@servera opt]# mv file3 file30[root@servera opt]# lsdir1  dir2  file30  man_db.conf[root@servera opt]# mv dir1 /[root@servera opt]# lsdir2  file30  man_db.conf[root@servera opt]# mv dir2 dir20[root@servera opt]# lsdir20  file30  man_db.conf<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-7-通配符规则"><a href="#2-7-通配符规则" class="headerlink" title="2.7 通配符规则"></a>2.7 通配符规则</h2><table><thead><tr><th align="left">通配符</th><th align="left">规则</th></tr></thead><tbody><tr><td align="left">*</td><td align="left">匹配0个或多个任意字符</td></tr><tr><td align="left">？</td><td align="left">匹配1个任意字符</td></tr><tr><td align="left">[ ]</td><td align="left">匹配中括号内一个字符</td></tr><tr><td align="left">[ - ]</td><td align="left">匹配中括号内连续范围的一个字符</td></tr><tr><td align="left">[ ^ ]</td><td align="left">取反，匹配非中括号内的字符，表示一定有一个字符，但不是中括号内出现的。【^ab】</td></tr><tr><td align="left">{a,b}或{a..c}</td><td align="left">匹配括号中的字符或连续的字符</td></tr></tbody></table><h1 id="3-在线获取帮助"><a href="#3-在线获取帮助" class="headerlink" title="3 在线获取帮助"></a>3 在线获取帮助</h1><h2 id="3-1-MAN手册说明"><a href="#3-1-MAN手册说明" class="headerlink" title="3.1 MAN手册说明"></a>3.1 MAN手册说明</h2><table><thead><tr><th align="left">命令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">man 1</td><td align="left">用户命令</td></tr><tr><td align="left">man 2</td><td align="left">系统调用</td></tr><tr><td align="left">man 3</td><td align="left">库调用</td></tr><tr><td align="left">man 4</td><td align="left">特殊文件</td></tr><tr><td align="left">man 5</td><td align="left">配置文件</td></tr><tr><td align="left">man 6</td><td align="left">游戏</td></tr><tr><td align="left">man 7</td><td align="left">杂项</td></tr><tr><td align="left">man 8</td><td align="left">系统命令</td></tr></tbody></table><h2 id="3-2-获取帮助的方法"><a href="#3-2-获取帮助的方法" class="headerlink" title="3.2 获取帮助的方法"></a>3.2 获取帮助的方法</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># man命令mandbman passwdman -k passwd man 5 passwdman setfacl | grep -B 1 lisa# --helpsetfacl --help | grep \\-asetfacl --help | grep -w \\-a  # pinfopinfo   回车  upinfo  ls# rpm包中提供帮助rpm -qa | grep httpdrpm -ql 软件包名称rpm -qc<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="4-创建、查看、编辑文本"><a href="#4-创建、查看、编辑文本" class="headerlink" title="4 创建、查看、编辑文本"></a>4 创建、查看、编辑文本</h1><h2 id="4-1-VIM的模式分类"><a href="#4-1-VIM的模式分类" class="headerlink" title="4.1 VIM的模式分类"></a>4.1 VIM的模式分类</h2><table><thead><tr><th align="left">模式</th><th align="left">功能</th></tr></thead><tbody><tr><td align="left">命令模式</td><td align="left">光标移动、复制、删除</td></tr><tr><td align="left">输入模式</td><td align="left">输入文本内容</td></tr><tr><td align="left">末行模式</td><td align="left">保存退出、设置环境</td></tr></tbody></table><h2 id="4-2-VIM的模式说明"><a href="#4-2-VIM的模式说明" class="headerlink" title="4.2 VIM的模式说明"></a>4.2 VIM的模式说明</h2><h3 id="4-2-1-命令模式"><a href="#4-2-1-命令模式" class="headerlink" title="4.2.1 命令模式"></a>4.2.1 命令模式</h3><table><thead><tr><th align="left">命令</th><th align="left">解释</th></tr></thead><tbody><tr><td align="left">h j k l</td><td align="left">左下上右</td></tr><tr><td align="left">方向键</td><td align="left">上下左右</td></tr><tr><td align="left">1G、nG</td><td align="left">n代表一个数字，去第1行或n行</td></tr><tr><td align="left">gg</td><td align="left">将光标定位到文章的顶端</td></tr><tr><td align="left">G</td><td align="left">将光标定位到文章的底端（$定位光标到行尾，0和^定位光标到行首）</td></tr><tr><td align="left">x，X</td><td align="left">向后删除一个字符、向前删除一个字符</td></tr><tr><td align="left">dd，ndd</td><td align="left">删除1行，n是一个数字，n行 例如：dgg、dG、d$、d0 D</td></tr><tr><td align="left">yy，nyy</td><td align="left">复制1行，复制n行</td></tr><tr><td align="left">p，P</td><td align="left">粘贴到下一行，粘贴到上一行</td></tr><tr><td align="left">u</td><td align="left">撤销</td></tr><tr><td align="left">ZZ</td><td align="left">保存退出</td></tr></tbody></table><h3 id="4-2-2-插入模式"><a href="#4-2-2-插入模式" class="headerlink" title="4.2.2 插入模式"></a>4.2.2 插入模式</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">a   字符后进入插入模式i   当前字符位置进入插入模式o   在下一行新创建一行进入插入模式A   在行尾进入插入模式I   在行首进入插入模式O   在上一行新创建一行进入插入模式s   删除光标位置字符并进入插入模式S   删除光标所在行并进入插入模式<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-2-3-末行模式"><a href="#4-2-3-末行模式" class="headerlink" title="4.2.3 末行模式"></a>4.2.3 末行模式</h3><table><thead><tr><th align="left">命令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">w</td><td align="left">保存</td></tr><tr><td align="left">q</td><td align="left">退出</td></tr><tr><td align="left">wq</td><td align="left">退出并保存</td></tr><tr><td align="left">q!</td><td align="left">强制退出</td></tr><tr><td align="left">x</td><td align="left">保存退出</td></tr><tr><td align="left">set nu</td><td align="left">设置行号</td></tr><tr><td align="left">set nonu</td><td align="left">取消行号</td></tr><tr><td align="left">：w /newfile</td><td align="left">另存为其他文件 例子：”:w /man.txt”</td></tr><tr><td align="left">：r /newfile</td><td align="left">读取/newfile到本文件中 例子： “:r /etc/passwd”</td></tr><tr><td align="left">：！ command</td><td align="left">vim编辑过程中，查询linux “:! ls /“</td></tr><tr><td align="left">: e！</td><td align="left">重新读取文件</td></tr></tbody></table><h3 id="4-2-4-其他模式"><a href="#4-2-4-其他模式" class="headerlink" title="4.2.4 其他模式"></a>4.2.4 其他模式</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">v、V或Ctrl+V    # 可视模式R              # 替换模式/word，？word  # /向下查找，？向上查找n，N          # 定位到下一个匹配字符，定位到上一个匹配字符# 视图模式# 视图模式修改方法：ctrl+v ， jjj，I，  写入#号，esc<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-3-VIM的缩进与保存"><a href="#4-3-VIM的缩进与保存" class="headerlink" title="4.3 VIM的缩进与保存"></a>4.3 VIM的缩进与保存</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">：set all         # 查看末行模式的帮助：set autoindent  # 保存上下缩进：set tabstop=2   # 调整tab键缩进：set nu          # 设置行号[root@foundation0 ~]# vim ~/.vimrc    仅对当前用户生效set nuset tabstop=2[root@foundation0 ~]# vim /etc/vimrc  全局设置，每个用户使用vim工具都有行号set nu<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-4-VIM的替换"><a href="#4-4-VIM的替换" class="headerlink" title="4.4 VIM的替换"></a>4.4 VIM的替换</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">:s///   @@@  AAA  ; ;;:s/old/new/:s/old/new/g:#,#s/old/new/g     #井号代表一个数字比如：1,5s/old/new/g:%s/old/new/g:#,$s/old/new/g    #井号代表数字，比如1，$s ，$代表末行，该命令为1行至末行# 修改某一段ip地址: %s/192.168.1/172.25.250/g# 取消文本中某个字段：:%s/10.10.10.10//g<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-5-关于重定向"><a href="#4-5-关于重定向" class="headerlink" title="4.5 关于重定向"></a>4.5 关于重定向</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">1=stand，2=error，&amp;=1+2echo $SHELLecho 123456 &gt; file1grep root /etc/passwd &gt; /opt/a.txtgrep apache /etc/passwd &gt; /opt/a.txtgrep -n ^$ /etc/resolv.confgrep na /etc/resolv.conf   &gt; /root/lines.txttc/resolv.conf   &gt; /root/lines.txt                 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="5-管理本地用户和组"><a href="#5-管理本地用户和组" class="headerlink" title="5 管理本地用户和组"></a>5 管理本地用户和组</h1><h2 id="5-1-USER-用户"><a href="#5-1-USER-用户" class="headerlink" title="5.1 USER-用户"></a>5.1 USER-用户</h2><p>  基本概念：用户用于访问计算机资源</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">0          超级用户 1000以下   系统用户1000以上   普通用户 组与用户ID对应(自然创建)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-1-1-useradd-添加用户"><a href="#5-1-1-useradd-添加用户" class="headerlink" title="5.1.1 useradd-添加用户"></a>5.1.1 useradd-添加用户</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">语法:useradd 选项 选项参数 用户名option：-u：指定用户uid-g：指定主要群组-G：指定附加群组-s：指定shell环境 /bin/bash /sbin/nolgoin /bin/false-c：指定描述-d：指定用户家目录(通常不更改，如果设置，需要是未存在的目录)例：useradd user1   创建user1passwd user1    为user1设置密码id user1        查询用户信息<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-1-2-用户配置文件"><a href="#5-1-2-用户配置文件" class="headerlink" title="5.1.2 用户配置文件"></a>5.1.2 用户配置文件</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 用户配置文件路径:/etc/passwd[kiosk@foundation0 ~]$ vim /etc/passwdroot:x:0:0:root:/root:/bin/bash#用户名：密码占位符：UID：GID：描述：家目录：shell环境# 练习1：   [root@servera /]# useradd -u 2000 user1[root@servera /]# id user1[root@servera /]# groupadd group1[root@servera /]# tail -1 /etc/group[root@servera /]# useradd -g group1 user2[root@servera /]# tail -1 /etc/passwd[root@servera /]# useradd -G wheel user3[root@servera /]# useradd -c student -d /user4dir -s /sbin/nologin user4[root@servera /]# tail -1 /etc/passwd[root@servera /]# su - user1[user1@servera /]# ctrl+d[root@servera /]# su - user1[root@servera /]# su - user2  需要密码[root@servera /]# ctrl+d  退出用户[root@servera /]# passwd user2  超级用户设置密码123456123456[root@servera /]# su - user1[root@servera /]# su - user2  输入密码[root@servera /]# useradd -G root,tom user5   #将user5同时加入到组root和tom组中# 练习2：tom10，uid 3000 ，gid devops，shell环境为/bin/false,描述 student，家目录/tom10dir,附加组 root。useradd -u 3000 -g devops -s /bin/false -c student -d /tom10dir -G root  tom10<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-1-3-usermod-修改用户"><a href="#5-1-3-usermod-修改用户" class="headerlink" title="5.1.3 usermod-修改用户"></a>5.1.3 usermod-修改用户</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">语法：usermod 选项 选项参数 用户名option：-u：指定用户uid-g：指定主要群组-G：指定附加群组-s：指定shell环境 /bin/bash  /sbin/nolgoin /bin/false-c：指定描述-d：指定用户家目录（通常不更改，且如设置需要是未存在的目录）-a：额外指定附加组# 练习1:[root@servera /]# usermod -u 3000 user1[root@servera /]# usermod -g group1 user1[root@servera /]# usermod -G root user1[root@servera /]# usermod -s /bin/false user1    #shell环境为/bin/false的用户和系统无任何交互[root@servera /]# su - user1[root@servera /]# usermod -c heihei user1# 练习2：tom11的附加组，root。想额外添加一个附加组为devops[root@servera opt]# usermod -a -G root tom11[root@servera opt]# usermod -G root,devops tom11<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-1-4-userdel-删除用户"><a href="#5-1-4-userdel-删除用户" class="headerlink" title="5.1.4 userdel-删除用户"></a>5.1.4 userdel-删除用户</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">语法：userdel 选项 选项参数  用户名option：-r：删除用户同时删除邮箱和家目录[root@servera /]# userdel -r user5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5-2-PASSWORD-密码"><a href="#5-2-PASSWORD-密码" class="headerlink" title="5.2 PASSWORD-密码"></a>5.2 PASSWORD-密码</h2><h3 id="5-2-1-设置密码"><a href="#5-2-1-设置密码" class="headerlink" title="5.2.1 设置密码"></a>5.2.1 设置密码</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">语法:passwd 用户名# 方法1：[root@foundation0 /]# echo 123456 | passwd --stdin zhangsan  非交互式Changing password for user zhangsan.passwd: all authentication tokens updated successfully.# 方法2：[root@foundation0 /]# passwd zhangsan  交互式<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-2-2-密码配置文件"><a href="#5-2-2-密码配置文件" class="headerlink" title="5.2.2 密码配置文件"></a>5.2.2 密码配置文件</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">路径:/etc/shadowuser2:$6$9R47OYVVaxga34EJ$Y3pGf5EnHpn6vfiBk5ZU1U89d7UiySOsnAs/fkFMuPRyhCZAvv0a6UXRVLGXqRUKwP34Sg0W/CYb1VQp7H08L0:20015:0:99999:7:::说明:第一列: 用户名第二列: 密码(有密码状态,无密码状态,!!帐号锁定,* 该帐号永久不能登陆系统)第三列: 密码的最后一次修改时间（从1970年1月1日至今的天数）18834=今天第四列: 密码的最小时间(和第三列比较，密码修改相隔时间，或理解为密码自最后一次修改后多少天内不能再重复修改)第五列: 密码的最大时间(密码有效期) 99999表示永久不过期(和第3列比，相当于自最后一次修改多久后必须变更密码，否则过期)第六列: 密码过期前警告时间（和第5列比，在过n天你的密码就过期了，需要重设密码。）第七列: 密码过期后帐号（宽限时间，第五列密码的最大时间到期后，还可以使用系统的宽限时间，该期间中可以继续使用系统，但是再次登入系统时强制修改密码，否则无法进入）第八列: 帐号有效期（账号失效后，无论密码是否过期都不能使用。）第九列: 保留列<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5-3-GROUP-用户组"><a href="#5-3-GROUP-用户组" class="headerlink" title="5.3 GROUP-用户组"></a>5.3 GROUP-用户组</h2><h3 id="5-3-1-groupadd"><a href="#5-3-1-groupadd" class="headerlink" title="5.3.1 groupadd"></a>5.3.1 groupadd</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">语法：groupadd 选项 选项参数 组名-g：指定组ID[root@servera /]# groupadd group10[root@servera /]# groupadd -g 3000 group10<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-3-2-groupmod"><a href="#5-3-2-groupmod" class="headerlink" title="5.3.2 groupmod"></a>5.3.2 groupmod</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">语法：groupmod 选项 选项参数 组名-n：更改组名 groupmod -n 新组名 旧组名[root@servera /]# groupmod -n group100 group10<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-3-3-groupdel"><a href="#5-3-3-groupdel" class="headerlink" title="5.3.3 groupdel"></a>5.3.3 groupdel</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 删除组信息groupdel groupname[root@foundation0 ~]# groupdel haha1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="5-3-4-gpasswd"><a href="#5-3-4-gpasswd" class="headerlink" title="5.3.4 gpasswd"></a>5.3.4 gpasswd</h3><p>  加入群组与清除群组成员</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">gpasswd-a：添加用户到群组-d：从组中清除用户[root@foundation0 ~]# useradd -G upup user5  添加用户时指定附加组（次要群组）[root@foundation0 ~]# usermod -G upup user1  修改用户时指定附加组（次要群组） [root@foundation0 ~]# gpasswd -a user2 rootAdding user user2 to group root[root@foundation0 ~]# gpasswd -d user2 rootRemoving user user2 from group root<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-3-5-用户组配置文件"><a href="#5-3-5-用户组配置文件" class="headerlink" title="5.3.5 用户组配置文件"></a>5.3.5 用户组配置文件</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">路径:/etc/group[root@localhost ~]# vim /etc/groupupup:x:2006:第一段: 组名第二段: 组密码占位符号第三段: gid第四段: 用户列表<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="6-控制对文件的访问"><a href="#6-控制对文件的访问" class="headerlink" title="6 控制对文件的访问"></a>6 控制对文件的访问</h1><h2 id="6-1-系统安全的技术点对比"><a href="#6-1-系统安全的技术点对比" class="headerlink" title="6.1 系统安全的技术点对比"></a><strong>6.1 系统安全的技术点对比</strong></h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#Linux操作系统涉及的安全部分:           防火墙                              semanage port ，selinux                            semanage ...软件app                             semanage boolean文件系统权限 特殊权限 facl 隐藏权限    semanage fcontext<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="6-2-文件权限说明"><a href="#6-2-文件权限说明" class="headerlink" title="6.2 文件权限说明"></a>6.2 文件权限说明</h2><table><thead><tr><th align="left">权限表示</th><th align="left">权限解释</th></tr></thead><tbody><tr><td align="left">r</td><td align="left">read(读)</td></tr><tr><td align="left">w</td><td align="left">write(写)</td></tr><tr><td align="left">x</td><td align="left">execute(执行)</td></tr></tbody></table><h2 id="6-3-权限表示"><a href="#6-3-权限表示" class="headerlink" title="6.3 权限表示"></a>6.3 权限表示</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># ls -l test-rw-r--r--. 1 stu1 class1 35 May 21 14:09 testrw-r--r--   #中间9位是权限，逻辑分三组，所有者 所属组 其他人权限stu1   所有者class1 所属组<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="6-4-系统权限的作用"><a href="#6-4-系统权限的作用" class="headerlink" title="6.4 系统权限的作用"></a>6.4 系统权限的作用</h2><table><thead><tr><th align="left">权限</th><th align="left">对文件的影响</th><th align="left">对目录的影响</th></tr></thead><tbody><tr><td align="left">r</td><td align="left">cat</td><td align="left">ls</td></tr><tr><td align="left">w</td><td align="left">vim</td><td align="left">touch，rm，mkdir</td></tr><tr><td align="left">x</td><td align="left">./script</td><td align="left">cd</td></tr></tbody></table><h2 id="6-5-符号修改文件权限"><a href="#6-5-符号修改文件权限" class="headerlink" title="6.5 符号修改文件权限"></a>6.5 符号修改文件权限</h2><table><thead><tr><th align="left">对象</th><th align="left">设置方式</th><th align="left">权限</th></tr></thead><tbody><tr><td align="left">u(user)</td><td align="left">+ (添加)</td><td align="left">r</td></tr><tr><td align="left">g(group)</td><td align="left">-(减去)</td><td align="left">w</td></tr><tr><td align="left">o(other)</td><td align="left">= (设置）</td><td align="left">x</td></tr><tr><td align="left">a(all)</td><td align="left"></td><td align="left">s(SUID、SGID)、t(Sbit)</td></tr></tbody></table><h2 id="6-6-数字方式修改文件权限"><a href="#6-6-数字方式修改文件权限" class="headerlink" title="6.6 数字方式修改文件权限"></a>6.6 <strong>数字方式修改文件权限</strong></h2><table><thead><tr><th align="left">rwx</th><th align="left">8进制表示</th><th align="left">数字表示</th></tr></thead><tbody><tr><td align="left">r–</td><td align="left">100</td><td align="left">4</td></tr><tr><td align="left">-w-</td><td align="left">010</td><td align="left">2</td></tr><tr><td align="left">–x</td><td align="left">001</td><td align="left">1</td></tr></tbody></table><h2 id="6-7-文件权限设置-chmod"><a href="#6-7-文件权限设置-chmod" class="headerlink" title="6.7 文件权限设置-chmod"></a>6.7 文件权限设置-chmod</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#语法：chmod 权限 文件名u g o a   + - =   r w x s t[root@node1 opt]# ll test -rw-r--r--. 1 root root 0 Nov 24 04:55 test[root@node1 opt]# chmod u+x test [root@node1 opt]# ll test -rwxr--r--. 1 root root 0 Nov 24 04:55 test<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="6-8-文件属主和属组-chown"><a href="#6-8-文件属主和属组-chown" class="headerlink" title="6.8 文件属主和属组-chown"></a>6.8 文件属主和属组-chown</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#语法：chown  所有者:所属组 文件名 chown  该命令可以作用于文件、目录，修改时保证所有者的用户及组都是存在的。例:chown user2:user2 newfile# 练习:[root@node1 opt]# ll test-rwxr--r--. 1 root root 0 Nov 24 04:55 test[root@node1 opt]# id studentuid=1000(student) gid=1000(student) groups=1000(student),10(wheel)[root@node1 opt]# useradd harry[root@node1 opt]# chown student test;ll test-rwxr--r--. 1 student root 0 Nov 24 04:55 test[root@node1 opt]# chown :harry test;ll test-rwxr--r--. 1 student harry 0 Nov 24 04:55 test[root@node1 opt]# useradd sally[root@node1 opt]# chown sally:sally test;ll test-rwxr--r--. 1 sally sally 0 Nov 24 04:55 test# -R参数[root@node1 opt]# ll -d dir1drwxrwxr-x. 2 root root 19 Nov 24 05:15 dir1[root@node1 opt]# chown -R sally:sally dir1[root@node1 opt]# ll -d dir1drwxrwxr-x. 2 sally sally 19 Nov 24 05:15 dir1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="6-9-文件默认权限-umask"><a href="#6-9-文件默认权限-umask" class="headerlink" title="6.9 文件默认权限-umask"></a>6.9 文件默认权限-umask</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#系统默认定义权限对于文件是666、对于目录是777#查看umask值[root@servera /]# umask0022#修改方法umask[root@servera /]# umask 0002修改完后，可以去文件和目录查看权限，看是否和之前不一样，看完改回来#永久生效[root@servera /]# echo 'umask 0002' &gt;&gt; ~/.bash_profile#将后面文件中的值加载到当前shell中。系统登录会读取~/.bash_profile文件自动加载[root@servera /]# source ~/.bash_profile  #source <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="6-10-umask的计算"><a href="#6-10-umask的计算" class="headerlink" title="6.10 umask的计算"></a>6.10 umask的计算</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#示例1：文件默认权限666umask后三位022快捷方法：变成权限后相减rw-rw-rw-  =  666  文件系统默认权限----w--w-  =  022  umask值------------------------------rw-r--r--  =  644  创建文件时的默认权限目录默认权限777rwxrwxrwx  =  777  目录系统默认权限----w--w-  =  022  umask值------------------------------rwxr-xr-x  =  755  创建目录时的默认权限故系统中应设置为:0022#示例2:文件权限是r-- --- ---， 400   文件夹是dr-x --- ---  500umask?目录rwxrwxrwx =  777r-x------ =  500--------------------w-rwxrwx =  277文件rw-rw-rw-  =  666-w-rwxrwx  =  umask  ------------------r-------   =  400参考umask计算方法：https://www.cnblogs.com/wyllearning/p/16482006.html如果减法时目录和文件权限不一致时，以目录的为准计算umask值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="6-10-特殊权限"><a href="#6-10-特殊权限" class="headerlink" title="6.10 特殊权限"></a>6.10 特殊权限</h2><p>  文件系统权限可以完成一些基本权限功能设置，但有些特殊要求是达不到的，可能需要特殊权限来完成</p><p>  Linux系统中特殊权限有三个：SUID 4 、SGID 2 、SBIT 1</p><h3 id="6-10-1-SUID-4"><a href="#6-10-1-SUID-4" class="headerlink" title="6.10.1 SUID 4"></a>6.10.1 SUID 4</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 通常设置在二进制可执行文件（命令）上，并具有执行权限的情况下# 作用：设置了该权限的命令，被其他用户执行时，会临时获取文件所有者权限[student@clear ~]$ cat /etc/shadow   #普通用户无法查看/etc/shadow[student@clear ~]$ su - root         #切换root身份[root@clear ~]# chmod u+s /usr/bin/cat   #数字修改方式：chmod 4755 /usr/bin/cart[root@clear ~]# ll /usr/bin/cat-rwsr-xr-x. 1 root root 34512 Aug 13  2018 /usr/bin/cat[student@clear ~]$ su - studnet[student@clear ~]$ cat /etc/shadow #能够看见内容，临时获取拥有者权限#数字修改法：chmod 4755 /usr/bin/cat# check：创建两个不同用户登录操作系统，进入dirt目录分别创建文件，尝试互相删除对方文件，结果应不能互相删除文件# 大S和小s区别，  1.执行权限位大S是，没有x  2.执行权限位小s是该位，有x<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="6-10-2-SGID-2"><a href="#6-10-2-SGID-2" class="headerlink" title="6.10.2 SGID 2"></a>6.10.2 SGID 2</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#该权限通常设置在`目录`上，设置了该权限的目录，在该目录中创建`子文件及目录`时会`继承`父目录所属组[root@clear opt]# chmod g+s dir1[root@clear opt]# ll -d dir1drwxr-sr-x. 2 student student 22 Nov 19 04:51 dir1[root@clear opt]# touch dir1/root1.txt[root@clear opt]# ll dir1/root1.txt-rw-r--r--. 1 root student 0 Nov 19 04:52 dir1/root1.txt#数字修改法： chmod 2755 dir1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="6-10-3-SBIT-1"><a href="#6-10-3-SBIT-1" class="headerlink" title="6.10.3 SBIT 1"></a>6.10.3 SBIT 1</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#该权限通常设置在目录上，设置了该权限的目录，其他用户在该目录中只能删除所有者是自己的文件[root@clear opt]# chmod 1777 /opt/share/[root@clear opt]# ll -d /opt/share/drwxrwxrwt. 2 root root 6 Nov 19 04:56 /opt/share/[root@clear opt]# su - studentLast login: Sat Nov 19 04:55:24 EST 2022 on pts/0[student@clear ~]$ touch /opt/share/student.txt.haha[student@clear ~]$ logout[root@clear opt]# su - tomLast login: Sat Nov 19 04:55:38 EST 2022 on pts/0[tom@clear ~]$ rm -f /opt/share/student.txt.haharm: cannot remove '/opt/share/student.txt.haha': Operation not permitted<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="7-进程监控及管理"><a href="#7-进程监控及管理" class="headerlink" title="7 进程监控及管理"></a>7 进程监控及管理</h1><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">yum install -y psmiscpstree -p# 程序被开启会产生一个或多个进程，他们都有对应父进程与子进程，每个进程都有进程号PID# systemd 1 不能被杀死，除非重启，关机<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="7-1-查看进程"><a href="#7-1-查看进程" class="headerlink" title="7.1 查看进程"></a>7.1 查看进程</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># ps以静态的方式查看系统进程ps -lps  aux  ps aux | grep http[root@servera ~]# ps -l# 查看httpd进程ps aux |grep httpd# top以同态的形式查看进程top<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="7-2-终止进程"><a href="#7-2-终止进程" class="headerlink" title="7.2 终止进程"></a>7.2 终止进程</h2><h3 id="7-2-1-kill命令"><a href="#7-2-1-kill命令" class="headerlink" title="7.2.1 kill命令"></a>7.2.1 kill命令</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#语法 kill -s 信号名称 或-n 信号编号#Options:-s sig  SIG is a signal name-n sig  SIG is a signal numberkill -s SIGKILL httpdkill -n 9 httpd   # 或 kill -9 httpd[root@node1 /]# kill -l 1) SIGHUP   2) SIGINT   3) SIGQUIT  4) SIGILL   5) SIGTRAP 6) SIGABRT  7) SIGBUS   8) SIGFPE   9) SIGKILL 10) SIGUSR1[root@node1 /]# vim 1 &amp;[1] 1372[root@node1 /]# ps -l[root@node1 /]# kill -n 9 1372[root@node1 /]# ps -lF S   UID     PID    PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD0 S     0    1313    1312  0  80   0 - 59084 -      pts/1    00:00:00 bash0 R     0    1374    1313  0  80   0 - 63799 -      pts/1    00:00:00 ps[1]+  Killed                  vim 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="7-2-2-killall命令"><a href="#7-2-2-killall命令" class="headerlink" title="7.2.2 killall命令"></a>7.2.2 killall命令</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#语法：killall 守护进程名称#yum install -y httpdsystemctl start httpdps aux | grep httpdkillall httpdyum provides killallyum install -y psmisc-23.1-3.el8.x86_64killall httpdps aux | grep httpd<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="7-3-作业控制jobs"><a href="#7-3-作业控制jobs" class="headerlink" title="7.3 作业控制jobs"></a>7.3 作业控制jobs</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@servera ~]# dd if=/dev/zero of=./bigfile bs=1M count=1000ctrl + z [root@servera ~]# jobs[1]+  Stopped                 dd if=/dev/zero of=./bigfile bs=1M count=1000[root@servera ~]# bg ％1[1]+ dd if=/dev/zero of=./bigfile bs=1M count=1000 &amp;[root@servera ~]# jobs[1]+  Running                 dd if=/dev/zero of=./bigfile bs=1M count=1000 &amp;[root@servera ~]# fg %1[root@servera ~]# kill -9 %2[2]-  Stopped                 vim file2[root@servera ~]# jobs[2]-  Killed                  vim file2[3]+  Stopped                 nice -n -10 vim file4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="7-4-进程优先级调整"><a href="#7-4-进程优先级调整" class="headerlink" title="7.4 进程优先级调整"></a>7.4 进程优先级调整</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#nice值#超级用户root 可以修改nice值范围 -20~19#普通用户user 可以修改nice值范围  0-191.进程优先级数字越小，优先级越高2.优先级不能直接改，可以通过nice值来影响优先级3.旧优先级 + nice值 = 新优先级  80       -10   = 70#两种方法：1.产生新进程时，设置nice值  nice  -n -5  vim file2 &amp;2.修改现有进程nice值  renice -n  10  PID# ps -l 查看需要更改的进程号  renice -n 10 28183<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="8-控制服务与守护进程"><a href="#8-控制服务与守护进程" class="headerlink" title="8 控制服务与守护进程"></a>8 控制服务与守护进程</h1><h2 id="8-1-服务状态关键字段"><a href="#8-1-服务状态关键字段" class="headerlink" title="8.1 服务状态关键字段"></a>8.1 服务状态关键字段</h2><table><thead><tr><th align="left">字段</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">Loaded</td><td align="left">服务单元是否加载到内存</td></tr><tr><td align="left">Active</td><td align="left">服务单元是否在运行，运行了多久</td></tr><tr><td align="left">Main PID</td><td align="left">服务的主进程ID，包括命令名称</td></tr><tr><td align="left">Status</td><td align="left">有关该服务的其他信息</td></tr></tbody></table><h2 id="8-2-systemctl管理服务"><a href="#8-2-systemctl管理服务" class="headerlink" title="8.2 systemctl管理服务"></a>8.2 systemctl管理服务</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">systemctl -t help# 列入.service扩展名，代表服务，如web服务systemctl list-units --type service  列出当前服务器加载的服务单元systemctl  status  httpd.service     查看某个服务    [root@servera system]# systemctl status httpd# 查看服务是否启动[root@servera system]# systemctl  is-active httpdactive# 查看服务是否开机启动[root@servera system]# systemctl enable httpd[root@servera system]# systemctl is-enabled httpdenabled[root@servera system]# systemctl disable httpdRemoved /etc/systemd/system/multi-user.target.wants/httpd.service.[root@servera system]# systemctl is-enabled httpddisabled# 常见特征：1、安装   yum install -y httpd2、启动   systemctl  start  httpd.service （单元文件）/usr/lib/systemd/system/3、查进程 ps aux | grep httpd , 每个服务有自己的守护进程/usr/sbin/httpd4、查端口 netstat -ntlp ，找到80端口，对应Listen监听状态 对应httpd服务# vim /etc/service  该文件记录了系统服务的端口和协议的对应关系<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="8-3-服务状态分类"><a href="#8-3-服务状态分类" class="headerlink" title="8.3 服务状态分类"></a>8.3 服务状态分类</h2><table><thead><tr><th align="left">关键字</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">loaded</td><td align="left">单元配置文件已处理</td></tr><tr><td align="left">active（running）</td><td align="left">正在通过一个或多个持续进程与运行</td></tr><tr><td align="left">active（exited）</td><td align="left">已成功完成一次性配置</td></tr><tr><td align="left">active（waiting）</td><td align="left">运行中，但正在等待事件</td></tr><tr><td align="left">inactive</td><td align="left">不在运行</td></tr><tr><td align="left">enabled</td><td align="left">在系统引导时启动</td></tr><tr><td align="left">disabled</td><td align="left">未设为在系统引导时启动</td></tr><tr><td align="left">static</td><td align="left">无法启动，但可以由某一启动的单元自动启动</td></tr></tbody></table><h2 id="8-4-管理系统服务"><a href="#8-4-管理系统服务" class="headerlink" title="8.4 管理系统服务"></a>8.4 管理系统服务</h2><p>  语法：systemctl 管理命令 unitname</p><table><thead><tr><th align="left">管理命令</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">status</td><td align="left">查看状态</td></tr><tr><td align="left">start</td><td align="left">开启</td></tr><tr><td align="left">stop</td><td align="left">关闭</td></tr><tr><td align="left">restart</td><td align="left">重启</td></tr><tr><td align="left">reload</td><td align="left">加载配置文件</td></tr><tr><td align="left">enable</td><td align="left">开机启动</td></tr><tr><td align="left">disable</td><td align="left">关闭开机启动</td></tr><tr><td align="left">is-active</td><td align="left">查看服务状态是否启动</td></tr><tr><td align="left">is-enabled</td><td align="left">查看服务是否开机自启动</td></tr><tr><td align="left">list-dependencies 【unitname】</td><td align="left">查看单元依赖</td></tr><tr><td align="left">mask</td><td align="left">禁止服务，无法启动或开机启动</td></tr><tr><td align="left">unmask</td><td align="left">解除码</td></tr></tbody></table><h1 id="9-OPENSSH服务"><a href="#9-OPENSSH服务" class="headerlink" title="9 OPENSSH服务"></a>9 OPENSSH服务</h1><h2 id="9-1-ssh常用功能"><a href="#9-1-ssh常用功能" class="headerlink" title="9.1 ssh常用功能"></a>9.1 ssh常用功能</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@servera ~]# vim /etc/hosts     系统是否做了dns,ip和域名及主机名的映射[root@servera ~]# ssh root@172.25.250.11[root@serverb /]# scp root@172.25.250.10:/opt/newfile  .root@172.25.250.10's password: newfile                                                  100%    0     0.0KB/s   00:00 [root@servera opt]# ssh root@172.25.250.11 'yum install -y httpd'ssh root@172.25.250.11 'yum install -y httpd'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="9-2-ssh免密登录"><a href="#9-2-ssh免密登录" class="headerlink" title="9.2 ssh免密登录"></a>9.2 ssh免密登录</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@servera ssh]# ssh-keygen  后面三个回车[root@servera ssh]# ssh-copy-id  root@serverb[root@serverb /]# cd /root/.ssh/[root@serverb .ssh]# lsauthorized_keys  known_hosts[root@servera ssh]# ssh root@serverb# a免密远程b，如果想b远程a免密，需要相同的配置<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="9-3-ssh服务控制"><a href="#9-3-ssh服务控制" class="headerlink" title="9.3 ssh服务控制"></a>9.3 ssh服务控制</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 拒绝root登录[root@serverb ~]# vim /etc/ssh/sshd_configPermitRootLogin no[root@serverb ~]# systemctl reload sshd（或restart）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="9-4-sudo命令"><a href="#9-4-sudo命令" class="headerlink" title="9.4 sudo命令"></a>9.4 sudo命令</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 将用户设置为特权用户[student@servera ~]$ yum remove -y httpdError: This command has to be run under the root user.[root@servera /]# vim /etc/sudoers    或者 visudo## Allow root to run any commands anywhere root    ALL=(ALL)       ALLstudent ALL=(ALL)       ALL[student@servera ~]$ sudo yum remove -y httpd[sudo] password for student: student# 将账号添加到特权用户组中，培训环境默认特权用户组是wheel组，在/etc/sudoers文件中用%wheel来表示usermod -G wheel tom# 设置特权组中用户切换时不需要密码%admin  ALL=(ALL)       NOPASSWD: ALL# 添加一个特权组admin，而且组内有一个成员是harry。最终harry账号应当为特权账号[root@serverb ~]# groupadd admin[root@serverb ~]# visudo[root@serverb ~]# useradd -G admin harry[root@serverb ~]# su - harry[harry@serverb ~]$ sudo -i[sudo] password for harry: <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="10-日志分析与存储"><a href="#10-日志分析与存储" class="headerlink" title="10 日志分析与存储"></a>10 日志分析与存储</h1><h2 id="10-1-系统中的日志文件"><a href="#10-1-系统中的日志文件" class="headerlink" title="10.1 系统中的日志文件"></a>10.1 系统中的日志文件</h2><table><thead><tr><th align="left">日志文件</th><th align="left">存储的消息类型</th></tr></thead><tbody><tr><td align="left">/var/log/messages</td><td align="left">大多数系统日志消息处存放处</td></tr><tr><td align="left">/var/log/secure</td><td align="left">与安全性和身份验证时间相关的syslog消息</td></tr><tr><td align="left">/var/log/maillog</td><td align="left">与邮件服务器相关的syslog消息</td></tr><tr><td align="left">/var/log/cron</td><td align="left">与计划任务执行相关的syslog消息</td></tr><tr><td align="left">/var/log/boot.log</td><td align="left">与系统启动相关的消息</td></tr></tbody></table><h3 id="10-1-1-rsyslog服务管理日志"><a href="#10-1-1-rsyslog服务管理日志" class="headerlink" title="10.1.1 rsyslog服务管理日志"></a>10.1.1 rsyslog服务管理日志</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@haha log]# yum provides /etc/rsyslog.conf  #查看文件是哪个软件包提供的[root@clear log]# rpm -qc rsyslog-8.1911.0-3.el8.x86_64 /etc/logrotate.d/syslog/etc/rsyslog.conf       #一般服务文件以.conf结尾，改文件是日志服务的配置文件/etc/sysconfig/rsyslog[root@clear log]# vim /etc/rsyslog.conf<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="10-1-2-记录日志的规则"><a href="#10-1-2-记录日志的规则" class="headerlink" title="10.1.2 记录日志的规则"></a>10.1.2 记录日志的规则</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#日志文件配置格式: mail.info  /var/log/vsftpd.log  #.点代表包含后面级别及以上级别AAAA.BBBB CCCCAAAA 产生日志的设备（类别）    #如何产生的日志BBBB 日志的级别              #日志有不同安全级别，类似轻重缓急的严重程度，发出警告CCCC 保存日志的位置          #在系统中保存日志文件的路径<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="10-1-3-rsyslog配置文件类别"><a href="#10-1-3-rsyslog配置文件类别" class="headerlink" title="10.1.3 rsyslog配置文件类别"></a>10.1.3 rsyslog配置文件类别</h3><table><thead><tr><th align="left">类别</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">Kern</td><td align="left">内核</td></tr><tr><td align="left">authpriv</td><td align="left">授权和安全</td></tr><tr><td align="left">cron</td><td align="left">计划任务</td></tr><tr><td align="left">mail</td><td align="left">邮件</td></tr><tr><td align="left">daemon</td><td align="left">系统守护进程</td></tr><tr><td align="left">user</td><td align="left">普通用户级别的</td></tr><tr><td align="left">syslog</td><td align="left">由rsyslog生成的信息</td></tr><tr><td align="left">loca10~loca17</td><td align="left">自定义本地策略</td></tr><tr><td align="left">*</td><td align="left">所有类别</td></tr></tbody></table><h3 id="10-1-4-日志级别"><a href="#10-1-4-日志级别" class="headerlink" title="10.1.4 日志级别"></a>10.1.4 日志级别</h3><table><thead><tr><th align="left">等级</th><th align="left">解释</th></tr></thead><tbody><tr><td align="left">EMERG（紧急）</td><td align="left">会导致主机系统不可用的情况</td></tr><tr><td align="left">ALERT（警告）</td><td align="left">必须马上采取措施解决的问题</td></tr><tr><td align="left">CRIT（严重）</td><td align="left">比较严重的情况</td></tr><tr><td align="left">ERR（错误）</td><td align="left">运行出现错误</td></tr><tr><td align="left">WARNING（提醒）</td><td align="left">可能会影响系统功能的事件</td></tr><tr><td align="left">NOTICE（注意）</td><td align="left">不会影响系统但值得注意</td></tr><tr><td align="left">INFO（信息）</td><td align="left">一般信息</td></tr><tr><td align="left">DEBUG（调试）</td><td align="left">程序或系统调试信息等</td></tr><tr><td align="left">*</td><td align="left">所有等级</td></tr><tr><td align="left">none</td><td align="left">不记录日志</td></tr></tbody></table><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">*.info;mail.none;authpriv.none;cron.none                /var/log/messages*.info    # *代表所有级别    .点代表后面的等级及以上等级，也就是info以上的等级全记录；分号是不同设备等级的分隔符号-/var/log/maillog   # - 代表先记录缓存，再记录硬盘，减轻硬盘i/o读写压力<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="10-1-5-logger发送测试日志"><a href="#10-1-5-logger发送测试日志" class="headerlink" title="10.1.5 logger发送测试日志"></a>10.1.5 logger发送测试日志</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">1 查看rsyslog服务是否开启 (默认系统已开启)[root@servera ~]# systemctl status rsyslog2 编辑rsyslog配置文件[root@servera ~]# vim /etc/rsyslog.conf# Save boot messages also to boot.loglocal7.*                                                /var/log/boot.log..*.debug                                                 /var/log/messages.debug3 重启rsyslog日志服务让配置生效[root@servera ~]# systemctl restart rsyslog4 开另一个窗口 ctrl+shift+t[root@servera ~]# tail -n 0 -f /var/log/messages.debug   5 使用logger命令生成一个user类别，debug级别的日志内容为“Debug test messages”  #（考点）[root@servera ~]# logger -p user.debug "Debug test messages"    6 在第4步的窗口中查看新生成日志信息[root@servera ~]# tail -n 0 -f /var/log/messages.debugJun 18 14:45:31 servera root[29174]: messages haha<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="10-2-journalctl"><a href="#10-2-journalctl" class="headerlink" title="10.2 journalctl"></a>10.2 journalctl</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 传统的日志服务是rsyslog# 新的日志服务是systemd-journal，它也是一个日志管理服务，可以收集来自内核、系统早期启动阶段的日志，以及系统进程在启动和运行中的一些标准输出与错误输出# systemd-journal一旦重启既消失，因为保存在了/run/log/journal/*/*.journal结尾，该文件是一个二进制日志文件，需要用journalctl命令查看journalctl      #查看系统日志journalctl -n   #通过q或ctrl接触观看  ，此命令显示方式类似与tail -njournalctl -n 5 journalctl -p err  日志等级journalctl -f journalctl -p err journalctl -p info  （deubg、info、notice、warning、err、crit、alert、emerg）journalctl --since "2020-02-28 22:53:35" --until "2020-02-28 22:53:40"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="10-2-1-journalctl常用字段"><a href="#10-2-1-journalctl常用字段" class="headerlink" title="10.2.1 journalctl常用字段"></a>10.2.1 journalctl常用字段</h3><table><thead><tr><th align="left">常用字段</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">_COMM</td><td align="left">命令名称</td></tr><tr><td align="left">_EXE</td><td align="left">进程的可执行文件的路径</td></tr><tr><td align="left">_PID</td><td align="left">进程的PID</td></tr><tr><td align="left">_UID</td><td align="left">UID</td></tr><tr><td align="left">_SYSTEM_UNIT</td><td align="left">启动该进程的systemd单元</td></tr></tbody></table><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">journalctl -o verbose journalctl _HOSTNAME=localhostjournalctl _HOSTNAME=localhost _PID=1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="102-2-保存journal服务文件"><a href="#102-2-保存journal服务文件" class="headerlink" title="102.2 保存journal服务文件"></a>102.2 保存journal服务文件</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mandbman -k journalman 5 journald.conf  ， Storage=[root@clear journal]# ll -d /run/log/journal[root@clear journal]# cp -a /run/log/journal/ /var/log/journal[root@clear journal]# ll -d /var/log/journaldrwxr-sr-x. 4 root systemd-journal 86 Nov 19 04:30 /var/log/journal[root@clear journal]# systemctl restart systemd-journald[root@clear journal]# ll /var/log/journal/3a2b4da8dabb4729935c193e58ad052d/  #字符串目录名字每个人的可能不一样。不要复制我的笔记。total 8192-rw-r-----. 1 root root 8388608 Nov 19 04:30 system.journal[root@clear journal]# journalctl<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="10-3-准确的系统时间"><a href="#10-3-准确的系统时间" class="headerlink" title="10.3 准确的系统时间"></a>10.3 准确的系统时间</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># RHEL6 ntp服务# RHEL8 chrony服务# 还是使用同样的协议标准ntp（network time protocol）UTC：通用协调时   （UTC时间0点是北京时间8点,因为中国、新加坡、马来西亚、菲律宾等国的时间与UTC的时差均为+8,也就是UTC+8,所以当UTC时间0点,北京时间即为0+8=8点）GMT：格林威治标准时间CST：中国标准时间 (China Standard Time）    （中国大陆、中国香港、中国澳门、中国台湾、蒙古国、新加坡、马来西亚、菲律宾、西澳大利亚州的时间与UTC的时差均为＋8，也就是UTC+8）RTC：(Real-Time Clock)也称为硬件时间：RTC是芯片内置的硬件时钟，只要芯片不断电，即使操作系统关机的时候，RTC时钟也是正常在      走的，所以当操作系统关机重启后，可通过读取RTC时间来更新系统时间    （可通过hwclock命令来获取具体的时间       -r 查看硬件时间      -s 硬件时间设置到系统      -w 系统设置到硬件）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="10-3-1-timedatectl命令"><a href="#10-3-1-timedatectl命令" class="headerlink" title="10.3.1 timedatectl命令"></a>10.3.1 timedatectl命令</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@servera log]# timedatectl                Local time: Sat 2020-02-29 08:51:49 CST           Universal time: Sat 2020-02-29 00:51:49 UTC                 RTC time: Sat 2020-02-29 08:11:07                Time zone: Asia/Shanghai (CST, +0800)System clock synchronized: yes              NTP service: active          RTC in local TZ: no          [root@servera log]# timedatectl list-timezones     [root@servera log]# timedatectl set-timezone Asia/Hong_Kong [root@servera log]# timedatectl                Local time: Sat 2020-02-29 08:55:48 HKT           Universal time: Sat 2020-02-29 00:55:48 UTC                 RTC time: Sat 2020-02-29 08:15:06                Time zone: Asia/Hong_Kong (HKT, +0800)System clock synchronized: yes              NTP service: active          RTC in local TZ: no# 修改时间方法timedatectl set-time "2020-02-30 10:00:00"Failed to set time: NTP unit is activetimedatectl set-ntp false timedatectl set-time "2020-02-30 10:00:00"timedatectl set-ntp true <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="10-3-2-chrony命令"><a href="#10-3-2-chrony命令" class="headerlink" title="10.3.2 chrony命令"></a>10.3.2 chrony命令</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">server===server选项格式===server host  [ key n ] [ version n ] [ prefer ] [ mode n ] [ minpoll n ] [ maxpoll n ] [ iburst ]其中host是上层NTP服务器的IP地址或域名，随后所跟的参数解释如下所示：◆ key： 表示所有发往服务器的报文包含有秘钥加密的认证信息，n是32位的整数，表示秘钥号。◆ version： 表示发往上层服务器的报文使用的版本号，n默认是3，可以是1或者2。◆ prefer： 如果有多个server选项，具有该参数的服务器有限使用。◆ mode： 指定数据报文mode字段的值。◆ minpoll： 指定与查询该服务器的最小时间间隔为2的n次方秒，n默认为6，范围为4-14。◆ maxpoll：  指定与查询该服务器的最大时间间隔为2的n次方秒，n默认为10，范围为4-14。◆ iburst： 当初始同步请求时，采用突发方式接连发送8个报文，时间间隔为2秒。[root@servera ~]# systemctl enable --now chronyd    #--now启动服务 enable 开机自动[root@servera ~]# systemctl status chronyd[root@servera ~]# vim /etc/chrony.conf   #大概第7行 server 后面添加服务器'地址'或'域名'。server classroom.exmaple.com iburst[root@servera ~]# systemctl  restart chronyd.service[root@servera ~]# chronyc sources -v<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="11-RHEL网络管理"><a href="#11-RHEL网络管理" class="headerlink" title="11 RHEL网络管理"></a>11 RHEL网络管理</h1><h2 id="11-1-IPv4地址"><a href="#11-1-IPv4地址" class="headerlink" title="11.1 IPv4地址"></a>11.1 IPv4地址</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">IP/(NETMASK\|PREFIX)   172.25.0.9/255.255.0.0 \| 172.25.0.9/16--- ---------------------- --------------------------------------------GATEWAY                172.25.x.xDNS                    正向解析 \# host servera， 反向解析 \# host私有地址：A　１－１２７B　１２８－１９１C　１９２－２２３IP地址分类默认对应的子网掩码掩码：Ａ：２５５．０．０．０         11111111.00000000.00000000.00000000     /8Ｂ：２５５．２５５．０．０      11111111.11111111.00000000.00000000     /16Ｃ：２５５．２５５．２５５．０  11111111.11111111.11111111.00000000     /24<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="11-1-1-IP与掩码二进制与运算"><a href="#11-1-1-IP与掩码二进制与运算" class="headerlink" title="11.1.1 IP与掩码二进制与运算"></a>11.1.1 IP与掩码二进制与运算</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">网络地址   172.25.0.0       主机位全0---------- ---------------- -----------广播地址   172.25.255.255   主机位全1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="11-1-2-查看ipv4与ipv6"><a href="#11-1-2-查看ipv4与ipv6" class="headerlink" title="11.1.2 查看ipv4与ipv6"></a>11.1.2 查看ipv4与ipv6</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 查看ip地址方法1：[root@servera ~]#ifconfig [root@servera ~]#ifconfig  eth0# 查看ip地址方法2：[root@servera ~]# ip addr show eth0[root@servera ~]# ip a  s eth0[root@servera ~]# ip -s link show enp1s0 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="11-1-3-端口与服务"><a href="#11-1-3-端口与服务" class="headerlink" title="11.1.3 端口与服务"></a>11.1.3 端口与服务</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 查看服务端口是否被占用lsof -i:80 或 netstat-n：显示接口和端口编号-t：tcp信息-u：udp信息-l：监听状态信息-a：显示所有信息-p：显示协议名称而不是端口netstat -ntlp | grep 80# 参考ss和netstat区别：https://blog.csdn.net/qq_37863891/article/details/107283415# 标准服务端口 /etc/services<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="11-2-网络管理工具"><a href="#11-2-网络管理工具" class="headerlink" title="11.2 网络管理工具"></a>11.2 网络管理工具</h2><h3 id="11-2-1-nmcli的概念"><a href="#11-2-1-nmcli的概念" class="headerlink" title="11.2.1 nmcli的概念"></a>11.2.1 nmcli的概念</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">1.使用nmcli管理网络服务NetworkManager2.nmcli工具的功能：查看网络设备、创建网络连接、修改网络配置3.nmcli的特点及概念：  nmcli工具可以对网卡或网卡配置文件操作  device ---- 网卡设备  connection --- 连接  指的就是网卡配置文件  一个device可以拥有多个connection，同一时间只能启用一个connection，且一个connection只能属于一个device4.举例：  device-----eth0  connection1  ----  dhcp    自动获取IP    connection2  ----  static  静态IP  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="11-2-2-nmcli管理网络"><a href="#11-2-2-nmcli管理网络" class="headerlink" title="11.2.2 nmcli管理网络"></a>11.2.2 nmcli管理网络</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mandbman -k nmclinmcli (1) nmcli-examples (7)man nmcli | grep -A 2 'nmcli connection add'-basic[root@servera ~]# nmcli connection show [root@servera ~]# nmcli connection show --active [root@servera ~]# nmcli device status -add---添加   dhcp方式: #创建一个名为default的手动链接，绑定至eth0网卡[root@servera ~]# nmcli connection add  con-name 'default' type ethernet ifname eth0  autoconnect yes    [root@servera ~]# nmcli con show    static方式：#创建一个名为static的静态链接，绑定至eth1网卡[root@servera ~]# nmcli connection add con-name static type ethernet ifname eth0 autoconnect yes ipv4.addresses 192.168.0.1/24 ipv4.gateway 192.168.0.254 ipv4.dns 8.8.8.8 ipv4.method manual  [root@servera ~]# nmcli connection showNAME                UUID                                  TYPE      DEVICE Wired connection 1  1f5ad5ae-e926-3f54-9805-33174e63af47  ethernet  eth0   static              980f6712-86b7-4d92-bc84-62e677ccabfc  ethernet  eth1     #此处dhcp                82c4a93f-1ca2-432b-94da-59a6c4f5aaca  ethernet  --     Wired connection 2  e801f880-78a6-3344-857f-588f7495bb26  ethernet  --     [root@servera /]# nmcli connection up static   启动static网卡[root@servera /]# ip a s eth1 | grep -w inet-modify---修改#将链接static网络信息更改： IP：192.168.0.2  mask：/24  gw：192.168.0.200 dns：114.114.114.114[root@servera ~]# nmcli connection modify static ipv4.addresses 192.168.0.2/24 ipv4.gateway 192.168.0.200 ipv4.dns 114.114.114.114 autoconnect yes ipv4.method manual[root@servera ~]# nmcli connection up  static[root@servera ~]# ip a s eth0    inet 192.168.0.2/24 brd 192.168.0.255 scope global noprefixroute eth1   [root@servera ~]# route -nDestination     Gateway         Genmask         Flags Metric Ref    Use Iface0.0.0.0         172.25.250.254  0.0.0.0         UG    100    0        0 eth00.0.0.0         192.168.0.200   0.0.0.0         UG    101    0        0 eth1[root@servera ~]# cat /etc/resolv.conf # Generated by NetworkManagersearch lab.example.com example.comnameserver 172.25.250.254nameserver 114.114.114.114 [root@serverb ~]# nmcli connection delete static  #删除一个链接Connection 'static' (b85e6a57-b8f7-421f-8d15-9ff5e27cbb85) successfully deleted.-up_down---启动与关闭网卡[root@servera /]# nmcli connection down static   关闭static网卡-off---关闭网络服务[root@servera /]# nmcli networking off       关闭网络服务，慎重使<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="11-2-3-图形化管理工具nmtui"><a href="#11-2-3-图形化管理工具nmtui" class="headerlink" title="11.2.3 图形化管理工具nmtui"></a>11.2.3 图形化管理工具nmtui</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">nmtui-edit图形化管理配置通过点击设置--network--网卡设置，ipv4address  netmask  dns  gatewaynmtui-edit[root@servera /]# nmcli connection up static<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="11-2-4-网卡配置文件"><a href="#11-2-4-网卡配置文件" class="headerlink" title="11.2.4 网卡配置文件"></a>11.2.4 网卡配置文件</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">-RHEL8 版本# grep -r IPADDR /usr/share/ #找到下面手册的指令vim /usr/share/doc/initscripts/sysconfig.txt 帮助手册修改配置文件方式修改IP[root@servera ~]# vim /etc/sysconfig/network-scripts/ifcfg-Wired_connection_1BOOTPROTO=none          #获取IP的方式  static--静态 none--不设置 dhcp--自动获取 ，手动配IP选前两个中任意一个ONBOOT=yes              #开机自动连接IPADDR=172.25.250.100   #ip地址PREFIX=24               #子网掩码  PREFIX=24(等效于255.255.255.0)，mask=255.255.255.0 netmask=255.255.255.0GATEWAY=172.25.250.254  #网关DNS1=xxxx               #dns，dns可以有三个 DNS1= DNS2= DNS3=加载网卡配置文件方法一：[root@serverb network-scripts]# nmcli connection reload ifcfg-Wired_connection_1 或 nmcli connection reload[root@serverb network-scripts]# nmcli connection up staticsystemctl restart NetworkManager-RHEL9版本 网卡配置文件位置[root@node1 system-connections]# vim /etc/NetworkManager/system-connections/System\ eth0.nmconnection<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="11-3-更改网络信息"><a href="#11-3-更改网络信息" class="headerlink" title="11.3 更改网络信息"></a>11.3 更改网络信息</h2><h3 id="11-3-1-主机名"><a href="#11-3-1-主机名" class="headerlink" title="11.3.1 主机名"></a>11.3.1 主机名</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@servera ~]# hostnameservera.lab.example.com[root@servera ~]# hostnmae  www.example.com 临时[root@servera ~]# vim /etc/hostname  永久（重启系统:reboot、init 6)[root@servera ~]# hostnamectl set-hostname hostname　永久<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="11-3-2-网关-gateway"><a href="#11-3-2-网关-gateway" class="headerlink" title="11.3.2 网关(gateway)"></a>11.3.2 网关(gateway)</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 使用nmclinmcli con add con-name xxx ipv4.gateway xxx.xxx.xxx.xxx  配置网关nmcli con mod xxx ipv4.gateway xxx.xxx.xxx.xxx           修改网关以上两种改完之后，需要nmcli con up xxx# 修改配置文件vim /etc/sysconfig/network-scripts/ifcfg-xxxxGATEWAY=xxx.xxx.xxx.xxx  修改完后要nmcli con reload ，再nmcli con up xxxx<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="11-3-3-查看路由及网关"><a href="#11-3-3-查看路由及网关" class="headerlink" title="11.3.3 查看路由及网关"></a>11.3.3 查看路由及网关</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@servera ~]# ip route default via 172.25.250.254 dev enp1s0 proto static metric 100 172.25.250.0/24 dev enp1s0 proto kernel scope link src 172.25.250.10 metric 100[root@servera ~]# route -nKernel IP routing tableDestination     Gateway         Genmask         Flags Metric Ref    Use Iface0.0.0.0         172.25.250.254  0.0.0.0         UG    100    0        0 enp1s0172.25.250.0    0.0.0.0         255.255.255.0   U     100    0        0 enp1s0[root@servera ~]# nmcli connection show Wired\ connection\ 1 | grep ipv4.gaipv4.gateway:                           172.25.250.254[root@servera ~]# netstat -nrKernel IP routing tableDestination     Gateway         Genmask         Flags   MSS Window  irtt Iface0.0.0.0         172.25.250.254  0.0.0.0         UG        0 0          0 enp1s0172.25.250.0    0.0.0.0         255.255.255.0   U         0 0          0 enp1s0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="11-3-4-指定DNS"><a href="#11-3-4-指定DNS" class="headerlink" title="11.3.4 指定DNS"></a>11.3.4 指定DNS</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">vim /etc/resolv.conf   #该文件指定dns和域名的/etc/sysconfig/network-scripts/ifcfg-xxx中的DNS字段会同步到/etc/resolv.conf，后者优先。nameserver 172.25.250.254# 测DNS域名解析是否正常[root@servera ~]# host classroom.example.com classroom.example.com has address 172.25.254.254[root@servera ~]# nslookup classroom.example.comServer:     172.25.250.254Address:    172.25.250.254#53Name:   classroom.example.comAddress: 172.25.254.254[root@servera ~]# dig classroom.example.com<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="12-归档与系统间复制文件"><a href="#12-归档与系统间复制文件" class="headerlink" title="12 归档与系统间复制文件"></a>12 归档与系统间复制文件</h1><h2 id="12-1-归档及压缩"><a href="#12-1-归档及压缩" class="headerlink" title="12.1 归档及压缩"></a>12.1 归档及压缩</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 语法：tar 选项  归档文件名    源文件 源文件2 源文件N-c  创建-t  查看-f  指定文件名-v  显示详细信息-x  解包-C  指定解包路径man tartar -cvf /root/etc.tar /etc/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="12-1-1-文件及目录打包、解包"><a href="#12-1-1-文件及目录打包、解包" class="headerlink" title="12.1.1 文件及目录打包、解包"></a>12.1.1 文件及目录打包、解包</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 文件打包归档[root@servera opt]#etc.tar  file1  file2  file3[root@servera opt]# tar -cvf file.tar file1 file2 file3[root@servera opt]# lsetc.tar  file1  file2  file3  file.tar# 文件解包[root@servera opt]# tar -xvf file.tar -C /tmp/[root@servera opt]# ls /tmp/file1  rclocal.logfile2  rht-bastionfile3  rht-defaultNIC1   rht-vm-hostsNIC2   systemd-private-ef2feb022cd2465c9dd920878a1d962b-chronyd.service-kRKFp0# 目录打包归档[root@servera opt]# tar -cvf etc.tar /etc[root@servera opt]# lsetc.tar  file1  file2  file3  file.tar# 目录解包[root@servera opt]# tar -xvf etc.tar <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="12-1-2-文件压缩"><a href="#12-1-2-文件压缩" class="headerlink" title="12.1.2 文件压缩"></a>12.1.2 文件压缩</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 只压缩文件[root@servera opt]# gzip file1[root@servera opt]# file file1.gz file1.gz: gzip compressed data, was "file1", last modified: Sun Mar  1 05:54:06 2020, from Unix, original size 0[root@servera opt]# bzip2 file2[root@servera opt]# file file2.bz2 file2.bz2: bzip2 compressed data, block size = 900k[root@servera opt]# xz file.tar [root@servera opt]# lsetc.tar  file1.gz  file2.bz2  file3  file.tar.xz<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="12-1-3-tar打包并压缩"><a href="#12-1-3-tar打包并压缩" class="headerlink" title="12.1.3 tar打包并压缩"></a>12.1.3 tar打包并压缩</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># tar的压缩选项  man tar | grep gzip-z  gzip    -j  bzip2    -J  xz# 打包并压缩 tar -zcvf /root/etc.tar.gz /etc/ file etc.tar.gz  tar -jcvf /opt.tar.bz2 /opt/ tar -Jcvf /root/etc.tar.gz /etc/# 解压缩并指定路径tar -zxvf etc.tar.gz -C /opt/tar xf etc.tar.gz -C /opt/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="12-2-远程传输"><a href="#12-2-远程传输" class="headerlink" title="12.2 远程传输"></a>12.2 远程传输</h2><h3 id="12-2-1-远程文件传输"><a href="#12-2-1-远程文件传输" class="headerlink" title="12.2.1 远程文件传输"></a>12.2.1 远程文件传输</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># scp实现远程文件传输scp servra.txt root@bastion:/opt/scp root@bastion:/opt/bastion.txt .# sftp实现远程文件传输ID    app   roles---- ------- ----------------1     ftp    client2     sftp   ssh SubService3     vsftp  service[root@servera opt]# touch put.txt[root@servera opt]# sftp instructor@classroom.example.cominstructor@classroom.example.com's password: Connected to instructor@classroom.example.com.sftp&gt; cd /tmp/sftp&gt; put /opt/put.txt Uploading /opt/put.txt to /tmp/put.txt/opt/put.txt                                    100%    0     0.0KB/s   00:00    sftp&gt; ls<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="12-2-2-同步文件内容"><a href="#12-2-2-同步文件内容" class="headerlink" title="12.2.2 同步文件内容"></a>12.2.2 同步文件内容</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># rsync  -v  显示详细信息     -a  相当于存档模式  # 本地同步[root@servera tmp]# rsync -av /var/log/* /tmp# 远程同步[root@servera tmp]# rsync -av /var/log/* serverb:/tmp# 将serverb上的/var/log/同步到，servera当前目录下[root@servera tmp]# rsync -av serverb:/var/log/  .<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="13-安装和升级软件包"><a href="#13-安装和升级软件包" class="headerlink" title="13 安装和升级软件包"></a>13 安装和升级软件包</h1><h2 id="13-1-RPM包管理"><a href="#13-1-RPM包管理" class="headerlink" title="13.1 RPM包管理"></a>13.1 RPM包管理</h2><h3 id="13-1-1-rpm包语法"><a href="#13-1-1-rpm包语法" class="headerlink" title="13.1.1 rpm包语法"></a>13.1.1 rpm包语法</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#软件的获取方式： 1、互联网(下载光盘镜像.iso)、直接使用网络yum源 2、光盘#rpm包语法:rpm 选项 包名-i  安装-v  显示过程-h  以易读方式显示进度条-e  卸载rpm -ivh xxx.rpm#示例:1. 在f0中进入软件包的存储位置[root@foundation0 /]# cd /content/rhel8.0/x86_64/dvd/AppStream/Packages/[root@foundation0 Packages]# pwd/content/rhel8.0/x86_64/dvd/AppStream/Packages2.安装软件[root@foundation0 Packages]# rpm -ivh lftp-4.8.4-1.el8.x86_64.rpm<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="13-1-2-rpm包查询命令"><a href="#13-1-2-rpm包查询命令" class="headerlink" title="13.1.2 rpm包查询命令"></a>13.1.2 rpm包查询命令</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#语法:rpm -q 软件包名称-q: query      查询，和其他参数配合-l：list       列出软件包安装后给系统带来的所有文件-a：all        查看所有已安装的软件包-c: configure  查看软件包提供的配置文件rpm -qa | grep telnetrpm -qc openssh-server-8.0p1-4.el8_1.x86_64#卸载RPM包[root@node1 /]# rpm -q telnettelnet-0.17-73.el8.x86_64[root@node1 /]# rpm -e telnet-0.17-73.el8.x86_64[root@node1 /]# rpm -q telnetpackage telnet is not installed<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="13-2-YUM工具"><a href="#13-2-YUM工具" class="headerlink" title="13.2 YUM工具"></a>13.2 YUM工具</h2><h3 id="13-2-1-管理yum源文件"><a href="#13-2-1-管理yum源文件" class="headerlink" title="13.2.1 管理yum源文件"></a>13.2.1 管理yum源文件</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># yum源软件配置方式:[root@servera /]# cd /etc/yum.repos.d/[root@servera yum.repos.d]# mkdir old[root@servera yum.repos.d]# mv * old     #将系统默认的yum源文件移动到old中，可以在该文件中查看原来的yum源路径[root@servera yum.repos.d]# man 5 yum.conf[root@servera yum.repos.d]# vim rhel.repo[AppStream]      #id名称自定义name=AppStream   #描述自定义，和id不必一样baseurl=http://content.example.com/rhel8.4/x86_64/dvd/AppStream   #file:///中://是url格式，第三个/是根目录gpgcheck=0   #gpgchek=1 要进行公钥验证，需要再添加选项gpgkey=http://content.example.com/rhel8.4/x86_64/dvd/RPM-GPG-KEY-redhat-releaseenabled=1[BaseOS]name=BaseOSbaseurl=http://content.example.com/rhel8.4/x86_64/dvd/BaseOSgpgcheck=0enabled=1[root@servera yum.repos.d]# yum clean all           #清除缓存，避免沿用之前缓存的软件[root@servera yum.repos.d]# yum makecache           #和当前yum源建立缓存关联[root@servera yum.repos.d]# yum repolist all        #查看当前yum源状态[root@servera yum.repos.d]# yum install -y telnet   #测试安装软件telnet[root@servera yum.repos.d]# rpm -q telnet           #使用rpm方式查询测试<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="13-2-2-yum源命令配置"><a href="#13-2-2-yum源命令配置" class="headerlink" title="13.2.2 yum源命令配置"></a>13.2.2 yum源命令配置</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">1 找到提供yum-config-manager命令的软件包名称[kiosk@foundation0 ~]$ yum provides yum-config-manager2 安装yum-utils软件 #打开浏览器输入yum源仓库地址，找到yum-utils的软件包，并且通过rpm命令安装网络上的yum-utils软件包，来提通yum-config-manager命令[root@servera ]# rpm -ivh http://content.example.com/rhel8.4/x86_64/dvd/BaseOS/Packages/yum-utils-4.0.18-4.el8.noarch.rpm3  通过yum-config-manager命令部署yum源[root@servera ]# yum-config-manager --help[root@servera ]# yum-config-manager --add-repo=http://content.example.com/rhel8.4/x86_64/dvd/AppStream[root@servera ]# yum-config-manager --add-repo=http://content.example.com/rhel8.4/x86_64/dvd/BaseOS4 命令制作的yum源中没有gpgcheck选项，如何配置？可以通过以下方法：   1、此处可以在/etc/yum.repos.d/xx.repo文件里添加 gpgcheck=0   2、rpm --import ‘公钥地址’   导入公钥` [root@servera yum.repos.d]# rpm --import http://content.example.com/rhel8.4/x86_64/dvd/RPM-GPG- KEY-redhat-release  5.开启或关闭[root@servera /]# yum-config-manager --disable rhel-8.0-for-x86_64-appstream-rpms（yum池ID）[root@servera /]# yum repolist all[root@servera /]# yum-config-manager --enable rhel-8.0-for-x86_64-appstream-rpms[root@servera /]# yum repolist all<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="13-2-3-YUM常见的命令"><a href="#13-2-3-YUM常见的命令" class="headerlink" title="13.2.3 YUM常见的命令"></a>13.2.3 YUM常见的命令</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">yum list http*yum search httpdyum info httpd-manual[root@servera /]# yum provides /var/www/html# yum update# yum install 包名      yum remove 包名[root@servera /]# yum install  -y autofs[root@servera /]# yum remove -y autofs[root@servera /]# yum history# yum clean all      yum repolist     yum repolist all# yum group list     yum groupinfo 'Server with GUI'# yum groupinstall -y 'Server with GUI'# startx 切图形<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="13-3-第三方YUM源"><a href="#13-3-第三方YUM源" class="headerlink" title="13.3 第三方YUM源"></a>13.3 第三方YUM源</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">1.虚拟机联网  虚拟机设置里面NAT选择已连接   nmcli connection up ens192  2.百度搜索（阿里源、华为源...），将.repo文件下载到系统curl -o /etc/yum.repos.d/CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-vault-8.5.2111.repo3.验证cd /etc/yum.repos.d/;lsyum repolist allyum install -y vsftpd<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="14-访问Linux文件系统"><a href="#14-访问Linux文件系统" class="headerlink" title="14 访问Linux文件系统"></a>14 访问Linux文件系统</h1><h2 id="14-1-存储管理"><a href="#14-1-存储管理" class="headerlink" title="14.1 存储管理"></a>14.1 存储管理</h2><h3 id="14-1-1-文件系统、存储和块设备"><a href="#14-1-1-文件系统、存储和块设备" class="headerlink" title="14.1.1 文件系统、存储和块设备"></a>14.1.1 文件系统、存储和块设备</h3><table><thead><tr><th align="left">块设备</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">/dev/sda、/dev/sdb</td><td align="left">STAT/SAS（新SCSI技术）/USB 附加存储</td></tr><tr><td align="left">/dev/vda、/dev/vdb</td><td align="left">virtio-blk 超虚拟化存储（部分虚拟机）</td></tr><tr><td align="left">/dev/nvme0，/dev/nvme1</td><td align="left">附加存储 （SSD）</td></tr><tr><td align="left">/dev/mmcblk0、/dev/mmcblk1</td><td align="left">SD卡</td></tr></tbody></table><h3 id="14-1-2-磁盘分区"><a href="#14-1-2-磁盘分区" class="headerlink" title="14.1.2 磁盘分区"></a>14.1.2 磁盘分区</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 分区--格式化--挂载--使用# mount命令挂载是临时的，意味着重启系统后将取消挂载。需要手动重新挂载# 永久挂载需要将挂载项记入/etc/fstab中1 分区，gpt方案 ，分2个区，每个1G[root@servera ~]# fdisk /dev/vdbCommand (m for help): m   d   delete a partition    #删除分区   n   add a new partition   #创建分区   p   print the partition table  #打印分区表   w   write table to disk and exit   #保存并退出  Create a new label   g   create a new empty GPT partition table  #指定分区方案gpt   o   create a new empty DOS partition table  #指定分区方位mbrCommand (m for help): g   #指定分区方案gptCreated a new GPT disklabel (GUID: D29B3E19-BA51-1042-BFE6-0FD975D1B7DB).Command (m for help): nPartition number (1-128, default 1): #回车First sector (2048-10485726, default 2048):  #回车Last sector, +sectors or +size{K,M,G,T,P} (2048-10485726, default 10485726): +1G  #指定分区大小1GCreated a new partition 1 of type 'Linux filesystem' and of size 1 GiB.Command (m for help): pDisklabel type: gpt  #查看分区方案Device     Start     End Sectors Size Type  #分区表/dev/vdb1   2048 2099199 2097152   1G Linux filesystem  #/dev/vdb 分区为1GCommand (m for help): n   #创建第二个分区Partition number (2-128, default 2): First sector (2099200-10485726, default 2099200): Last sector, +sectors or +size{K,M,G,T,P} (2099200-10485726, default 10485726): +1GCommand (m for help): pDevice       Start     End Sectors Size Type/dev/vdb1     2048 2099199 2097152   1G Linux filesystem/dev/vdb2  2099200 4196351 2097152   1G Linux filesystemCommand (m for help): w  #保存退出[root@servera ~]# fdisk -l /dev/vdb  #查看/dev/vdb分区表Device       Start     End Sectors Size Type/dev/vdb1     2048 2099199 2097152   1G Linux filesystem/dev/vdb2  2099200 4196351 2097152   1G Linux filesystem[root@servera ~]# lsblk /dev/vdb   #lsblk查看块设备NAME   MAJ:MIN RM SIZE RO TYPE MOUNTPOINTvdb    252:16   0   5G  0 disk ├─vdb1 252:17   0   1G  0 part └─vdb2 252:18   0   1G  0 part 2 格式化，将两个分区分别格式化为ext4和xfs文件系统  # mkfs 选项 设备名     -t 指定文件系统类型mkfs -t ext4 /dev/vdb1     mkfs.ext4 /dev/vdb1    [root@servera /]# mkfs -t ext4 /dev/vdb1   #mkfs格式化 ext4是文件系统类型 /dev/vdb1是要格式化的磁盘分区[root@servera /]# echo $?     $?是看上一条命令返回值，0为正确，非0为错误0[root@servera /]# mkfs.xfs /dev/vdb2[root@servera /]# echo $?0[root@servera ~]# lsblk -f[root@servera ~]# lsblk -f /dev/vdb  #查看文件系统类型，NAME   FSTYPE LABEL UUID                                 MOUNTPOINTvdb                                                      ├─vdb1 ext4         ecb332da-5bf4-4b86-b92e-d9da25f22a07 └─vdb2 xfs          b538bf38-2b33-4d53-a785-372627587c52 3 挂载  创建挂载点  mkdir /mnt/disk1  文件系统：格式化后的设备或分区   挂载点：linux中的空目录挂载：mount  文件系统  挂载点    mount  /dev/vdb1  /mnt/disk1卸载：umount 文件系统/挂载点     umount /dev/vdb1 or umount /mnt/disk1#挂载[root@servera ~]# lsblk -f /dev/vdbNAME   FSTYPE LABEL UUID                                 MOUNTPOINTvdb                                                      ├─vdb1 ext4         ecb332da-5bf4-4b86-b92e-d9da25f22a07 └─vdb2 xfs          b538bf38-2b33-4d53-a785-372627587c52 [root@servera ~]# mkdir /mnt/{disk1,disk2}  # 创建挂载点[root@servera ~]# ls /mntdisk1  disk2[root@servera ~]# mount /dev/vdb1 /mnt/disk1  #将/dev/vdb1 挂载到/mnt/disk1目录上[root@servera ~]# df [root@servera ~]# df -Th  #-T 显示文件系统，-h以易读单位显示Filesystem     Type      Size  Used Avail Use% Mounted on/dev/vdb1      ext4      976M  2.6M  907M   1% /mnt/disk1/dev/vdb2      xfs      1014M   40M  975M   4% /mnt/disk2[root@servera ~]# tree /mnt//mnt/├── disk1│   ├── haha.txt│   └── lost+found└── disk2    └── heihei.txt 卸载   [root@servera ~]# cd /mnt/disk2[root@servera disk2]# umount /dev/vdb2      #使用时不能卸载umount: /mnt/disk2: target is busy.[root@servera disk2]# cd /    #需要退出挂载点[root@servera /]# umount /dev/vdb2   #卸载[root@servera /]# df -h | tail -2tmpfs           183M     0  183M   0% /run/user/0/dev/vdb1       976M  2.6M  907M   1% /mnt/disk1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="14-1-3-检查文件系统"><a href="#14-1-3-检查文件系统" class="headerlink" title="14.1.3 检查文件系统"></a>14.1.3 检查文件系统</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># df查看系统挂载状态-T 查看文件系统类型-h 以易读方式列出容量单位du查看文件大小[root@servera /]# du /etc/[root@servera /]# du -h /etc/[root@servera /]# du -sh  /etc/24M /etc/[root@servera /]# du /etc/man_db.conf 8   /etc/man_db.conf[root@servera /]# du /etc/man_db.conf  -h  #占用了的块大小，linux默认一个块4k8.0K    /etc/man_db.conf[root@servera /]# ll /etc/man_db.conf -rw-r--r--. 1 root root 5165 Nov  7  2018 /etc/man_db.conf<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="14-2-文件查找"><a href="#14-2-文件查找" class="headerlink" title="14.2 文件查找"></a>14.2 文件查找</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># locateupdatedb      #收集所有文件元数据locate passwdlocate -i imagelocate -n 5  image   #显示前5行# findfind  查找范围  查找条件   动作(可选)find /  -name  passwd-name： 以文件名的形式查找-size： 根据文件大小 -size 1k ：大小为1k的文件，+1k大于1k的文件，-1k小于1k的文件-user /  -uid： 文件所有者   -user studnet  ：student是用户名，查找student拥有的文件-group / -gid-perm： 权限查找     -perm 700 ：搜索权限为700的文件-type： 按文件类型   -type f ： f表示文件，d表示目录-exec： 选项后接Linux指令，操作查找到的文件  command {} ; find /etc -name sshd_configfind / -user student | xargs ls -lfind / -perm 700 -type d -user student | xargs ls -ldfind /etc -type f -size +3k  -and -size -10k  find / -perm -4000 | xargs ls -ld将系统中student用户的文件复制到/root/studentdir目录中，并且保留权限[root@servera ~]# find / -user student -exec cp -a {} /root/studentdir/ \;将系统中student用户的文件列表保存到/root/studentdir文件中find / -user student &gt; /root/studentdir<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="14-3-ln-软链接与硬链接"><a href="#14-3-ln-软链接与硬链接" class="headerlink" title="14.3 ln 软链接与硬链接"></a>14.3 ln 软链接与硬链接</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 软链接(符号链接)：使用范围广，方便访问源文件# 文件链接创建方式：ln -s 源文件   链接文件ln -s dir1 linkdir1#硬链接：节省系统空间    ln 源文件  链接文件ln /opt/sou_file.txt /opt/link_file.txt# 取消链接[root@servera opt]# unlink /opt/link_file.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="14-4-软链接和硬链接区别"><a href="#14-4-软链接和硬链接区别" class="headerlink" title="14.4 软链接和硬链接区别"></a>14.4 软链接和硬链接区别</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">1.命令相同 参数不同2.硬链接的权限和源文件完全一致、软链接的链接文件权限永远是777，和源文件权限不同3.硬链接可以删除，移动源文件、软链接不可以删除，移动源文件4.软链接inode和源文件不同、硬链接的inode的源文件相同5.软链接可以对目录及文件生效、硬链接只可以对文件操作6.软链接可以跨文件系统、硬链接不可以跨文件系统<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux的基本使用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令</title>
      <link href="/2022/04/28/linux/linux-ming-ling/"/>
      <url>/2022/04/28/linux/linux-ming-ling/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux命令 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
